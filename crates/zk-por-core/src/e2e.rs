use itertools::Itertools;
use plonky2::plonk::proof::ProofWithPublicInputs;
use rayon::prelude::*;

use crate::{
    account::Account, circuit_registry::registry::CircuitRegistry, merkle_sum_prover::prover::MerkleSumTreeProver, recursive_prover::prover::RecursiveProver, types::{C, D, F}
};

pub fn batch_prove_accounts<const RECURSION_FACTOR : usize>(circuit_registry: &CircuitRegistry<RECURSION_FACTOR>, account_batches : Vec<Vec<Account>>, parallism : usize) -> Vec<ProofWithPublicInputs<F, C, D>> {
    let mut batch_proofs: Vec<ProofWithPublicInputs<F, C, D>> = Vec::new();
    let (batch_circuit, account_targets) = circuit_registry.get_batch_circuit();

    account_batches
        .into_iter()
        .chunks(parallism)
        .into_iter()
        .map(|chunk| chunk.collect())
        .for_each(|chunk: Vec<Vec<Account>>| {
            let proofs: Vec<ProofWithPublicInputs<F, C, D>> = chunk
                .into_par_iter()
                .map(|accounts| {
                    let prover = MerkleSumTreeProver { accounts };
                    let proof = prover
                        .get_proof_with_circuit_data(account_targets.clone(), &batch_circuit);
                    proof
                    // TODO: parse tree node from proof and check against the one generated by merkle sum tree.
                })
                .collect();
            batch_proofs.extend(proofs.into_iter());
        });

    batch_proofs
}

pub fn recursive_prove_subproofs<const RECURSION_FACTOR : usize>(subproofs : Vec<ProofWithPublicInputs<F,C,D>>, circuit_registry: &CircuitRegistry<RECURSION_FACTOR>, parallism : usize) -> ProofWithPublicInputs<F, C, D> {
    let (batch_circuit, _) = circuit_registry.get_batch_circuit();
    let mut last_level_circuit_vd = batch_circuit.verifier_only.clone();
    let mut last_level_proofs = subproofs;
    let recursive_levels = circuit_registry.get_recursive_levels();

    for level in 0..recursive_levels {
        let start = std::time::Instant::now();
        let last_level_vd_digest = last_level_circuit_vd.circuit_digest;
        let last_level_empty_proof =
            circuit_registry.get_empty_proof(&last_level_vd_digest).expect(
                format!(
                    "fail to find empty proof at recursive level {} with inner circuit vd {:?}",
                    level, last_level_vd_digest
                )
                .as_str(),
            );

        let (recursive_circuit, recursive_targets) = circuit_registry
            .get_recursive_circuit(&last_level_vd_digest)
            .expect(format!("No recursive circuit found for level {}", level).as_str());
        let subproof_len = last_level_proofs.len();

        let mut subproof_batches: Vec<Vec<ProofWithPublicInputs<F, C, D>>> = last_level_proofs
            .into_iter()
            .chunks(RECURSION_FACTOR)
            .into_iter()
            .map(|chunk| chunk.collect())
            .collect();

        tracing::info!(
            "Start on recursive Level {}, number of subproofs {}, number of generated proofs {}",
            level,
            subproof_len,
            subproof_batches.len()
        );

        if let Some(last_batch) = subproof_batches.last_mut() {
            let last_batch_size = last_batch.len();

            // fill the last batch with empty subproofs so that it is of size RECURSIVE_FACTOR
            let empty_proofs =
                vec![last_level_empty_proof.clone(); RECURSION_FACTOR - last_batch_size];
            last_batch.extend(empty_proofs.into_iter());
            tracing::debug!("last batch size {} at level {}, fill last batch with {} empty proofs fit into {} proofs", last_batch_size, level, RECURSION_FACTOR - last_batch_size, RECURSION_FACTOR);
        } else {
            panic!("No last proof batches found in the level {}", level);
        }

        let mut this_level_proofs = vec![];

        let chunks : Vec<Vec<Vec<ProofWithPublicInputs<F, C, D>>>> = subproof_batches.into_iter().chunks(parallism).into_iter().map(|chunk| chunk.collect()).collect();

        chunks.into_iter().for_each(|chunk: Vec<Vec<ProofWithPublicInputs<F, C, D>>>| {
            let proofs: Vec<ProofWithPublicInputs<F, C, D>> = chunk
                .into_par_iter()
                .map(|subproofs| {
                    let sub_proofs: [ProofWithPublicInputs<F, C, D>; RECURSION_FACTOR] =
                        subproofs
                            .try_into()
                            .expect("subproofs length not equal to RECURSIVE_FACTOR");
                    let recursive_prover = RecursiveProver {
                        sub_proofs,
                        sub_circuit_vd: last_level_circuit_vd.clone(),
                    };
                    let proof = recursive_prover.get_proof_with_circuit_data(
                        recursive_targets.clone(),
                        &recursive_circuit,
                    );
                    // TODO: consider valid proof and parse the tree node from the proof and check against the one generated by merkle sum tree.
                    proof
                })
                .collect();
            this_level_proofs.extend(proofs.into_iter());
            tracing::info!(
                "finish generating {} proofs at level {}",
                this_level_proofs.len(),
                level
            );
        });

        last_level_circuit_vd = recursive_circuit.verifier_only.clone();
        last_level_proofs = this_level_proofs;
        tracing::info!(
            "finish recursive level {} with {} proofs in : {:?}",
            level,
            last_level_proofs.len(),
            start.elapsed()
        );
    }

    if last_level_proofs.len() != 1 {
        panic!("The last level proofs should be of length 1, but got {}", last_level_proofs.len());
    }
    let root_proof = last_level_proofs.pop().unwrap();
    circuit_registry
        .get_root_circuit()
        .verify(root_proof.clone())
        .expect("fail to verify root proof");
    root_proof
}