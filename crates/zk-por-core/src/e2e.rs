use itertools::Itertools;
use plonky2::plonk::proof::ProofWithPublicInputs;
use rayon::prelude::*;
use std::sync::mpsc::Receiver;

use crate::{
    account::Account,
    circuit_registry::registry::CircuitRegistry,
    merkle_sum_prover::prover::MerkleSumTreeProver,
    recursive_prover::prover::RecursiveProver,
    types::{C, D, F},
};

/// Batch prove the accounts streamed from a channel, to avoid loading all accounts into memory.
/// then recursively prove the proofs generated from the batch proving.
/// finally return the root proof.
pub fn stream_prove<const RECURSIVE_FACTOR: usize>(
    accounts_receiver: Receiver<Vec<Account>>,
    circuit_registry: &CircuitRegistry<RECURSIVE_FACTOR>,
    batch_size: usize,
    concurrency: usize,
) -> ProofWithPublicInputs<F, C, D> {
    let mut received_num = 0;
    let mut batch_proofs: Vec<ProofWithPublicInputs<F, C, D>> = Vec::new();
    let (batch_circuit, account_targets) = circuit_registry.get_batch_circuit();
    let start = std::time::Instant::now();
    for accounts in accounts_receiver {
        received_num += 1;
        let account_num = accounts.len();
        // assert account_num is a multiple of batch_size
        assert_eq!(account_num % batch_size, 0);

        // split accounts into vector of batch_size
        let account_batches: Vec<Vec<Account>> = accounts
            .into_iter()
            .chunks(batch_size)
            .into_iter()
            .map(|chunk| chunk.collect())
            .collect();

        tracing::info!(
            "received {} in stream, with number of accounts {}, number of batches {}",
            received_num,
            account_num,
            account_batches.len(),
        );

        // avoid padding due to the above assertions
        // if let Some(last_batch) = account_batches.last_mut() {
        //     let last_batch_size = last_batch.len();

        //     // fill the last batch with empty accounts so that it is of size batch_size
        //     let empty_accounts = gen_empty_accounts(batch_size - last_batch_size, asset_num); // TODO: to be consistent with the one used for building merkle tree.
        //     last_batch.extend(empty_accounts.into_iter());
        // } else {
        //     panic!("No account batches found in the file {}", account_path.to_str().unwrap());
        // }

        // split account_batches into chunks of size PROVING_THREADS_NUM and then parallelize the proving in each chunk.
        account_batches
            .into_iter()
            .chunks(concurrency)
            .into_iter()
            .map(|chunk| chunk.collect())
            .for_each(|chunk: Vec<Vec<Account>>| {
                let proofs: Vec<ProofWithPublicInputs<F, C, D>> = chunk
                    .into_par_iter()
                    .map(|accounts| {
                        let prover = MerkleSumTreeProver { accounts };
                        let proof = prover
                            .get_proof_with_circuit_data(account_targets.clone(), &batch_circuit);
                        proof
                        // TODO: parse tree node from proof and check against the one generated by merkle sum tree.
                    })
                    .collect();
                batch_proofs.extend(proofs.into_iter());
                tracing::debug!(
                    "finish proving {} batches after {} stream inputs",
                    batch_proofs.len(),
                    received_num
                );
            });
    }
    tracing::info!("finish proving {} batches in : {:?}", batch_proofs.len(), start.elapsed());

    let mut last_level_circuit_vd = batch_circuit.verifier_only.clone();
    let mut last_level_proofs = batch_proofs;
    let recursive_levels = circuit_registry.get_recursive_levels();
    for level in 0..recursive_levels {
        let start = std::time::Instant::now();
        let last_level_vd_digest = last_level_circuit_vd.circuit_digest;
        let last_level_empty_proof =
            circuit_registry.get_empty_proof(&last_level_vd_digest).expect(
                format!(
                    "fail to find empty proof at recursive level {} with inner circuit vd {:?}",
                    level, last_level_vd_digest
                )
                .as_str(),
            );

        let (recursive_circuit, recursive_targets) = circuit_registry
            .get_recursive_circuit(&last_level_vd_digest)
            .expect(format!("No recursive circuit found for level {}", level).as_str());
        let subproof_len = last_level_proofs.len();

        let mut subproof_batches: Vec<Vec<ProofWithPublicInputs<F, C, D>>> = last_level_proofs
            .into_iter()
            .chunks(RECURSIVE_FACTOR)
            .into_iter()
            .map(|chunk| chunk.collect())
            .collect();

        tracing::debug!(
            "Start on recursive Level {}, number of subproofs {}, number of generated proofs {}",
            level,
            subproof_len,
            subproof_batches.len()
        );
        if let Some(last_batch) = subproof_batches.last_mut() {
            let last_batch_size = last_batch.len();

            // fill the last batch with empty subproofs so that it is of size RECURSIVE_FACTOR
            let empty_proofs =
                vec![last_level_empty_proof.clone(); RECURSIVE_FACTOR - last_batch_size];
            last_batch.extend(empty_proofs.into_iter());
            tracing::debug!("last batch size {} at level {}, fill last batch with {} empty proofs fit into {} proofs", last_batch_size, level, RECURSIVE_FACTOR - last_batch_size, RECURSIVE_FACTOR);
        } else {
            panic!("No last proof batches found in the level {}", level);
        }

        let mut this_level_proofs = vec![];

        subproof_batches
            .into_iter()
            .chunks(concurrency)
            .into_iter()
            .map(|chunk| chunk.collect())
            .for_each(|chunk: Vec<Vec<ProofWithPublicInputs<F, C, D>>>| {
                let proofs: Vec<ProofWithPublicInputs<F, C, D>> = chunk
                    .into_par_iter()
                    .map(|subproofs| {
                        let sub_proofs: [ProofWithPublicInputs<F, C, D>; RECURSIVE_FACTOR] =
                            subproofs
                                .try_into()
                                .expect("subproofs length not equal to RECURSIVE_FACTOR");
                        let recursive_prover = RecursiveProver {
                            sub_proofs,
                            sub_circuit_vd: last_level_circuit_vd.clone(),
                        };
                        let proof = recursive_prover.get_proof_with_circuit_data(
                            recursive_targets.clone(),
                            &recursive_circuit,
                        );
                        // TODO: consider valid proof and parse the tree node from the proof and check against the one generated by merkle sum tree.
                        proof
                    })
                    .collect();
                this_level_proofs.extend(proofs.into_iter());
                tracing::info!(
                    "finish generating {} proofs at level {}",
                    this_level_proofs.len(),
                    level
                );
            });

        last_level_circuit_vd = recursive_circuit.verifier_only.clone();
        last_level_proofs = this_level_proofs;
        tracing::info!(
            "finish recursive level {} with {} proofs in : {:?}",
            level,
            last_level_proofs.len(),
            start.elapsed()
        );
    }

    if last_level_proofs.len() != 1 {
        panic!("The last level proofs should be of length 1, but got {}", last_level_proofs.len());
    }
    let root_proof = last_level_proofs.pop().unwrap();
    circuit_registry
        .get_root_circuit()
        .verify(root_proof.clone())
        .expect("fail to verify root proof");
    root_proof
}
