use itertools::Itertools;
use rayon::prelude::*;

use std::{
    fs,
    ops::Div,
    path::{Path, PathBuf}, thread::panicking,
};
use tracing::{debug, info, warn};
use zk_por_core::{
    account::{gen_empty_accounts, Account}, circuit_registry::registry::CircuitRegistry, config::ProverConfig, merkle_sum_tree::MerkleSumTree, parser::read_json_into_accounts_vec
};

use zk_por_tracing::{init_tracing, TraceConfig};
use plonky2::plonk::proof::ProofWithPublicInputs;
use zk_por_core::{
    account::gen_accounts_with_random_data,
    circuit_config::{STANDARD_CONFIG,STANDARD_ZK_CONFIG},
    recursive_prover::{prover::RecursiveProver, recursive_circuit::build_recursive_n_circuit},
	merkle_sum_prover::prover::MerkleSumTreeProver,
    types::{C, D, F},
};

fn main() {
	let cfg = ProverConfig::try_new().unwrap();
    // let trace_cfg: TraceConfig = cfg.log.into();
    // init_tracing(trace_cfg);
	const RECURSION_FACTOR : usize = 64;
	const PROVING_THREADS_NUM: usize = 4;
	if cfg.prover.hyper_tree_size as usize != RECURSION_FACTOR {
		panic!("The hyper_tree_size is not configured to be equal to 64 (Recursion_Factor)"); 
	}
	let batch_size = cfg.prover.batch_size as usize;
	let asset_num = 4; // TODO: read from config
	// TODO: read path from args
	let account_paths = vec![PathBuf::from("../../test-data/batch0.json")];

	// Hardcode three levels of recursive circuits, each branching out 64 children, with the last level being a zk circuit. 
	// Hence given batch_size=1024, the current setting can support 268M (1024*64^3) accounts, enough for the foreseeable future. (Currently we have 10M accounts)
	let recursive_circuit_configs = vec![STANDARD_CONFIG, STANDARD_CONFIG, STANDARD_ZK_CONFIG]; 

	let circuit_registry = CircuitRegistry::<RECURSION_FACTOR>::init(batch_size, asset_num, STANDARD_CONFIG, recursive_circuit_configs);

	let mut batch_proofs : Vec<ProofWithPublicInputs<F, C, D>> = Vec::new();
	let (batch_circuit, account_targets) = circuit_registry.get_batch_circuit();

	for (file_idx, account_path) in account_paths.iter().enumerate() {
		let accounts = read_json_into_accounts_vec(account_path.to_str().unwrap());
		let num_accounts = accounts.len();

		// split accounts into vector of batch_size
		let mut account_batches: Vec<Vec<Account>> = accounts.into_iter().chunks(batch_size).into_iter().map(|chunk| chunk.collect()).collect();

		tracing::info!("Number of accounts {}, number of batches {}, file_idx {}, file_path {}", account_batches.len(), num_accounts, file_idx, account_path.to_str().unwrap());
		if let Some(last_batch) = account_batches.last_mut() {
			let last_batch_size = last_batch.len();

			// fill the last batch with empty accounts so that it is of size batch_size
			let empty_accounts = gen_empty_accounts(batch_size - last_batch_size, asset_num);
			last_batch.extend(empty_accounts.into_iter()); 
		} else {
			panic!("No account batches found in the file {}", account_path.to_str().unwrap());
		}

		// split account_batches into chunks of size PROVING_THREADS_NUM and then parallelize the proving in each chunk. 
		account_batches.into_iter().chunks(PROVING_THREADS_NUM).into_iter().map(|chunk| chunk.collect()).for_each(|chunk : Vec<Vec<Account>>| {
			let proofs: Vec<ProofWithPublicInputs<F, C, D>> = chunk.into_par_iter().map(|accounts| {

				let prover = MerkleSumTreeProver { accounts };
				let proof = prover.get_proof_with_circuit_data(account_targets.clone(), &batch_circuit);
				proof
				// TODO: parse tree node from proof and check against the one generated by merkle sum tree. 
			}).collect();
			batch_proofs.extend(proofs.into_iter());
		});
	}
	let mut last_circuit_vd = batch_circuit.verifier_only;
	let mut last_level_proofs = batch_proofs;
	let mut last_empty_proof = circuit_registry.get_empty_batch_circuit_proof();

	(0..recursive_circuit_configs.len()).for_each(|level| {
		let (recursive_circuit, recursive_targets) = circuit_registry.get_recursive_circuit(level).expect(format!("No recursive circuit found for level {}", level).as_str());
		let subproof_len = last_level_proofs.len();

		let mut subproof_batches: Vec<Vec<ProofWithPublicInputs<F, C, D>>> = last_level_proofs.into_iter().chunks(RECURSION_FACTOR).into_iter().map(|chunk| chunk.collect()).collect();

		tracing::info!("Recursive Level {}, number of subproofs {}, number of batches {}", level, subproof_len, subproof_batches.len());

		if let Some(last_batch) = subproof_batches.last_mut() {
			let last_batch_size = last_batch.len();

			// fill the last batch with empty accounts so that it is of size batch_size
			let empty_accounts = gen_empty_accounts(batch_size - last_batch_size, asset_num);
			last_batch.extend(empty_accounts.into_iter()); 
		} else {
			panic!("No account batches found in the file {}", account_path.to_str().unwrap());
		}

		// let sub_proofs: [ProofWithPublicInputs<F, C, D>; RECURSION_FACTOR] = std::array::from_fn(|_| last_empty_proof.clone());

		// let recursive_prover = RecursiveProver {
		// 	sub_proofs,
		// 	sub_circuit_vd: last_proofs.last().unwrap().circuit_data.clone(),
		// };
		// let recursive_proof = recursive_prover.get_proof_with_circuit_data(recursive_targets, &recursive_circuit);
		// last_proofs.push(recursive_proof);
		// last_empty_proof = recursive_proof;
	});
}