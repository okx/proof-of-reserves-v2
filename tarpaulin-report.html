<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-cli","src","constant.rs"],"content":"pub const RECURSION_BRANCHOUT_NUM: usize = 64;\npub const DEFAULT_BATCH_SIZE: usize = 1024;\npub const GLOBAL_PROOF_FILENAME: \u0026str = \"global_proof.json\";\npub const USER_PROOF_DIRNAME: \u0026str = \"user_proofs\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-cli","src","lib.rs"],"content":"mod constant;\npub mod prover;\npub mod verifier;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-cli","src","main.rs"],"content":"use std::{path::PathBuf, str::FromStr};\n\nuse clap::{Parser, Subcommand};\nuse zk_por_cli::{\n    prover::prove,\n    verifier::{verify_global, verify_user},\n};\nuse zk_por_core::error::PoRError;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: ZkPorCommitCommands,\n}\n\npub trait Execute {\n    fn execute(\u0026self) -\u003e std::result::Result\u003c(), PoRError\u003e;\n}\n\n#[derive(Subcommand)]\npub enum ZkPorCommitCommands {\n    Prove {\n        #[arg(short, long)]\n        cfg_path: String, // path to config file\n        #[arg(short, long)]\n        output_path: String, // path to output file\n    },\n    VerifyGlobal {\n        #[arg(short, long)]\n        proof_path: String,\n    },\n\n    VerifyUser {\n        #[arg(short, long)]\n        global_proof_path: String,\n        #[arg(short, long)]\n        user_proof_path_pattern: String,\n    },\n}\n\nimpl Execute for ZkPorCommitCommands {\n    fn execute(\u0026self) -\u003e std::result::Result\u003c(), PoRError\u003e {\n        match self {\n            ZkPorCommitCommands::Prove { cfg_path, output_path } =\u003e {\n                let cfg = zk_por_core::config::ProverConfig::load(\u0026cfg_path)\n                    .map_err(|e| PoRError::ConfigError(e))?;\n                let prover_cfg = cfg.try_deserialize().unwrap();\n                let output_file = PathBuf::from_str(\u0026output_path).unwrap();\n                prove(prover_cfg, output_file)\n            }\n\n            ZkPorCommitCommands::VerifyGlobal { proof_path: global_proof_path } =\u003e {\n                let global_proof_path = PathBuf::from_str(\u0026global_proof_path).unwrap();\n                verify_global(global_proof_path)\n            }\n\n            ZkPorCommitCommands::VerifyUser { global_proof_path, user_proof_path_pattern } =\u003e {\n                let global_proof_path = PathBuf::from_str(\u0026global_proof_path).unwrap();\n                verify_user(global_proof_path, user_proof_path_pattern)\n            }\n        }\n    }\n}\n\nfn main() -\u003e std::result::Result\u003c(), PoRError\u003e {\n    let cli = Cli::parse();\n    let start = std::time::Instant::now();\n    let result = cli.command.execute();\n    println!(\"result: {:?}, elapsed: {:?}\", result, start.elapsed());\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-cli","src","prover.rs"],"content":"use super::constant::{\n    DEFAULT_BATCH_SIZE, GLOBAL_PROOF_FILENAME, RECURSION_BRANCHOUT_NUM, USER_PROOF_DIRNAME,\n};\nuse indicatif::ProgressBar;\nuse plonky2::hash::hash_types::HashOut;\nuse rayon::{iter::ParallelIterator, prelude::*};\nuse serde_json::json;\nuse std::{\n    fs,\n    fs::File,\n    io::Write,\n    path::PathBuf,\n    str::FromStr,\n    sync::{Arc, RwLock},\n};\nuse zk_por_core::{\n    account::{persist_account_id_to_gmst_pos, Account},\n    circuit_config::{get_recursive_circuit_configs, STANDARD_CONFIG},\n    circuit_registry::registry::CircuitRegistry,\n    config::{ConfigProver, ProverConfig},\n    database::{PoRDB, PoRGMSTMemoryDB, PoRLevelDB, PoRLevelDBOption},\n    e2e::{batch_prove_accounts, prove_subproofs},\n    error::PoRError,\n    global::{GlobalConfig, GlobalMst, GLOBAL_MST},\n    merkle_proof::MerkleProof,\n    merkle_sum_prover::circuits::merkle_sum_circuit::MerkleSumNodeTarget,\n    merkle_sum_tree::MerkleSumTree,\n    parser::{AccountParser, FileAccountReader, FileManager, FilesCfg},\n    recursive_prover::recursive_circuit::RecursiveTargets,\n    types::F,\n    General, Proof,\n};\nuse zk_por_tracing::{init_tracing, TraceConfig};\n\n// as we use one thread to prove each batch, we load num_cpus batches to increase the parallelism.\nfn calculate_per_parse_account_num(batch_size: usize, threads_num: usize) -\u003e usize {\n    let num_cpus = num_cpus::get();\n    let num_cpus = if threads_num \u003c num_cpus { threads_num } else { num_cpus };\n    num_cpus * batch_size\n}\n\nfn ensure_output_dir_empty(user_proof_dir: PathBuf) -\u003e Result\u003c(), PoRError\u003e {\n    fs::create_dir_all(\u0026user_proof_dir).map_err(|e| return PoRError::Io(e))?;\n    let is_empty =\n        fs::read_dir(user_proof_dir.clone()).map_err(|e| return PoRError::Io(e))?.count() == 0;\n    if !is_empty {\n        return Err(PoRError::Io(std::io::Error::new(\n            std::io::ErrorKind::AlreadyExists,\n            format!(\n                \"user proof output directory {} is not empty\",\n                user_proof_dir.to_str().unwrap(),\n            ),\n        )));\n    }\n    return Ok(());\n}\n\npub fn prove(cfg: ProverConfig, proof_output_path: PathBuf) -\u003e Result\u003c(), PoRError\u003e {\n    let trace_cfg: TraceConfig = cfg.log.into();\n\n    let _g = init_tracing(trace_cfg);\n    let user_proof_output_path = proof_output_path.join(USER_PROOF_DIRNAME);\n    ensure_output_dir_empty(user_proof_output_path)?;\n\n    let mut database: Box\u003cdyn PoRDB\u003e;\n    if let Some(level_db_config) = cfg.db {\n        database = Box::new(PoRLevelDB::new(PoRLevelDBOption {\n            user_map_dir: level_db_config.level_db_user_path.to_string(),\n            gmst_dir: level_db_config.level_db_gmst_path.to_string(),\n        }));\n    } else {\n        database = Box::new(PoRGMSTMemoryDB::new());\n    }\n\n    let batch_size = cfg.prover.batch_size.unwrap_or(DEFAULT_BATCH_SIZE);\n    let token_num = cfg.prover.tokens.len();\n    let batch_prove_threads_num = cfg.prover.batch_prove_threads_num;\n    let recursive_prove_threads_num = cfg.prover.recursive_prove_threads_num;\n\n    // the path to dump the final generated proof\n    let file_manager = FileManager {};\n    let mut account_parser = FileAccountReader::new(\n        FilesCfg {\n            dir: std::path::PathBuf::from_str(\u0026cfg.prover.user_data_path).unwrap(),\n            batch_size: batch_size,\n            tokens: cfg.prover.tokens.clone(),\n        },\n        \u0026file_manager,\n    );\n    account_parser.log_state();\n\n    let batch_num = account_parser.total_num_of_users().div_ceil(batch_size);\n\n    match GLOBAL_MST.set(RwLock::new(GlobalMst::new(GlobalConfig {\n        num_of_tokens: token_num,\n        num_of_batches: batch_num,\n        batch_size: batch_size,\n        recursion_branchout_num: RECURSION_BRANCHOUT_NUM,\n    }))) {\n        Ok(_) =\u003e (),\n        Err(_) =\u003e {\n            panic!(\"set global mst error\");\n        }\n    }\n\n    let recursive_circuit_configs =\n        get_recursive_circuit_configs::\u003cRECURSION_BRANCHOUT_NUM\u003e(batch_num);\n    let recursive_level = recursive_circuit_configs.len();\n\n    tracing::info!(\n        \"start to precompute circuits and empty proofs for {} recursive levels\",\n        recursive_level\n    );\n    let circuit_registry = CircuitRegistry::\u003cRECURSION_BRANCHOUT_NUM\u003e::init(\n        batch_size,\n        token_num,\n        STANDARD_CONFIG,\n        recursive_circuit_configs,\n    );\n\n    tracing::info!(\n        \"start to prove {} accounts with {} tokens, {} batch size, {} recursive level\",\n        account_parser.total_num_of_users(),\n        token_num,\n        batch_size,\n        recursive_level,\n    );\n\n    let start = std::time::Instant::now();\n    let mut offset = 0;\n    let per_parse_account_num =\n        calculate_per_parse_account_num(batch_size, batch_prove_threads_num);\n\n    let mut parse_num = 0;\n    let mut batch_proofs = vec![];\n    let bar = ProgressBar::new(account_parser.total_num_of_users() as u64);\n    while offset \u003c account_parser.total_num_of_users() {\n        parse_num += 1;\n        let mut accounts =\n            account_parser.read_n_accounts(offset, per_parse_account_num, \u0026file_manager);\n\n        persist_account_id_to_gmst_pos(\u0026mut database, \u0026accounts, offset);\n\n        let account_num = accounts.len();\n        if account_num % batch_size != 0 {\n            let pad_num = batch_size - account_num % batch_size;\n            tracing::info!(\"in {} parse, account number {} is not a multiple of batch size {}, hence padding {} empty accounts\", parse_num, account_num, batch_size,pad_num);\n            accounts.resize(account_num + pad_num, Account::get_empty_account(token_num));\n        }\n\n        assert_eq!(accounts.len() % batch_size, 0);\n\n        tracing::debug!(\n            \"parse {} times, with number of accounts {}, number of batches {}\",\n            parse_num,\n            account_num,\n            batch_num,\n        );\n\n        let msts: Vec\u003cMerkleSumTree\u003e = accounts\n            .par_chunks(batch_size)\n            .map(|account_batch| MerkleSumTree::new_tree_from_accounts(\u0026account_batch.to_vec()))\n            .collect();\n\n        let global_mst = GLOBAL_MST.get().unwrap();\n        let mut _g: std::sync::RwLockWriteGuard\u003cGlobalMst\u003e =\n            global_mst.write().expect(\"unable to get a lock\");\n        let batch_idx_base = batch_proofs.len();\n\n        let root_hashes: Vec\u003cHashOut\u003cF\u003e\u003e = msts\n            .into_iter()\n            .enumerate()\n            .map(|(i, mst)| {\n                let batch_idx = batch_idx_base + i;\n                mst.merkle_sum_tree.iter().enumerate().for_each(|(j, node)| {\n                    _g.set_batch_hash(batch_idx, j, node.hash);\n                });\n                mst.get_root().hash\n            })\n            .collect();\n        drop(_g);\n\n        let proofs =\n            batch_prove_accounts(\u0026circuit_registry, accounts, batch_prove_threads_num, batch_size);\n\n        assert_eq!(proofs.len(), root_hashes.len());\n\n        proofs.iter().zip(root_hashes.iter()).enumerate().for_each(|(i, (proof, root_hash))|{\n            let batch_idx = batch_idx_base + i;\n            // exclude the first two pub inputs for equity and debt\n            let hash_offset = MerkleSumNodeTarget::pub_input_root_hash_offset();\n            let proof_root_hash = HashOut::\u003cF\u003e::from_partial(\u0026proof.public_inputs[hash_offset]);\n            if proof_root_hash != *root_hash {\n                panic!(\"The root hash in proof is not equal to the one generated by merkle sum tree for batch {}\", batch_idx);\n            }\n        });\n\n        batch_proofs.extend(proofs.into_iter());\n\n        tracing::debug!(\n            \"finish {}/{} batches of accounts in {} parse, since start {:?}\",\n            batch_proofs.len(),\n            batch_num,\n            parse_num,\n            start.elapsed()\n        );\n        bar.inc(account_num as u64);\n        offset += per_parse_account_num;\n    }\n    bar.finish();\n\n    tracing::info!(\n        \"finish batch proving {} accounts, generating {} proofs in {:?}\",\n        account_parser.total_num_of_users(),\n        batch_proofs.len(),\n        start.elapsed()\n    );\n\n    let batch_proof_num = batch_proofs.len();\n\n    let (batch_circuit, _) = circuit_registry.get_batch_circuit();\n    let mut last_level_circuit_vd = batch_circuit.verifier_only.clone();\n    let mut last_level_proofs = batch_proofs;\n    let recursive_levels = circuit_registry.get_recursive_levels();\n\n    // level 0 for mst root hash\n    for level in 1..=recursive_levels {\n        let start = std::time::Instant::now();\n        let last_level_vd_digest = last_level_circuit_vd.circuit_digest;\n        let last_level_empty_proof = circuit_registry\n            .get_empty_proof(\u0026last_level_vd_digest)\n            .expect(\n                format!(\"fail to find empty proof for circuit vd {:?}\", last_level_vd_digest)\n                    .as_str(),\n            )\n            .clone();\n\n        let subproof_len = last_level_proofs.len();\n\n        tracing::info!(\n            \"start to recursively prove {} subproofs at level {}/{}\",\n            subproof_len,\n            level,\n            recursive_levels,\n        );\n\n        if subproof_len % RECURSION_BRANCHOUT_NUM != 0 {\n            let pad_num = RECURSION_BRANCHOUT_NUM - subproof_len % RECURSION_BRANCHOUT_NUM;\n            tracing::info!(\"At level {}, {} subproofs are not a multiple of RECURSION_BRANCHOUT_NUM {}, hence padding {} empty proofs. \", level, subproof_len, RECURSION_BRANCHOUT_NUM, pad_num);\n\n            last_level_proofs.resize(subproof_len + pad_num, last_level_empty_proof);\n        }\n\n        let global_mst = GLOBAL_MST.get().unwrap();\n        let mut _g = global_mst.write().expect(\"unable to get a lock\");\n        last_level_proofs.iter().enumerate().for_each(|(i, proof)| {\n            let hash_offset = RecursiveTargets::\u003cRECURSION_BRANCHOUT_NUM\u003e::pub_input_hash_offset();\n            let proof_root_hash = HashOut::\u003cF\u003e::from_partial(\u0026proof.public_inputs[hash_offset]);\n\n            _g.set_recursive_hash(level - 1, i, proof_root_hash);\n        });\n        drop(_g);\n\n        let this_level_proofs = prove_subproofs(\n            last_level_proofs,\n            last_level_circuit_vd.clone(),\n            \u0026circuit_registry,\n            recursive_prove_threads_num,\n            level,\n        );\n\n        let recursive_circuit = circuit_registry\n            .get_recursive_circuit(\u0026last_level_circuit_vd.circuit_digest)\n            .expect(\n                format!(\n                    \"No recursive circuit found for inner circuit with vd {:?}\",\n                    last_level_circuit_vd.circuit_digest\n                )\n                .as_str(),\n            )\n            .0;\n\n        last_level_circuit_vd = recursive_circuit.verifier_only.clone();\n        last_level_proofs = this_level_proofs;\n\n        tracing::debug!(\n            \"finish recursive level {} with {} proofs in : {:?}\",\n            level,\n            last_level_proofs.len(),\n            start.elapsed()\n        );\n    }\n\n    if last_level_proofs.len() != 1 {\n        panic!(\"The last level proofs should be of length 1, but got {}\", last_level_proofs.len());\n    }\n    let root_proof = last_level_proofs.pop().unwrap();\n\n    // Set the root hash of the recursive circuit to the global mst\n    let hash_offset = RecursiveTargets::\u003cRECURSION_BRANCHOUT_NUM\u003e::pub_input_hash_offset();\n    let proof_root_hash = HashOut::\u003cF\u003e::from_partial(\u0026root_proof.public_inputs[hash_offset]);\n\n    let global_mst = GLOBAL_MST.get().unwrap();\n    let mut _g = global_mst.write().expect(\"unable to get a lock\");\n    _g.set_recursive_hash(recursive_levels, 0, proof_root_hash);\n    drop(_g);\n\n    let start = std::time::Instant::now();\n    assert!(GLOBAL_MST.get().unwrap().read().unwrap().is_integral());\n    tracing::info!(\"verify global mst in {:?}\", start.elapsed());\n\n    circuit_registry\n        .get_root_circuit()\n        .verify(root_proof.clone())\n        .expect(\"fail to verify root proof\");\n\n    tracing::info!(\n        \"finish recursive proving {} subproofs in {:?}\",\n        batch_proof_num,\n        start.elapsed()\n    );\n\n    let root_circuit_digest = circuit_registry.get_root_circuit().verifier_only.circuit_digest;\n\n    let proof = Proof {\n        general: General {\n            round_num: cfg.prover.round_no,\n            batch_num: batch_num,\n            recursion_branchout_num: RECURSION_BRANCHOUT_NUM,\n            batch_size: batch_size,\n            token_num: token_num,\n        },\n        root_vd_digest: root_circuit_digest,\n        proof: root_proof,\n    };\n\n    // persist gmst to database\n\n    let global_mst = GLOBAL_MST.get().unwrap();\n\n    let _g = global_mst.read().expect(\"unable to get a lock\");\n    let root_hash = _g.get_root().expect(\"no root\");\n    tracing::info!(\"root hash is {:?}\", root_hash);\n    let start = std::time::Instant::now();\n    _g.persist(\u0026mut database);\n    tracing::info!(\"persist gmst to db in {:?}\", start.elapsed());\n\n    dump_proofs(\u0026cfg.prover, proof_output_path, database, \u0026proof)?;\n    tracing::info!(\"finish dumping global proof and user proofs in {:?}\", start.elapsed());\n\n    return Ok(());\n}\n\nfn dump_proofs(\n    cfg: \u0026ConfigProver,\n    proof_output_dir_path: PathBuf,\n    db: Box\u003cdyn PoRDB\u003e,\n    root_proof: \u0026Proof,\n) -\u003e Result\u003c(), PoRError\u003e {\n    let user_proof_output_dir_path = proof_output_dir_path.join(USER_PROOF_DIRNAME); // directory has been checked empty before.\n\n    let global_proof_output_path = proof_output_dir_path.join(GLOBAL_PROOF_FILENAME);\n    let mut global_proof_file =\n        File::create(global_proof_output_path.clone()).map_err(|e| PoRError::Io(e))?;\n\n    global_proof_file\n        .write_all(json!(root_proof).to_string().as_bytes())\n        .map_err(|e| return PoRError::Io(e))?;\n\n    ///////////////////////////////////////////////\n    // generate and dump proof for each user\n    // create a new account reader to avoid buffering previously loaded accounts in memory\n    let file_manager = FileManager {};\n    let batch_size = cfg.batch_size.unwrap_or(DEFAULT_BATCH_SIZE);\n    let mut account_reader = FileAccountReader::new(\n        FilesCfg {\n            dir: std::path::PathBuf::from_str(\u0026cfg.user_data_path).unwrap(),\n            batch_size: batch_size,\n            tokens: cfg.tokens.clone(),\n        },\n        \u0026file_manager,\n    );\n\n    let global_cfg = GlobalConfig {\n        num_of_tokens: cfg.tokens.len(),\n        num_of_batches: account_reader.total_num_of_batches,\n        batch_size: batch_size,\n        recursion_branchout_num: RECURSION_BRANCHOUT_NUM,\n    };\n    let user_num = account_reader.total_num_of_users();\n\n    tracing::info!(\"start to generate and dump merkle proof for each of {} accounts\", user_num);\n\n    let bar = ProgressBar::new(user_num as u64);\n    let per_parse_account_num =\n        calculate_per_parse_account_num(batch_size, cfg.batch_prove_threads_num);\n\n    let cdb: Arc\u003cdyn PoRDB\u003e = Arc::from(db);\n    let mut offset = 0;\n    let chunk_size: usize = num_cpus::get();\n    while offset \u003c account_reader.total_num_of_users() {\n        let accounts: Vec\u003cAccount\u003e =\n            account_reader.read_n_accounts(offset, per_parse_account_num, \u0026file_manager);\n        accounts.chunks(chunk_size).for_each(|chunk| {\n            chunk.par_iter().for_each(|account| {\n                let user_proof = MerkleProof::new_from_account(account, cdb.clone(), \u0026global_cfg)\n                    .expect(\n                        format!(\"fail to generate merkle proof for account {}\", account.id)\n                            .as_str(),\n                    );\n\n                let user_proof_output_path =\n                    user_proof_output_dir_path.join(format!(\"{}.json\", account.id));\n\n                let mut user_proof_file = File::create(user_proof_output_path).expect(\n                    format!(\"fail to create user proof file for account {}\", user_proof.account.id)\n                        .as_str(),\n                );\n\n                user_proof_file.write_all(json!(user_proof).to_string().as_bytes()).expect(\n                    format!(\"fail to write user proof file for account {}\", user_proof.account.id)\n                        .as_str(),\n                );\n            });\n\n            bar.inc(chunk.len() as u64);\n        });\n        offset += per_parse_account_num;\n    }\n    bar.finish();\n\n    return Ok(());\n}\n","traces":[{"line":36,"address":[9224224],"length":1,"stats":{"Line":0}},{"line":37,"address":[9224248],"length":1,"stats":{"Line":0}},{"line":38,"address":[9224268],"length":1,"stats":{"Line":0}},{"line":39,"address":[9224300,9224328],"length":1,"stats":{"Line":0}},{"line":42,"address":[9225523,9224352],"length":1,"stats":{"Line":0}},{"line":43,"address":[9225560,9225521,9224448,9225552,9224535,9224382],"length":1,"stats":{"Line":0}},{"line":44,"address":[9225592,9225519,9224669,9224523,9225584],"length":1,"stats":{"Line":0}},{"line":46,"address":[9224958],"length":1,"stats":{"Line":0}},{"line":47,"address":[9225409],"length":1,"stats":{"Line":0}},{"line":48,"address":[9224967],"length":1,"stats":{"Line":0}},{"line":49,"address":[9225288],"length":1,"stats":{"Line":0}},{"line":51,"address":[9225026,9225162,9224975],"length":1,"stats":{"Line":0}},{"line":55,"address":[9224997],"length":1,"stats":{"Line":0}},{"line":58,"address":[9261985,9227063,9225616],"length":1,"stats":{"Line":0}},{"line":59,"address":[9225730],"length":1,"stats":{"Line":0}},{"line":61,"address":[9226011],"length":1,"stats":{"Line":0}},{"line":62,"address":[9226046,9226126],"length":1,"stats":{"Line":0}},{"line":63,"address":[9226298,9226174,9261718],"length":1,"stats":{"Line":0}},{"line":66,"address":[9226247,9226427,9227245],"length":1,"stats":{"Line":0}},{"line":67,"address":[9226898,9226665],"length":1,"stats":{"Line":0}},{"line":68,"address":[9226496],"length":1,"stats":{"Line":0}},{"line":69,"address":[9226601],"length":1,"stats":{"Line":0}},{"line":72,"address":[9226503,9227214],"length":1,"stats":{"Line":0}},{"line":75,"address":[9227266,9227029],"length":1,"stats":{"Line":0}},{"line":76,"address":[9227274],"length":1,"stats":{"Line":0}},{"line":77,"address":[9227321],"length":1,"stats":{"Line":0}},{"line":78,"address":[9227341],"length":1,"stats":{"Line":0}},{"line":83,"address":[9227542],"length":1,"stats":{"Line":0}},{"line":84,"address":[9227361],"length":1,"stats":{"Line":0}},{"line":86,"address":[9227475],"length":1,"stats":{"Line":0}},{"line":90,"address":[9227653],"length":1,"stats":{"Line":0}},{"line":92,"address":[9227716],"length":1,"stats":{"Line":0}},{"line":94,"address":[9227797],"length":1,"stats":{"Line":0}},{"line":102,"address":[9261671,9227963],"length":1,"stats":{"Line":0}},{"line":106,"address":[9227992],"length":1,"stats":{"Line":0}},{"line":108,"address":[9228095,9228031],"length":1,"stats":{"Line":0}},{"line":110,"address":[9228255,9229000,9229374,9229568,9229298,9228671,9228870],"length":1,"stats":{"Line":0}},{"line":118,"address":[9229065],"length":1,"stats":{"Line":0}},{"line":121,"address":[9231052],"length":1,"stats":{"Line":0}},{"line":129,"address":[9230825,9231859],"length":1,"stats":{"Line":0}},{"line":130,"address":[9231874],"length":1,"stats":{"Line":0}},{"line":131,"address":[9231886],"length":1,"stats":{"Line":0}},{"line":134,"address":[9231925],"length":1,"stats":{"Line":0}},{"line":135,"address":[9231944],"length":1,"stats":{"Line":0}},{"line":136,"address":[9231951,9232035],"length":1,"stats":{"Line":0}},{"line":137,"address":[9232159,9261514,9232056],"length":1,"stats":{"Line":0}},{"line":138,"address":[9253717,9232183,9253671],"length":1,"stats":{"Line":0}},{"line":139,"address":[9253678,9253738],"length":1,"stats":{"Line":0}},{"line":142,"address":[9253746],"length":1,"stats":{"Line":0}},{"line":144,"address":[9253822],"length":1,"stats":{"Line":0}},{"line":145,"address":[9253865],"length":1,"stats":{"Line":0}},{"line":146,"address":[9253955,9254203],"length":1,"stats":{"Line":0}},{"line":147,"address":[9255193,9255717,9254231,9254647,9254846,9254976,9255117],"length":1,"stats":{"Line":0}},{"line":148,"address":[9256018,9255041],"length":1,"stats":{"Line":0}},{"line":151,"address":[9256102,9253925],"length":1,"stats":{"Line":0}},{"line":153,"address":[9257812,9257322,9257398,9256436,9257051,9257181,9256852],"length":1,"stats":{"Line":0}},{"line":160,"address":[9257246,9258113],"length":1,"stats":{"Line":0}},{"line":162,"address":[9262191,9262128],"length":1,"stats":{"Line":0}},{"line":165,"address":[9258353,9258197],"length":1,"stats":{"Line":0}},{"line":166,"address":[9258369],"length":1,"stats":{"Line":0}},{"line":168,"address":[9258537,9258473],"length":1,"stats":{"Line":0}},{"line":170,"address":[9258545],"length":1,"stats":{"Line":0}},{"line":173,"address":[9262350,9262320,9262685],"length":1,"stats":{"Line":0}},{"line":174,"address":[9262397,9262449],"length":1,"stats":{"Line":0}},{"line":175,"address":[9262720,9262520,9262423,9262754],"length":1,"stats":{"Line":0}},{"line":176,"address":[9262764],"length":1,"stats":{"Line":0}},{"line":178,"address":[9262585],"length":1,"stats":{"Line":0}},{"line":181,"address":[9258693],"length":1,"stats":{"Line":0}},{"line":183,"address":[9258779],"length":1,"stats":{"Line":0}},{"line":186,"address":[9258938,9258874],"length":1,"stats":{"Line":0}},{"line":188,"address":[9259120,9262863,9262848],"length":1,"stats":{"Line":0}},{"line":189,"address":[9262908,9263018],"length":1,"stats":{"Line":0}},{"line":191,"address":[9262934],"length":1,"stats":{"Line":0}},{"line":192,"address":[9262964],"length":1,"stats":{"Line":0}},{"line":193,"address":[9263001],"length":1,"stats":{"Line":0}},{"line":194,"address":[9263110],"length":1,"stats":{"Line":0}},{"line":198,"address":[9259385],"length":1,"stats":{"Line":0}},{"line":200,"address":[9260018,9260205,9260435,9259623,9261105,9260499,9260317],"length":1,"stats":{"Line":0}},{"line":207,"address":[9260373],"length":1,"stats":{"Line":0}},{"line":208,"address":[9261411,9261469],"length":1,"stats":{"Line":0}},{"line":210,"address":[9232164],"length":1,"stats":{"Line":0}},{"line":212,"address":[9233399],"length":1,"stats":{"Line":0}},{"line":219,"address":[9234168,9233183],"length":1,"stats":{"Line":0}},{"line":221,"address":[9234192],"length":1,"stats":{"Line":0}},{"line":222,"address":[9234215],"length":1,"stats":{"Line":0}},{"line":223,"address":[9234237],"length":1,"stats":{"Line":0}},{"line":224,"address":[9234357,9234293],"length":1,"stats":{"Line":0}},{"line":227,"address":[9253538,9234573,9234365],"length":1,"stats":{"Line":0}},{"line":228,"address":[9234589,9245791],"length":1,"stats":{"Line":0}},{"line":229,"address":[9245806],"length":1,"stats":{"Line":0}},{"line":230,"address":[9245854,9246199],"length":1,"stats":{"Line":0}},{"line":233,"address":[9245979,9246108],"length":1,"stats":{"Line":0}},{"line":238,"address":[9246324],"length":1,"stats":{"Line":0}},{"line":240,"address":[9247436,9247850,9247360,9246923,9247122,9246507,9247252],"length":1,"stats":{"Line":0}},{"line":247,"address":[9247317,9248135],"length":1,"stats":{"Line":0}},{"line":248,"address":[9248182,9248389],"length":1,"stats":{"Line":0}},{"line":249,"address":[9249303,9249379,9248833,9249900,9249162,9249032,9248417],"length":1,"stats":{"Line":0}},{"line":251,"address":[9250201,9249227],"length":1,"stats":{"Line":0}},{"line":254,"address":[9248153,9250393],"length":1,"stats":{"Line":0}},{"line":255,"address":[9250409],"length":1,"stats":{"Line":0}},{"line":256,"address":[9250593,9263221,9263184,9250513],"length":1,"stats":{"Line":0}},{"line":257,"address":[9263231],"length":1,"stats":{"Line":0}},{"line":258,"address":[9263257],"length":1,"stats":{"Line":0}},{"line":260,"address":[9263294,9263426],"length":1,"stats":{"Line":0}},{"line":262,"address":[9250678],"length":1,"stats":{"Line":0}},{"line":265,"address":[9250712],"length":1,"stats":{"Line":0}},{"line":266,"address":[9250776],"length":1,"stats":{"Line":0}},{"line":272,"address":[9251309,9250919],"length":1,"stats":{"Line":0}},{"line":273,"address":[9250903],"length":1,"stats":{"Line":0}},{"line":275,"address":[9251081,9251210,9250983],"length":1,"stats":{"Line":0}},{"line":281,"address":[9251358,9251233],"length":1,"stats":{"Line":0}},{"line":283,"address":[9251385],"length":1,"stats":{"Line":0}},{"line":284,"address":[9251505],"length":1,"stats":{"Line":0}},{"line":286,"address":[9253071],"length":1,"stats":{"Line":0}},{"line":294,"address":[9234558,9234626],"length":1,"stats":{"Line":0}},{"line":295,"address":[9245579,9245697,9234663],"length":1,"stats":{"Line":0}},{"line":297,"address":[9234754,9234648],"length":1,"stats":{"Line":0}},{"line":300,"address":[9234762,9234842],"length":1,"stats":{"Line":0}},{"line":301,"address":[9234858],"length":1,"stats":{"Line":0}},{"line":303,"address":[9235042,9234927],"length":1,"stats":{"Line":0}},{"line":304,"address":[9235058],"length":1,"stats":{"Line":0}},{"line":305,"address":[9235258,9235162],"length":1,"stats":{"Line":0}},{"line":306,"address":[9235321],"length":1,"stats":{"Line":0}},{"line":308,"address":[9235355],"length":1,"stats":{"Line":0}},{"line":309,"address":[9235786,9235411,9235526],"length":1,"stats":{"Line":0}},{"line":310,"address":[9236134,9236550,9236749,9236879,9237008,9237084,9237342],"length":1,"stats":{"Line":0}},{"line":312,"address":[9236952,9237630],"length":1,"stats":{"Line":0}},{"line":314,"address":[9237595],"length":1,"stats":{"Line":0}},{"line":317,"address":[9238991],"length":1,"stats":{"Line":0}},{"line":323,"address":[9238665,9239450],"length":1,"stats":{"Line":0}},{"line":326,"address":[9239484],"length":1,"stats":{"Line":0}},{"line":339,"address":[9239728,9239887],"length":1,"stats":{"Line":0}},{"line":341,"address":[9239895],"length":1,"stats":{"Line":0}},{"line":342,"address":[9239996,9240075],"length":1,"stats":{"Line":0}},{"line":343,"address":[9241451,9240919,9240720,9241257,9241049,9240304,9241181],"length":1,"stats":{"Line":0}},{"line":344,"address":[9241719,9241114],"length":1,"stats":{"Line":0}},{"line":345,"address":[9241734],"length":1,"stats":{"Line":0}},{"line":346,"address":[9242893,9243227,9242356,9242555,9241940,9242969,9242685],"length":1,"stats":{"Line":0}},{"line":348,"address":[9242766,9243700,9245309,9243496],"length":1,"stats":{"Line":0}},{"line":349,"address":[9244573,9244703,9243828,9244244,9244779,9245037,9244443],"length":1,"stats":{"Line":0}},{"line":351,"address":[9244646],"length":1,"stats":{"Line":0}},{"line":354,"address":[9263456,9267658,9267859],"length":1,"stats":{"Line":0}},{"line":360,"address":[9263634,9263538],"length":1,"stats":{"Line":0}},{"line":362,"address":[9263674,9263757],"length":1,"stats":{"Line":0}},{"line":363,"address":[9263872,9263805,9267727,9267880,9267872,9264015],"length":1,"stats":{"Line":0}},{"line":366,"address":[9264614,9264836],"length":1,"stats":{"Line":0}},{"line":367,"address":[9263997,9264526,9264467],"length":1,"stats":{"Line":0}},{"line":368,"address":[9264861,9264549,9267667,9264710,9267904,9267912,9264474],"length":1,"stats":{"Line":0}},{"line":373,"address":[9263506],"length":1,"stats":{"Line":0}},{"line":374,"address":[9264888],"length":1,"stats":{"Line":0}},{"line":376,"address":[9265132],"length":1,"stats":{"Line":0}},{"line":377,"address":[9264943],"length":1,"stats":{"Line":0}},{"line":379,"address":[9265057],"length":1,"stats":{"Line":0}},{"line":385,"address":[9265243],"length":1,"stats":{"Line":0}},{"line":386,"address":[9265326],"length":1,"stats":{"Line":0}},{"line":390,"address":[9265370],"length":1,"stats":{"Line":0}},{"line":392,"address":[9266680,9266425,9266180,9265981,9265565,9266307,9266489],"length":1,"stats":{"Line":0}},{"line":394,"address":[9266363],"length":1,"stats":{"Line":0}},{"line":395,"address":[9266946,9267011],"length":1,"stats":{"Line":0}},{"line":398,"address":[9267019],"length":1,"stats":{"Line":0}},{"line":399,"address":[9267086],"length":1,"stats":{"Line":0}},{"line":400,"address":[9267098,9267159],"length":1,"stats":{"Line":0}},{"line":401,"address":[9267167],"length":1,"stats":{"Line":0}},{"line":402,"address":[9267243],"length":1,"stats":{"Line":0}},{"line":404,"address":[9267383,9267471,9267936],"length":1,"stats":{"Line":0}},{"line":405,"address":[9268080,9270393,9267991,9270443],"length":1,"stats":{"Line":0}},{"line":406,"address":[9268525,9268113],"length":1,"stats":{"Line":0}},{"line":408,"address":[9268328,9268457],"length":1,"stats":{"Line":0}},{"line":413,"address":[9268639,9268898,9268751],"length":1,"stats":{"Line":0}},{"line":415,"address":[9269289,9268921],"length":1,"stats":{"Line":0}},{"line":416,"address":[9269221,9269092],"length":1,"stats":{"Line":0}},{"line":420,"address":[9269697,9269441,9269832,9270216,9269756],"length":1,"stats":{"Line":0}},{"line":421,"address":[9270021,9270150],"length":1,"stats":{"Line":0}},{"line":426,"address":[9268053],"length":1,"stats":{"Line":0}},{"line":428,"address":[9267585,9267638],"length":1,"stats":{"Line":0}},{"line":430,"address":[9267219],"length":1,"stats":{"Line":0}},{"line":432,"address":[9267300],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":177},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-cli","src","verifier.rs"],"content":"use indicatif::ProgressBar;\nuse plonky2_field::types::PrimeField64;\nuse rayon::iter::IntoParallelRefIterator;\nuse serde_json::from_reader;\nuse std::{fs::File, path::PathBuf};\n\n// Assuming Proof is defined in lib.rs and lib.rs is in the same crate\nuse super::constant::RECURSION_BRANCHOUT_NUM;\nuse zk_por_core::{\n    circuit_config::{get_recursive_circuit_configs, STANDARD_CONFIG},\n    circuit_registry::registry::CircuitRegistry,\n    error::PoRError,\n    merkle_proof::MerkleProof,\n    recursive_prover::recursive_circuit::RecursiveTargets,\n    types::F,\n    Proof,\n};\n\nuse plonky2::hash::hash_types::HashOut;\nuse rayon::iter::ParallelIterator;\n\nuse glob::glob;\nuse std::io;\n\nfn find_matching_files(pattern: \u0026str) -\u003e Result\u003cVec\u003cPathBuf\u003e, io::Error\u003e {\n    let mut matching_files = Vec::new();\n\n    // Use the glob function to get an iterator of matching paths\n    for entry in glob(pattern).expect(\"Failed to read glob pattern\") {\n        match entry {\n            Ok(path) =\u003e matching_files.push(path),\n            Err(e) =\u003e return Err(io::Error::new(io::ErrorKind::Other, e.to_string())),\n        }\n    }\n\n    Ok(matching_files)\n}\n\npub fn verify_user(\n    global_proof_path: PathBuf,\n    user_proof_path_pattern: \u0026String,\n) -\u003e Result\u003c(), PoRError\u003e {\n    let proof_file = File::open(\u0026global_proof_path).unwrap();\n    let reader = std::io::BufReader::new(proof_file);\n\n    // Parse the JSON as Proof\n    let proof: Proof = from_reader(reader)\n        .expect(format!(\"fail to parse global proof from path {:?}\", global_proof_path).as_str());\n\n    let hash_offset = RecursiveTargets::\u003cRECURSION_BRANCHOUT_NUM\u003e::pub_input_hash_offset();\n    let root_hash = HashOut::\u003cF\u003e::from_partial(\u0026proof.proof.public_inputs[hash_offset]);\n    let user_proof_paths =\n        find_matching_files(user_proof_path_pattern).map_err(|e| PoRError::Io(e))?;\n    let proof_file_num = user_proof_paths.len();\n    println!(\"successfully identify {} user proof files\", proof_file_num);\n\n    let bar = ProgressBar::new(proof_file_num as u64);\n    let chunk_size: usize = num_cpus::get();\n    user_proof_paths.chunks(chunk_size).for_each(|chunks| {\n        chunks.par_iter().for_each(|user_proof_path| {\n            let merkle_path = File::open(\u0026user_proof_path).unwrap();\n            let reader = std::io::BufReader::new(merkle_path);\n            let proof: MerkleProof = from_reader(reader).unwrap();\n            if let Err(e) = proof.verify_merkle_proof(root_hash) {\n                panic!(\n                    \"fail to verify the user proof on path {:?} due to error {:?}\",\n                    user_proof_path, e\n                )\n            }\n        });\n        bar.inc(chunks.len() as u64);\n    });\n    bar.finish();\n    println!(\n        \"successfully verify {} user proofs with file pattern {}\",\n        proof_file_num, user_proof_path_pattern\n    );\n\n    Ok(())\n}\n\npub fn verify_global(global_proof_path: PathBuf) -\u003e Result\u003c(), PoRError\u003e {\n    let proof_file = File::open(\u0026global_proof_path).unwrap();\n    let reader = std::io::BufReader::new(proof_file);\n\n    // Parse the JSON as Proof\n    let proof: Proof = from_reader(reader).unwrap();\n\n    if proof.general.recursion_branchout_num != RECURSION_BRANCHOUT_NUM {\n        panic!(\"The recursion_branchout_num is not configured to be equal to 64\");\n    }\n\n    let token_num = proof.general.token_num;\n    let batch_num = proof.general.batch_num;\n    let round_num = proof.general.round_num;\n    let batch_size = proof.general.batch_size;\n    let recursive_circuit_configs =\n        get_recursive_circuit_configs::\u003cRECURSION_BRANCHOUT_NUM\u003e(batch_num);\n\n    // not to use trace::log to avoid the dependency on the trace config.\n    println!(\n        \"start to reconstruct the circuit with {} recursive levels for round {}\",\n        recursive_circuit_configs.len(),\n        round_num\n    );\n    let start = std::time::Instant::now();\n    let circuit_registry = CircuitRegistry::\u003cRECURSION_BRANCHOUT_NUM\u003e::init(\n        batch_size,\n        token_num,\n        STANDARD_CONFIG,\n        recursive_circuit_configs,\n    );\n\n    let root_circuit = circuit_registry.get_root_circuit();\n\n    let circuit_vd = root_circuit.verifier_only.circuit_digest;\n    if circuit_vd != proof.root_vd_digest {\n        return Err(PoRError::CircuitDigestMismatch);\n    }\n\n    println!(\n        \"successfully reconstruct the circuit for round {} in {:?}\",\n        round_num,\n        start.elapsed()\n    );\n\n    let equity = proof.proof.public_inputs\n        [RecursiveTargets::\u003cRECURSION_BRANCHOUT_NUM\u003e::pub_input_equity_offset()];\n    let debt = proof.proof.public_inputs\n        [RecursiveTargets::\u003cRECURSION_BRANCHOUT_NUM\u003e::pub_input_debt_offset()];\n    if !root_circuit.verify(proof.proof).is_ok() {\n        return Err(PoRError::InvalidProof);\n    }\n\n    println!(\"successfully verify the global proof for round {}, total exchange users' equity is {}, debt is {}, exchange liability is {}\", \n    round_num, equity.to_canonical_u64(), debt.to_canonical_u64(), (equity- debt).to_canonical_u64());\n\n    Ok(())\n}\n","traces":[{"line":25,"address":[9597660,9596848],"length":1,"stats":{"Line":0}},{"line":26,"address":[9596891],"length":1,"stats":{"Line":0}},{"line":29,"address":[9596915,9597131,9596975,9597185],"length":1,"stats":{"Line":0}},{"line":30,"address":[9597249],"length":1,"stats":{"Line":0}},{"line":31,"address":[9597500,9597381],"length":1,"stats":{"Line":0}},{"line":32,"address":[9597505,9597437],"length":1,"stats":{"Line":0}},{"line":36,"address":[9597294],"length":1,"stats":{"Line":0}},{"line":39,"address":[9597696,9599805,9599886],"length":1,"stats":{"Line":0}},{"line":43,"address":[9598001,9597735],"length":1,"stats":{"Line":0}},{"line":44,"address":[9598008],"length":1,"stats":{"Line":0}},{"line":47,"address":[9598391,9598043],"length":1,"stats":{"Line":0}},{"line":48,"address":[9598429,9598162,9598323,9599849],"length":1,"stats":{"Line":0}},{"line":50,"address":[9598500],"length":1,"stats":{"Line":0}},{"line":51,"address":[9598543],"length":1,"stats":{"Line":0}},{"line":52,"address":[9599912,9598826,9598600,9599904],"length":1,"stats":{"Line":0}},{"line":54,"address":[9598996,9598803],"length":1,"stats":{"Line":0}},{"line":55,"address":[9599114],"length":1,"stats":{"Line":0}},{"line":57,"address":[9599183],"length":1,"stats":{"Line":0}},{"line":58,"address":[9599210,9599271],"length":1,"stats":{"Line":0}},{"line":59,"address":[9599287,9599936],"length":1,"stats":{"Line":0}},{"line":60,"address":[9601124,9600048,9599989,9601247],"length":1,"stats":{"Line":0}},{"line":61,"address":[9600243,9600073],"length":1,"stats":{"Line":0}},{"line":62,"address":[9600250],"length":1,"stats":{"Line":0}},{"line":63,"address":[9600261],"length":1,"stats":{"Line":0}},{"line":64,"address":[9600574,9600673],"length":1,"stats":{"Line":0}},{"line":65,"address":[9601030],"length":1,"stats":{"Line":0}},{"line":71,"address":[9600023],"length":1,"stats":{"Line":0}},{"line":73,"address":[9599372],"length":1,"stats":{"Line":0}},{"line":74,"address":[9599611],"length":1,"stats":{"Line":0}},{"line":79,"address":[9599714],"length":1,"stats":{"Line":0}},{"line":82,"address":[9604469,9601296,9604607],"length":1,"stats":{"Line":0}},{"line":83,"address":[9601657,9601327],"length":1,"stats":{"Line":0}},{"line":84,"address":[9601664],"length":1,"stats":{"Line":0}},{"line":87,"address":[9601699,9601917],"length":1,"stats":{"Line":0}},{"line":89,"address":[9601925],"length":1,"stats":{"Line":0}},{"line":90,"address":[9604557,9602031],"length":1,"stats":{"Line":0}},{"line":93,"address":[9601936],"length":1,"stats":{"Line":0}},{"line":94,"address":[9601960],"length":1,"stats":{"Line":0}},{"line":95,"address":[9601976],"length":1,"stats":{"Line":0}},{"line":96,"address":[9601992],"length":1,"stats":{"Line":0}},{"line":97,"address":[9602101,9602024],"length":1,"stats":{"Line":0}},{"line":101,"address":[9602406],"length":1,"stats":{"Line":0}},{"line":106,"address":[9602491],"length":1,"stats":{"Line":0}},{"line":111,"address":[9602563],"length":1,"stats":{"Line":0}},{"line":114,"address":[9602747,9602810],"length":1,"stats":{"Line":0}},{"line":116,"address":[9602818],"length":1,"stats":{"Line":0}},{"line":117,"address":[9602848],"length":1,"stats":{"Line":0}},{"line":118,"address":[9603009],"length":1,"stats":{"Line":0}},{"line":121,"address":[9603212],"length":1,"stats":{"Line":0}},{"line":127,"address":[9603297,9603360],"length":1,"stats":{"Line":0}},{"line":128,"address":[9603310],"length":1,"stats":{"Line":0}},{"line":129,"address":[9603434,9603371],"length":1,"stats":{"Line":0}},{"line":130,"address":[9603384],"length":1,"stats":{"Line":0}},{"line":131,"address":[9603445],"length":1,"stats":{"Line":0}},{"line":132,"address":[9603637],"length":1,"stats":{"Line":0}},{"line":135,"address":[9604269],"length":1,"stats":{"Line":0}},{"line":138,"address":[9604404],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":57},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","benches","batch_circuit.rs"],"content":"#![feature(test)]\nuse plonky2::plonk::circuit_builder::CircuitBuilder;\nuse zk_por_core::{\n    account::gen_accounts_with_random_data,\n    circuit_config::STANDARD_CONFIG,\n    merkle_sum_prover::{circuits::account_circuit::AccountTargets, prover::MerkleSumTreeProver},\n    types::{C, D, F},\n};\n\nextern crate test;\nuse test::Bencher;\n\nfn bench(b: \u0026mut Bencher, batch_size: usize) {\n    let mut builder = CircuitBuilder::\u003cF, D\u003e::new(STANDARD_CONFIG);\n    let num_assets = 50;\n    let accounts = gen_accounts_with_random_data(batch_size, num_assets);\n    let prover = MerkleSumTreeProver { accounts };\n    let account_targets: Vec\u003cAccountTargets\u003e = prover.build_merkle_tree_targets(\u0026mut builder);\n    let data = \u0026builder.build::\u003cC\u003e();\n\n    b.iter(|| _ = prover.get_proof_with_circuit_data(account_targets.as_slice(), data));\n}\n\n#[bench]\npub fn bench_batch_size_equal_2(b: \u0026mut Bencher) {\n    bench(b, 2);\n}\n\n#[bench]\npub fn bench_batch_size_equal_16(b: \u0026mut Bencher) {\n    bench(b, 16);\n}\n\n#[bench]\npub fn bench_batch_size_equal_256(b: \u0026mut Bencher) {\n    bench(b, 256);\n}\n\n#[bench]\npub fn bench_batch_size_equal_1024(b: \u0026mut Bencher) {\n    bench(b, 1024);\n}\n\n#[bench]\npub fn bench_batch_size_equal_2048(b: \u0026mut Bencher) {\n    bench(b, 2048);\n}\n\n#[bench]\npub fn bench_batch_size_equal_4096(b: \u0026mut Bencher) {\n    bench(b, 4096);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","benches","benchmark.rs"],"content":"use criterion::{\n    criterion_group, criterion_main, measurement::WallTime, BenchmarkGroup, Criterion, SamplingMode,\n};\nuse zk_por_core::{\n    account::gen_accounts_with_random_data,\n    circuit_config::STANDARD_CONFIG,\n    merkle_sum_prover::{\n        circuits::merkle_sum_circuit::build_merkle_sum_tree_circuit, prover::MerkleSumTreeProver,\n    },\n    recursive_prover::{prover::RecursiveProver, recursive_circuit::build_recursive_n_circuit},\n    types::{C, D, F},\n};\n\nuse plonky2::plonk::proof::ProofWithPublicInputs;\nuse rayon::iter::{IntoParallelIterator, ParallelIterator};\n\n/// Benchmark the batch proving of the accounts. There are {parallism} threads, each thread proving the batch_size accounts.\npub fn bench_batch_circuit(\n    c: \u0026mut BenchmarkGroup\u003cWallTime\u003e,\n    batch_size: usize,\n    num_assets: usize,\n    parallism: usize,\n) {\n    let accounts = gen_accounts_with_random_data(batch_size, num_assets);\n    let bench_id =\n        format!(\"batch_circuit_{}_token_num_{}_parallism_{}\", batch_size, num_assets, parallism);\n    let (circuit_data, account_targets) =\n        build_merkle_sum_tree_circuit(batch_size, num_assets, STANDARD_CONFIG);\n    c.bench_function(bench_id.as_str(), |b| {\n        b.iter(|| {\n            (0..parallism).into_par_iter().for_each(|_| {\n                let prover = MerkleSumTreeProver { accounts: accounts.clone() };\n                let _ = prover.get_proof_with_circuit_data(\u0026account_targets, \u0026circuit_data);\n            });\n        })\n    });\n}\n\npub fn batch_circuit_for_batch_size(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"batch_circuit_for_batch_size\");\n    group.sample_size(10);\n    let num_assets = 200;\n    let parallism = 1;\n    for \u0026batch_size in [16, 64, 256, 512, 1024].iter() {\n        bench_batch_circuit(\u0026mut group, batch_size, num_assets, parallism);\n    }\n    group.finish();\n}\n\npub fn batch_circuit_for_token_num(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"batch_circuit_for_token_num\");\n    group.sample_size(10);\n    let batch_size = 1024;\n    let parallism = 1;\n    for \u0026num_assets in [4, 20, 50, 100, 200].iter() {\n        bench_batch_circuit(\u0026mut group, batch_size, num_assets, parallism);\n    }\n    group.finish();\n}\n\npub fn batch_circuit_for_parallism(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"batch_circuit_for_parallism\");\n    group.sample_size(10);\n    let token_num = 200;\n    for \u0026batch_size in [16, 1024].iter() {\n        for \u0026parallism in [1, 2, 4, 8, 16, 32].iter() {\n            bench_batch_circuit(\u0026mut group, batch_size, token_num, parallism);\n        }\n    }\n    group.finish();\n}\n\npub fn bench_recursive_circuit\u003cconst SUBPROOF_NUM: usize\u003e(\n    g: \u0026mut BenchmarkGroup\u003cWallTime\u003e,\n    parallism: usize,\n) {\n    let batch_size = 1024;\n    let token_num = 4;\n    let (merkle_sum_circuit, account_targets) =\n        build_merkle_sum_tree_circuit(batch_size, token_num, STANDARD_CONFIG);\n\n    let accounts = gen_accounts_with_random_data(batch_size, token_num);\n    let prover = MerkleSumTreeProver { accounts };\n\n    let merkle_sum_proof =\n        prover.get_proof_with_circuit_data(\u0026account_targets, \u0026merkle_sum_circuit);\n\n    let (recursive_circuit, recursive_targets) = build_recursive_n_circuit::\u003cC, SUBPROOF_NUM\u003e(\n        \u0026merkle_sum_circuit.common,\n        \u0026merkle_sum_circuit.verifier_only,\n        STANDARD_CONFIG,\n    );\n\n    let subproofs: [ProofWithPublicInputs\u003cF, C, D\u003e; SUBPROOF_NUM] =\n        std::array::from_fn(|_| merkle_sum_proof.clone());\n    let bench_id = format!(\"recursive_circuit_{}_parallism_{}\", SUBPROOF_NUM, parallism);\n    g.bench_function(bench_id.as_str(), |b| {\n        b.iter(|| {\n            (0..parallism).into_par_iter().for_each(|_| {\n                let recursive_prover = RecursiveProver {\n                    sub_proofs: subproofs.clone(),\n                    sub_circuit_vd: merkle_sum_circuit.verifier_only.clone(),\n                };\n                recursive_prover\n                    .get_proof_with_circuit_data(recursive_targets.clone(), \u0026recursive_circuit);\n            });\n        })\n    });\n}\n\npub fn recursive_circuit_for_branchout(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"recursive_circuit_for_branchout\");\n    group.sample_size(10);\n    group.sampling_mode(SamplingMode::Flat); // for long running benchmarks\n    let parallism = 1;\n    bench_recursive_circuit::\u003c4\u003e(\u0026mut group, parallism);\n    bench_recursive_circuit::\u003c8\u003e(\u0026mut group, parallism);\n    bench_recursive_circuit::\u003c16\u003e(\u0026mut group, parallism);\n    bench_recursive_circuit::\u003c32\u003e(\u0026mut group, parallism);\n    bench_recursive_circuit::\u003c64\u003e(\u0026mut group, parallism);\n    group.finish();\n}\n\npub fn recursive_circuit_for_parallism(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"recursive_circuit_for_parallism\");\n    group.sample_size(10);\n    group.sampling_mode(SamplingMode::Flat); // for long running benchmarks\n    const SUBPROOF_NUM: usize = 64;\n    for \u0026parallism in [1, 2, 4].iter() {\n        bench_recursive_circuit::\u003cSUBPROOF_NUM\u003e(\u0026mut group, parallism);\n    }\n}\n\ncriterion_group!(\n    benches,\n    batch_circuit_for_token_num,\n    batch_circuit_for_batch_size,\n    batch_circuit_for_parallism,\n    recursive_circuit_for_branchout,\n    recursive_circuit_for_parallism\n);\ncriterion_main!(benches);\n","traces":[{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","benches","merkle_sum_tree.rs"],"content":"#![feature(test)]\nuse zk_por_core::{account::gen_accounts_with_random_data, merkle_sum_tree::MerkleSumTree};\n\nextern crate test;\nuse test::Bencher;\n\nfn bench(b: \u0026mut Bencher, batch_size: usize) {\n    let num_assets = 200;\n    let accounts = gen_accounts_with_random_data(batch_size, num_assets);\n\n    b.iter(|| _ = MerkleSumTree::new_tree_from_accounts(\u0026accounts));\n}\n\n#[bench]\npub fn bench_batch_size_equal_1024(b: \u0026mut Bencher) {\n    bench(b, 1 \u003c\u003c 10);\n}\n\n#[bench]\npub fn bench_batch_size_equal_2048(b: \u0026mut Bencher) {\n    bench(b, 1 \u003c\u003c 11);\n}\n\n#[bench]\npub fn bench_batch_size_equal_4096(b: \u0026mut Bencher) {\n    bench(b, 1 \u003c\u003c 12);\n}\n\n#[bench]\npub fn bench_batch_size_equal_8192(b: \u0026mut Bencher) {\n    bench(b, 1 \u003c\u003c 13);\n}\n\n#[bench]\npub fn bench_batch_size_equal_16384(b: \u0026mut Bencher) {\n    bench(b, 1 \u003c\u003c 14);\n}\n\n#[bench]\npub fn bench_batch_size_equal_32768(b: \u0026mut Bencher) {\n    bench(b, 1 \u003c\u003c 15);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","account.rs"],"content":"use crate::{\n    database::{PoRDB, UserId},\n    types::F,\n};\nuse plonky2::{\n    hash::{hash_types::HashOut, poseidon::PoseidonHash},\n    plonk::config::Hasher,\n};\nuse plonky2_field::types::Field;\nuse rand::Rng;\nuse serde::{Deserialize, Serialize};\n\n/// A struct representing a users account. It represents their equity and debt as a Vector of goldilocks field elements.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Account {\n    pub id: String, // 256 bit hex string\n    pub equity: Vec\u003cF\u003e,\n    pub debt: Vec\u003cF\u003e,\n}\n\nimpl Account {\n    /// Gets the account hash for a given account.\n    pub fn get_hash(\u0026self) -\u003e HashOut\u003cF\u003e {\n        let sum_equity = self.equity.iter().fold(F::ZERO, |acc, x| acc + *x);\n\n        let sum_debt = self.debt.iter().fold(F::ZERO, |acc, x| acc + *x);\n\n        let id = self.get_user_id_in_field();\n\n        #[allow(clippy::useless_vec)]\n        let hash =\n            PoseidonHash::hash_no_pad(vec![id, vec![sum_equity, sum_debt]].concat().as_slice());\n\n        hash\n    }\n\n    pub fn get_empty_account_with_user_id(user_id: String, num_of_tokens: usize) -\u003e Account {\n        Self {\n            id: user_id,\n            equity: vec![F::default(); num_of_tokens],\n            debt: vec![F::default(); num_of_tokens],\n        }\n    }\n\n    pub fn get_empty_account(num_of_tokens: usize) -\u003e Account {\n        Self {\n            id: \"0\".repeat(64),\n            equity: vec![F::default(); num_of_tokens],\n            debt: vec![F::default(); num_of_tokens],\n        }\n    }\n\n    /// Gets a user id as a vec of 5 GF elements.\n    pub fn get_user_id_in_field(\u0026self) -\u003e Vec\u003cF\u003e {\n        assert!(self.id.len() == 64);\n        #[allow(clippy::useless_vec)]\n        let segments = vec![\n            self.id[0..14].to_string(),  // First 56 bits (14 hex chars)\n            self.id[14..28].to_string(), // Second 56 bits\n            self.id[28..42].to_string(), // Third 56 bits\n            self.id[42..56].to_string(), // Fourth 56 bits\n            self.id[56..64].to_string(), // Remaining 32 bits (8 hex chars, fits in 56 bits)\n        ];\n\n        segments\n            .iter()\n            .map(|seg| F::from_canonical_u64(u64::from_str_radix(seg, 16).unwrap()))\n            .collect::\u003cVec\u003cF\u003e\u003e()\n    }\n}\n\npub fn persist_account_id_to_gmst_pos(\n    db: \u0026mut Box\u003cdyn PoRDB\u003e,\n    accounts: \u0026Vec\u003cAccount\u003e,\n    start_idx: usize,\n) {\n    let user_batch = accounts\n        .iter()\n        .enumerate()\n        .map(|(i, acct)| {\n            let user_id = UserId::from_hex_string(acct.id.to_string()).unwrap();\n            // tracing::debug!(\"persist account {:?} with index: {:?}\", acct.id, i + start_idx);\n            (user_id, (i + start_idx) as u32)\n        })\n        .collect::\u003cVec\u003c(UserId, u32)\u003e\u003e();\n    db.add_batch_users(user_batch);\n}\n\n/// Generates num_accounts number of accounts with num_assets of assets (with equity and debt being seperate vecs)\npub fn gen_accounts_with_random_data(num_accounts: usize, num_assets: usize) -\u003e Vec\u003cAccount\u003e {\n    let mut accounts: Vec\u003cAccount\u003e = Vec::new();\n    let mut rng = rand::thread_rng(); // Create a random number generator\n    for _ in 0..num_accounts {\n        let mut equities = Vec::new();\n        let mut debts = Vec::new();\n        for _ in 0..num_assets {\n            let equity = rng.gen_range(1..1000);\n            let debt = equity - 1; // such that debt is always less than equity\n            equities.push(F::from_canonical_u32(equity));\n            debts.push(F::from_canonical_u32(debt));\n        }\n\n        let mut bytes = [0u8; 32]; // 32 bytes * 2 hex chars per byte = 64 hex chars\n        rng.fill(\u0026mut bytes);\n        #[allow(clippy::format_collect)]\n        let account_id = bytes.iter().map(|byte| format!(\"{:02x}\", byte)).collect::\u003cString\u003e();\n        accounts.push(Account { id: account_id, equity: equities, debt: debts });\n    }\n    accounts\n}\n\npub fn gen_empty_accounts(batch_size: usize, num_assets: usize) -\u003e Vec\u003cAccount\u003e {\n    let accounts =\n        vec![\n            Account::get_empty_account_with_user_id(UserId::rand().to_string(), num_assets);\n            batch_size\n        ];\n    accounts\n}\n","traces":[{"line":23,"address":[8688512,8689382,8689353],"length":1,"stats":{"Line":1}},{"line":24,"address":[12860838,12861792,12861760],"length":1,"stats":{"Line":3}},{"line":26,"address":[12861840,12861808,12860937],"length":1,"stats":{"Line":3}},{"line":28,"address":[12860997],"length":1,"stats":{"Line":1}},{"line":31,"address":[12861090,12861032,12861690],"length":1,"stats":{"Line":2}},{"line":37,"address":[12862164,12861856],"length":1,"stats":{"Line":0}},{"line":40,"address":[8689639,8689567],"length":1,"stats":{"Line":0}},{"line":41,"address":[12861986,12862050],"length":1,"stats":{"Line":0}},{"line":45,"address":[12862192,12862503],"length":1,"stats":{"Line":1}},{"line":47,"address":[12862219],"length":1,"stats":{"Line":1}},{"line":48,"address":[12862314,12862250],"length":1,"stats":{"Line":2}},{"line":49,"address":[12862389,12862330],"length":1,"stats":{"Line":2}},{"line":54,"address":[12863627,12862528],"length":1,"stats":{"Line":1}},{"line":55,"address":[12862663,12862578],"length":1,"stats":{"Line":1}},{"line":57,"address":[12862812,12862599,12863042,12863443,12863226,12862927,12863157,12862691,12863649],"length":1,"stats":{"Line":2}},{"line":58,"address":[12862759,12862620],"length":1,"stats":{"Line":2}},{"line":59,"address":[12862774,12862874],"length":1,"stats":{"Line":2}},{"line":60,"address":[12862989,12862889],"length":1,"stats":{"Line":2}},{"line":61,"address":[12863104,12863004],"length":1,"stats":{"Line":2}},{"line":62,"address":[8690779,8690879],"length":1,"stats":{"Line":2}},{"line":65,"address":[12863417,12863518],"length":1,"stats":{"Line":2}},{"line":67,"address":[12863872,12863691,12863664],"length":1,"stats":{"Line":3}},{"line":72,"address":[12863888],"length":1,"stats":{"Line":0}},{"line":77,"address":[8691571],"length":1,"stats":{"Line":0}},{"line":80,"address":[12864032,12864096],"length":1,"stats":{"Line":0}},{"line":81,"address":[8691744],"length":1,"stats":{"Line":0}},{"line":83,"address":[12864493,12864418],"length":1,"stats":{"Line":0}},{"line":86,"address":[12863997],"length":1,"stats":{"Line":0}},{"line":90,"address":[8693414,8692144,8693383],"length":1,"stats":{"Line":1}},{"line":91,"address":[12864567],"length":1,"stats":{"Line":1}},{"line":92,"address":[8692244,8692320],"length":1,"stats":{"Line":2}},{"line":93,"address":[12864782,12864700,12865599],"length":1,"stats":{"Line":3}},{"line":94,"address":[12864922],"length":1,"stats":{"Line":1}},{"line":95,"address":[12864965],"length":1,"stats":{"Line":1}},{"line":96,"address":[8692669,8692750],"length":1,"stats":{"Line":2}},{"line":97,"address":[12865250,12865608],"length":1,"stats":{"Line":2}},{"line":98,"address":[12865615,12865660],"length":1,"stats":{"Line":1}},{"line":99,"address":[12865644,12865685],"length":1,"stats":{"Line":2}},{"line":100,"address":[12865708],"length":1,"stats":{"Line":1}},{"line":103,"address":[12865204],"length":1,"stats":{"Line":1}},{"line":104,"address":[8692867],"length":1,"stats":{"Line":1}},{"line":106,"address":[12865968,12866223,12865286,12865840,12866347],"length":1,"stats":{"Line":5}},{"line":107,"address":[12865380],"length":1,"stats":{"Line":1}},{"line":109,"address":[12864872],"length":1,"stats":{"Line":1}},{"line":112,"address":[12866368],"length":1,"stats":{"Line":0}},{"line":113,"address":[12866475],"length":1,"stats":{"Line":0}},{"line":115,"address":[12866411],"length":1,"stats":{"Line":0}}],"covered":35,"coverable":47},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","circuit_config.rs"],"content":"use plonky2::{\n    fri::{reduction_strategies::FriReductionStrategy, FriConfig},\n    plonk::circuit_data::CircuitConfig,\n};\n\npub const STANDARD_CONFIG: CircuitConfig = CircuitConfig {\n    num_wires: 135,\n    num_routed_wires: 80,\n    num_constants: 2,\n    use_base_arithmetic_gate: true,\n    security_bits: 100,\n    num_challenges: 2,\n    zero_knowledge: false,\n    max_quotient_degree_factor: 8,\n    fri_config: FriConfig {\n        rate_bits: 3,\n        cap_height: 1,\n        proof_of_work_bits: 16,\n        reduction_strategy: FriReductionStrategy::ConstantArityBits(4, 5),\n        num_query_rounds: 28,\n    },\n};\n\n// A high-rate recursive proof, designed to be verifiable with fewer routed wires.\npub const HIGH_RATE_CONFIG: CircuitConfig = CircuitConfig {\n    num_wires: 135,\n    num_routed_wires: 80,\n    num_constants: 2,\n    use_base_arithmetic_gate: true,\n    security_bits: 100,\n    num_challenges: 2,\n    zero_knowledge: false,\n    max_quotient_degree_factor: 8,\n    fri_config: FriConfig {\n        rate_bits: 7,\n        cap_height: 1,\n        proof_of_work_bits: 16,\n        reduction_strategy: FriReductionStrategy::ConstantArityBits(4, 5),\n        num_query_rounds: 12,\n    },\n};\n\npub const STANDARD_ZK_CONFIG: CircuitConfig = CircuitConfig {\n    num_wires: 135,\n    num_routed_wires: 80,\n    num_constants: 2,\n    use_base_arithmetic_gate: true,\n    security_bits: 100,\n    num_challenges: 2,\n    zero_knowledge: true,\n    max_quotient_degree_factor: 8,\n    fri_config: FriConfig {\n        rate_bits: 3,\n        cap_height: 1,\n        proof_of_work_bits: 16,\n        reduction_strategy: FriReductionStrategy::ConstantArityBits(4, 5),\n        num_query_rounds: 28,\n    },\n};\n\npub fn get_recursive_circuit_configs\u003cconst RECURSION_BRANCHOUT_NUM: usize\u003e(\n    batch_num: usize,\n) -\u003e Vec\u003cCircuitConfig\u003e {\n    let level = (batch_num as f64).log(RECURSION_BRANCHOUT_NUM as f64).ceil() as usize;\n\n    let mut configs = vec![STANDARD_CONFIG; level];\n    *configs.last_mut().unwrap() = STANDARD_ZK_CONFIG;\n    configs\n}\n","traces":[{"line":61,"address":[9406323,9405760],"length":1,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","circuit_registry","mod.rs"],"content":"pub mod registry;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","circuit_registry","registry.rs"],"content":"use plonky2::{\n    hash::hash_types::HashOut,\n    plonk::{\n        circuit_data::{CircuitConfig, CircuitData},\n        proof::ProofWithPublicInputs,\n    },\n};\n\nuse crate::{\n    merkle_sum_prover::circuits::{\n        account_circuit::AccountTargets, merkle_sum_circuit::build_merkle_sum_tree_circuit,\n    },\n    recursive_prover::recursive_circuit::{build_recursive_n_circuit, RecursiveTargets},\n    types::{C, D, F},\n};\n\n#[cfg(not(feature = \"verifier\"))]\nuse crate::{\n    account::gen_empty_accounts, merkle_sum_prover::prover::MerkleSumTreeProver,\n    recursive_prover::prover::RecursiveProver,\n};\n\nuse std::collections::HashMap;\n\n#[allow(clippy::type_complexity)]\npub struct CircuitRegistry\u003cconst RECURSION_BRANCHOUT_NUM: usize\u003e {\n    batch_circuit: (CircuitData\u003cF, C, D\u003e, Vec\u003cAccountTargets\u003e),\n    // inner_vd =\u003e the verification circuit that verify the inner circuit\n    recursive_circuits:\n        HashMap\u003cHashOut\u003cF\u003e, (CircuitData\u003cF, C, D\u003e, RecursiveTargets\u003cRECURSION_BRANCHOUT_NUM\u003e)\u003e,\n    // circuit_vd -\u003e empty proof\n    #[cfg(not(feature = \"verifier\"))]\n    empty_proofs: HashMap\u003cHashOut\u003cF\u003e, ProofWithPublicInputs\u003cF, C, D\u003e\u003e,\n\n    last_inner_circuit_vd: HashOut\u003cF\u003e,\n}\n\nimpl\u003cconst RECURSION_BRANCHOUT_NUM: usize\u003e CircuitRegistry\u003cRECURSION_BRANCHOUT_NUM\u003e {\n    pub fn init(\n        batch_size: usize,\n        token_num: usize,\n        batch_circuit_config: CircuitConfig,\n        recursive_level_configs: Vec\u003cCircuitConfig\u003e,\n    ) -\u003e Self {\n        let init_start = std::time::Instant::now();\n\n        let start = std::time::Instant::now();\n        let (batch_circuit_data, account_targets) =\n            build_merkle_sum_tree_circuit(batch_size, token_num, batch_circuit_config);\n        tracing::info!(\n            \"build merkle sum tree circuit with batch size {} in : {:?}\",\n            batch_size,\n            start.elapsed()\n        );\n\n        let mut recursive_circuits = HashMap::new();\n        let mut last_circuit_data = \u0026batch_circuit_data;\n        let mut last_circuit_vd = last_circuit_data.verifier_only.circuit_digest;\n        let mut _empty_proofs: HashMap\u003cHashOut\u003cF\u003e, ProofWithPublicInputs\u003cF, C, D\u003e\u003e = HashMap::new();\n        let mut _last_empty_proof: ProofWithPublicInputs\u003cF, C, D\u003e;\n\n        #[cfg(not(feature = \"verifier\"))]\n        {\n            let accounts = gen_empty_accounts(batch_size, token_num);\n            let start = std::time::Instant::now();\n            let prover = MerkleSumTreeProver { accounts };\n            let empty_batch_proof =\n                prover.get_proof_with_circuit_data(\u0026account_targets, \u0026batch_circuit_data);\n            tracing::info!(\n                \"prove merkle sum tree with batch size {} in : {:?}\",\n                batch_size,\n                start.elapsed()\n            );\n            _last_empty_proof = empty_batch_proof.clone();\n            _empty_proofs\n                .insert(last_circuit_data.verifier_only.circuit_digest, _last_empty_proof.clone());\n        }\n\n        for (level, circuit_config) in recursive_level_configs.into_iter().enumerate() {\n            let start = std::time::Instant::now();\n            let (recursive_circuit, recursive_targets) =\n                build_recursive_n_circuit::\u003cC, RECURSION_BRANCHOUT_NUM\u003e(\n                    \u0026last_circuit_data.common,\n                    \u0026last_circuit_data.verifier_only,\n                    circuit_config,\n                );\n            tracing::info!(\n                \"build recursive circuit at level {} in : {:?}, with vd {:?}\",\n                level,\n                start.elapsed(),\n                recursive_circuit.verifier_only.circuit_digest\n            );\n\n            #[cfg(not(feature = \"verifier\"))]\n            {\n                let sub_proofs: [ProofWithPublicInputs\u003cF, C, D\u003e; RECURSION_BRANCHOUT_NUM] =\n                    std::array::from_fn(|_| _last_empty_proof.clone());\n                let start = std::time::Instant::now();\n                let recursive_prover = RecursiveProver {\n                    sub_proofs,\n                    sub_circuit_vd: last_circuit_data.verifier_only.clone(),\n                };\n                let recursive_proof = recursive_prover\n                    .get_proof_with_circuit_data(recursive_targets.clone(), \u0026recursive_circuit);\n\n                tracing::info!(\n                    \"prove empty recursive subproofs at level {} in : {:?}\",\n                    level,\n                    start.elapsed()\n                );\n\n                _empty_proofs.insert(\n                    recursive_circuit.verifier_only.circuit_digest,\n                    recursive_proof.clone(),\n                );\n\n                _last_empty_proof = recursive_proof;\n            }\n\n            last_circuit_vd = last_circuit_data.verifier_only.circuit_digest;\n            recursive_circuits.insert(last_circuit_vd, (recursive_circuit, recursive_targets));\n            last_circuit_data = \u0026recursive_circuits[\u0026last_circuit_vd].0;\n        }\n\n        tracing::info!(\n            \"finish init circuit registry with {} recursive levels in {:?}\",\n            recursive_circuits.len(),\n            init_start.elapsed()\n        );\n\n        #[cfg(feature = \"verifier\")]\n        {\n            Self {\n                batch_circuit: (batch_circuit_data, account_targets),\n                recursive_circuits: recursive_circuits,\n                last_inner_circuit_vd: last_circuit_vd,\n            }\n        }\n        #[cfg(not(feature = \"verifier\"))]\n        {\n            Self {\n                batch_circuit: (batch_circuit_data, account_targets),\n                empty_proofs: _empty_proofs,\n                recursive_circuits: recursive_circuits,\n                last_inner_circuit_vd: last_circuit_vd,\n            }\n        }\n    }\n\n    pub fn get_batch_circuit(\u0026self) -\u003e (\u0026CircuitData\u003cF, C, D\u003e, \u0026[AccountTargets]) {\n        (\u0026self.batch_circuit.0, \u0026self.batch_circuit.1)\n    }\n\n    pub fn get_empty_proof(\n        \u0026self,\n        _circuit_vd: \u0026HashOut\u003cF\u003e,\n    ) -\u003e Option\u003c\u0026ProofWithPublicInputs\u003cF, C, D\u003e\u003e {\n        #[cfg(feature = \"verifier\")]\n        {\n            tracing::error!(\"empty proof is not available in verifier mode\");\n            None\n        }\n\n        #[cfg(not(feature = \"verifier\"))]\n        {\n            self.empty_proofs.get(_circuit_vd)\n        }\n    }\n\n    /// leaf node at level 0\n    pub fn get_recursive_circuit(\n        \u0026self,\n        inner_circuit_vd: \u0026HashOut\u003cF\u003e,\n    ) -\u003e Option\u003c(\u0026CircuitData\u003cF, C, D\u003e, \u0026RecursiveTargets\u003cRECURSION_BRANCHOUT_NUM\u003e)\u003e {\n        let circuit_and_targets = self.recursive_circuits.get(inner_circuit_vd)?;\n        Some((\u0026circuit_and_targets.0, \u0026circuit_and_targets.1))\n    }\n\n    pub fn get_recursive_levels(\u0026self) -\u003e usize {\n        self.recursive_circuits.len()\n    }\n\n    pub fn get_root_circuit(\u0026self) -\u003e \u0026CircuitData\u003cF, C, D\u003e {\n        \u0026self.recursive_circuits[\u0026self.last_inner_circuit_vd].0\n    }\n}\n","traces":[{"line":39,"address":[9177526,9164544,9177262],"length":1,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[9166949],"length":1,"stats":{"Line":0}},{"line":59,"address":[9166995],"length":1,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[9167229],"length":1,"stats":{"Line":0}},{"line":67,"address":[9167301,9167396],"length":1,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[9169372],"length":1,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[9172285],"length":1,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[9174582],"length":1,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[9170820],"length":1,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[9164224],"length":1,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[9164416],"length":1,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":73},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","circuit_utils.rs"],"content":"use log::Level;\nuse plonky2::{\n    hash::hash_types::RichField,\n    iop::{target::Target, witness::PartialWitness},\n    plonk::{\n        circuit_builder::CircuitBuilder, circuit_data::CircuitData, config::GenericConfig,\n        prover::prove,\n    },\n    util::timing::TimingTree,\n};\nuse plonky2_field::extension::Extendable;\nuse std::panic;\n\nuse crate::{\n    circuit_config::STANDARD_CONFIG,\n    types::{C, D, F, MAX_POSITIVE_AMOUNT_LOG},\n};\n\npub fn prove_timing() -\u003e TimingTree {\n    let mut level = Level::Info;\n    if cfg!(debug_assertions) {\n        level = Level::Debug;\n    }\n\n    TimingTree::new(\"prove\", level)\n}\n\n/// Test runner for ease of testing\n#[allow(clippy::unused_unit)]\npub fn run_circuit_test\u003cT, F, const D: usize\u003e(test: T)\nwhere\n    T: FnOnce(\u0026mut CircuitBuilder\u003cF, D\u003e, \u0026mut PartialWitness\u003cF\u003e) -\u003e () + panic::UnwindSafe,\n    F: RichField + Extendable\u003cD\u003e,\n    C: GenericConfig\u003cD, F = F\u003e,\n{\n    let mut builder = CircuitBuilder::\u003cF, D\u003e::new(STANDARD_CONFIG);\n    let mut pw: PartialWitness\u003cF\u003e = PartialWitness::\u003cF\u003e::new();\n    test(\u0026mut builder, \u0026mut pw);\n    builder.print_gate_counts(0);\n    let mut timing = TimingTree::new(\"prove\", Level::Debug);\n    let data = builder.build::\u003cC\u003e();\n    let CircuitData { prover_only, common, verifier_only: _ } = \u0026data;\n    let proof = prove(prover_only, common, pw, \u0026mut timing).expect(\"Prove fail\");\n    timing.print();\n    data.verify(proof).expect(\"Verify fail\")\n}\n\n/// Assert 0 \u003c= x \u003c= MAX_POSITIVE_AMOUNT\n/// MAX_POSITIVE_AMOUNT =  (1 \u003c\u003c MAX_POSITIVE_AMOUNT_LOG) - 1\npub fn assert_non_negative_unsigned(builder: \u0026mut CircuitBuilder\u003cF, D\u003e, x: Target) {\n    builder.range_check(x, MAX_POSITIVE_AMOUNT_LOG);\n}\n\n#[cfg(test)]\npub mod test {\n    use crate::types::F;\n\n    use plonky2_field::types::{Field, Field64};\n\n    use super::{assert_non_negative_unsigned, run_circuit_test};\n\n    #[test]\n    fn test_assert_non_negative_unsigned() {\n        run_circuit_test(|builder, _pw| {\n            let x = builder.constant(F::from_canonical_u16(0));\n            assert_non_negative_unsigned(builder, x);\n        });\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_assert_non_negative_unsigned_panic() {\n        run_circuit_test(|builder, _pw| {\n            let x = builder.constant(F::from_canonical_i64(-1));\n            assert_non_negative_unsigned(builder, x);\n        });\n    }\n}\n","traces":[{"line":19,"address":[10942208],"length":1,"stats":{"Line":1}},{"line":20,"address":[10942212],"length":1,"stats":{"Line":1}},{"line":22,"address":[10942221],"length":1,"stats":{"Line":1}},{"line":25,"address":[10942240],"length":1,"stats":{"Line":1}},{"line":30,"address":[10887807,10884921,10883945,10886896,10882992,10884879,10885855,10887849,10883968,10885920,10885897,10887872,10888783,10888825,10886831,10884944,10886873,10883903],"length":1,"stats":{"Line":7}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":6}},{"line":38,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[10888241,10887265,10884337,10883361,10885313,10886289],"length":1,"stats":{"Line":5}},{"line":40,"address":[],"length":0,"stats":{"Line":5}},{"line":41,"address":[10884405,10887333,10888309,10885381,10883429,10886357],"length":1,"stats":{"Line":5}},{"line":42,"address":[],"length":0,"stats":{"Line":5}},{"line":43,"address":[],"length":0,"stats":{"Line":10}},{"line":44,"address":[],"length":0,"stats":{"Line":5}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[10942272],"length":1,"stats":{"Line":1}},{"line":51,"address":[10942281],"length":1,"stats":{"Line":1}}],"covered":17,"coverable":17},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","config.rs"],"content":"use std::str::FromStr;\n\nuse config::{Config, ConfigError, File};\nuse serde::Deserialize;\nuse tracing::Level;\nuse zk_por_tracing::TraceConfig;\n\n#[derive(Debug, Clone, Deserialize)]\npub struct ConfigLog {\n    pub file_name_prefix: String,\n    pub dir: String,\n    pub level: String,\n    pub flame: bool,\n    pub console: bool,\n}\n\nimpl From\u003cConfigLog\u003e for TraceConfig {\n    fn from(log_cfg: ConfigLog) -\u003e Self {\n        TraceConfig {\n            prefix: log_cfg.file_name_prefix,\n            dir: log_cfg.dir,\n            level: Level::from_str(\u0026log_cfg.level).unwrap(),\n            console: log_cfg.console,\n            flame: log_cfg.flame,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct ConfigProver {\n    pub round_no: usize,\n    pub batch_size: Option\u003cusize\u003e,\n    pub tokens: Vec\u003cString\u003e,\n    pub user_data_path: String,\n    pub batch_prove_threads_num: usize,\n    pub recursive_prove_threads_num: usize,\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct ConfigDb {\n    pub level_db_user_path: String,\n    pub level_db_gmst_path: String,\n}\n\nimpl ConfigDb {\n    pub fn load(dir: \u0026str) -\u003e Result\u003cConfig, ConfigError\u003e {\n        let env = std::env::var(\"ENV\").unwrap_or(\"default\".into());\n        Config::builder()\n            .add_source(File::with_name(\u0026format!(\"{}/default\", dir)))\n            .add_source(File::with_name(\u0026format!(\"{}/{}\", dir, env)).required(false))\n            .add_source(File::with_name(\u0026format!(\"{}/local\", dir)).required(false))\n            .add_source(config::Environment::with_prefix(\"ZKPOR\"))\n            .build()\n    }\n    pub fn try_new() -\u003e Result\u003cSelf, ConfigError\u003e {\n        let config = Self::load(\"config\")?;\n        config.try_deserialize()\n    }\n}\n\n#[derive(Debug, Clone, Deserialize)]\npub struct ProverConfig {\n    pub log: ConfigLog,\n    pub prover: ConfigProver,\n    pub db: Option\u003cConfigDb\u003e,\n}\n\nimpl ProverConfig {\n    pub fn load(dir: \u0026str) -\u003e Result\u003cConfig, ConfigError\u003e {\n        let env = std::env::var(\"ENV\").unwrap_or(\"default\".into());\n        Config::builder()\n            // .add_source(File::with_name(\u0026format!(\"{}/default\", dir)))\n            .add_source(File::with_name(\u0026format!(\"{}/{}\", dir, env)).required(false))\n            .add_source(File::with_name(\u0026format!(\"{}/local\", dir)).required(false))\n            .add_source(config::Environment::with_prefix(\"ZKPOR\"))\n            .build()\n    }\n    pub fn try_new() -\u003e Result\u003cSelf, ConfigError\u003e {\n        let config = Self::load(\"config\")?;\n        config.try_deserialize()\n    }\n}\n","traces":[{"line":18,"address":[10649341,10648848,10649296],"length":1,"stats":{"Line":0}},{"line":20,"address":[12721406],"length":1,"stats":{"Line":0}},{"line":21,"address":[12721423],"length":1,"stats":{"Line":0}},{"line":22,"address":[12721536,12721444],"length":1,"stats":{"Line":0}},{"line":23,"address":[12721723],"length":1,"stats":{"Line":0}},{"line":24,"address":[12721726],"length":1,"stats":{"Line":0}},{"line":46,"address":[11231489,11229344,11231596],"length":1,"stats":{"Line":0}},{"line":47,"address":[11229371,11231609],"length":1,"stats":{"Line":0}},{"line":48,"address":[11231019,11231147,11231203,11230000,11230568,11229569],"length":1,"stats":{"Line":0}},{"line":49,"address":[11229740,11231577,11229913,11229629,11230043],"length":1,"stats":{"Line":0}},{"line":50,"address":[11230162,11230307,11231539,11230452,11230611],"length":1,"stats":{"Line":0}},{"line":51,"address":[11230730,11231498,11230903,11231062],"length":1,"stats":{"Line":0}},{"line":52,"address":[10890610,10890723,10891003],"length":1,"stats":{"Line":0}},{"line":55,"address":[11232029,11232000,11231632],"length":1,"stats":{"Line":0}},{"line":56,"address":[11231883,11231649],"length":1,"stats":{"Line":0}},{"line":57,"address":[11231839],"length":1,"stats":{"Line":0}},{"line":69,"address":[11233695,11232048,11233764],"length":1,"stats":{"Line":0}},{"line":70,"address":[11233777,11232075],"length":1,"stats":{"Line":0}},{"line":71,"address":[10892328,10891759,10892765,10892941,10892889],"length":1,"stats":{"Line":0}},{"line":73,"address":[11232720,11233745,11232575,11232879,11232430,11232319],"length":1,"stats":{"Line":0}},{"line":74,"address":[11233704,11232998,11233171,11233328],"length":1,"stats":{"Line":0}},{"line":75,"address":[11233673,11233461,11233344],"length":1,"stats":{"Line":0}},{"line":78,"address":[11233808,11234205,11234176],"length":1,"stats":{"Line":0}},{"line":79,"address":[11233825,11234059],"length":1,"stats":{"Line":0}},{"line":80,"address":[11234015],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","database.rs"],"content":"use std::str::FromStr;\n\nuse hex::ToHex;\nuse plonky2::{hash::hash_types::HashOut, plonk::config::GenericHashOut};\nuse rand::Rng;\nuse zk_por_db::LevelDb;\n\nuse crate::{error::PoRError, global::GLOBAL_MST, types::F};\nuse std::{collections::HashMap, sync::RwLock};\n#[derive(Debug, Clone, Copy, Eq, Hash, PartialEq)]\npub struct UserId(pub [u8; 32]);\n\nimpl UserId {\n    pub fn rand() -\u003e Self {\n        let mut bytes: [u8; 32] = [0; 32];\n        let mut rng = rand::thread_rng();\n        rng.fill(\u0026mut bytes);\n        Self(bytes)\n    }\n\n    pub fn to_string(\u0026self) -\u003e String {\n        self.0.encode_hex()\n    }\n\n    pub fn from_hex_string(hex_str: String) -\u003e Result\u003cSelf, PoRError\u003e {\n        if hex_str.len() != 64 {\n            tracing::error!(\"User Id: {:?} is not a valid id, length is not 256 bits\", hex_str);\n            return Err(PoRError::InvalidParameter(hex_str));\n        }\n\n        let decode_res = hex::decode(hex_str.clone());\n\n        if decode_res.is_err() {\n            tracing::error!(\"User Id: {:?} is not a valid id\", hex_str);\n            return Err(PoRError::InvalidParameter(hex_str));\n        }\n\n        let mut arr = [0u8; 32];\n        arr.copy_from_slice(\u0026decode_res.unwrap());\n\n        Ok(UserId { 0: arr })\n    }\n}\n\nimpl db_key::Key for UserId {\n    fn from_u8(key: \u0026[u8]) -\u003e UserId {\n        assert!(key.len() == 32);\n        let mut output: [u8; 32] = [0; 32];\n        unsafe {\n            std::ptr::copy_nonoverlapping(key.as_ptr(), output.as_mut_ptr(), 32);\n        }\n        UserId(output)\n    }\n\n    fn as_slice\u003cT, F: Fn(\u0026[u8]) -\u003e T\u003e(\u0026self, f: F) -\u003e T {\n        let dst = self.0.as_slice();\n        f(\u0026dst)\n    }\n}\n\npub trait PoRDB: Sync + Send {\n    fn add_batch_users(\u0026mut self, batches: Vec\u003c(UserId, u32)\u003e);\n    fn get_user_index(\u0026self, user_id: UserId) -\u003e Option\u003cu32\u003e;\n    fn add_batch_gmst_nodes(\u0026mut self, batches: Vec\u003c(i32, HashOut\u003cF\u003e)\u003e);\n    fn get_gmst_node_hash(\u0026self, node_idx: i32) -\u003e Option\u003cHashOut\u003cF\u003e\u003e;\n}\n\npub struct PoRLevelDBOption {\n    pub user_map_dir: String,\n    pub gmst_dir: String,\n}\n\npub struct PoRLevelDB {\n    user_db: LevelDb\u003cUserId\u003e,\n    gmst_db: LevelDb\u003ci32\u003e, // we use i32 as a key of type u32 is not provided by default in leveldb\n}\n\nimpl PoRLevelDB {\n    pub fn new(opt: PoRLevelDBOption) -\u003e Self {\n        Self {\n            user_db: LevelDb::new(\u0026std::path::PathBuf::from_str(\u0026opt.user_map_dir).unwrap()),\n            gmst_db: LevelDb::new(\u0026std::path::PathBuf::from_str(\u0026opt.gmst_dir).unwrap()),\n        }\n    }\n}\n\nimpl PoRDB for PoRLevelDB {\n    fn add_batch_users(\u0026mut self, batches: Vec\u003c(UserId, u32)\u003e) {\n        let batches = batches\n            .into_iter()\n            .map(|(id, idx)| (id, idx.to_be_bytes().to_vec()))\n            .collect::\u003cVec\u003c(UserId, Vec\u003cu8\u003e)\u003e\u003e();\n        self.user_db.batch_put(batches)\n    }\n\n    fn get_user_index(\u0026self, user_id: UserId) -\u003e Option\u003cu32\u003e {\n        let ret = self.user_db.get(user_id).map(|x| {\n            let mut buf = [0; 4];\n            buf.as_mut_slice().copy_from_slice(\u0026x[0..4]);\n            u32::from_be_bytes(buf)\n        });\n        ret\n    }\n\n    /// 0: the index of the gmst\n    /// 1: the hash value at that index\n    fn add_batch_gmst_nodes(\u0026mut self, batches: Vec\u003c(i32, HashOut\u003cF\u003e)\u003e) {\n        let batches = batches\n            .into_iter()\n            .map(|(id, hash)| {\n                let ret = (id, hash.to_bytes());\n                ret\n            })\n            .collect::\u003cVec\u003c(i32, Vec\u003cu8\u003e)\u003e\u003e();\n        self.gmst_db.batch_put(batches);\n    }\n\n    fn get_gmst_node_hash(\u0026self, node_idx: i32) -\u003e Option\u003cHashOut\u003cF\u003e\u003e {\n        let ret = self.gmst_db.get(node_idx).map(|x| {\n            let ret = HashOut::\u003cF\u003e::from_bytes(\u0026x);\n            ret\n        });\n        ret\n    }\n}\n\npub struct PoRMemoryDB {\n    user_map: HashMap\u003cUserId, u32\u003e,\n    gmst_map: HashMap\u003ci32, HashOut\u003cF\u003e\u003e,\n}\n\nimpl PoRMemoryDB {\n    pub fn new() -\u003e Self {\n        Self { user_map: HashMap::new(), gmst_map: HashMap::new() }\n    }\n}\n\nimpl PoRDB for RwLock\u003cPoRMemoryDB\u003e {\n    fn add_batch_users(\u0026mut self, batches: Vec\u003c(UserId, u32)\u003e) {\n        for (id, idx) in batches {\n            self.write().unwrap().user_map.insert(id, idx);\n        }\n    }\n\n    fn get_user_index(\u0026self, user_id: UserId) -\u003e Option\u003cu32\u003e {\n        self.read().unwrap().user_map.get(\u0026user_id).map(|x| *x)\n    }\n\n    fn add_batch_gmst_nodes(\u0026mut self, batches: Vec\u003c(i32, HashOut\u003cF\u003e)\u003e) {\n        for (id, hash) in batches {\n            self.write().unwrap().gmst_map.insert(id, hash);\n        }\n    }\n\n    fn get_gmst_node_hash(\u0026self, node_idx: i32) -\u003e Option\u003cHashOut\u003cF\u003e\u003e {\n        self.read().unwrap().gmst_map.get(\u0026node_idx).map(|x| *x)\n    }\n}\n\n/// PoRGMSTMemoryDB delegates the query on gmst node to the direct access of global GMST. For user_db, the query is delegated to PoRMemoryDB.\n/// This is to save memory fingerprint.\npub struct PoRGMSTMemoryDB {\n    user_db: RwLock\u003cPoRMemoryDB\u003e,\n}\n///\nimpl PoRGMSTMemoryDB {\n    pub fn new() -\u003e Self {\n        Self { user_db: RwLock::new(PoRMemoryDB::new()) }\n    }\n}\n\nimpl PoRDB for PoRGMSTMemoryDB {\n    fn add_batch_users(\u0026mut self, batches: Vec\u003c(UserId, u32)\u003e) {\n        self.user_db.add_batch_users(batches);\n    }\n\n    fn get_user_index(\u0026self, user_id: UserId) -\u003e Option\u003cu32\u003e {\n        self.user_db.get_user_index(user_id)\n    }\n\n    #[inline(always)]\n    fn add_batch_gmst_nodes(\u0026mut self, _batches: Vec\u003c(i32, HashOut\u003cF\u003e)\u003e) {\n        // do nothing as we assume GMST is already built.\n        return;\n    }\n\n    fn get_gmst_node_hash(\u0026self, node_idx: i32) -\u003e Option\u003cHashOut\u003cF\u003e\u003e {\n        GLOBAL_MST.get().unwrap().read().unwrap().inner.get(node_idx as usize).map(|x| *x)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use plonky2::{field::types::Sample, hash::hash_types::HashOut};\n    use tempdir::TempDir;\n\n    use crate::{\n        database::{PoRDB, PoRLevelDB, PoRLevelDBOption, PoRMemoryDB, UserId},\n        types::F,\n    };\n    use std::sync::RwLock;\n\n    fn test_database(mut db: Box\u003cdyn PoRDB\u003e) {\n        let batches_user = (0..4)\n            .into_iter()\n            .map(|i| {\n                let id = UserId::rand();\n                let idx = i;\n                (id, idx)\n            })\n            .collect::\u003cVec\u003c(UserId, u32)\u003e\u003e();\n        db.add_batch_users(batches_user.clone());\n        assert_eq!(db.get_user_index(batches_user[0].0), Some(0));\n        assert_eq!(db.get_user_index(batches_user[3].0), Some(3));\n\n        let batches_hash = (0..4)\n            .into_iter()\n            .map(|i| (i, HashOut::\u003cF\u003e::from_vec(vec![F::rand(), F::rand(), F::rand(), F::rand()])))\n            .collect::\u003cVec\u003c(i32, HashOut\u003cF\u003e)\u003e\u003e();\n        db.add_batch_gmst_nodes(batches_hash.clone());\n\n        assert_eq!(db.get_gmst_node_hash(0), Some(batches_hash[0].1));\n        assert_eq!(db.get_gmst_node_hash(1), Some(batches_hash[1].1));\n        assert_eq!(db.get_gmst_node_hash(2), Some(batches_hash[2].1));\n        assert_eq!(db.get_gmst_node_hash(3), Some(batches_hash[3].1));\n    }\n\n    #[test]\n    fn test_leveldb() {\n        let tempdir_user = TempDir::new(\"example_user\").unwrap();\n        let tempdir_gmst = TempDir::new(\"example_gmst\").unwrap();\n        let db = PoRLevelDB::new(PoRLevelDBOption {\n            user_map_dir: tempdir_user.path().to_string_lossy().into_owned(),\n            gmst_dir: tempdir_gmst.path().to_string_lossy().into_owned(),\n        });\n        test_database(Box::new(db));\n    }\n\n    #[test]\n    fn test_memorydb() {\n        let db = PoRMemoryDB::new();\n        test_database(Box::new(RwLock::new(db)));\n    }\n}\n","traces":[{"line":14,"address":[8694301,8694112],"length":1,"stats":{"Line":1}},{"line":15,"address":[12866525],"length":1,"stats":{"Line":1}},{"line":16,"address":[12866538],"length":1,"stats":{"Line":1}},{"line":17,"address":[12866552],"length":1,"stats":{"Line":1}},{"line":18,"address":[12866609],"length":1,"stats":{"Line":1}},{"line":21,"address":[12866736],"length":1,"stats":{"Line":0}},{"line":22,"address":[8694337],"length":1,"stats":{"Line":0}},{"line":25,"address":[12871053,12866784,12868063],"length":1,"stats":{"Line":0}},{"line":26,"address":[12866914,12866826],"length":1,"stats":{"Line":0}},{"line":27,"address":[12870566,12870031,12870218,12870630,12870804,12870330,12869636],"length":1,"stats":{"Line":0}},{"line":28,"address":[8697950],"length":1,"stats":{"Line":0}},{"line":31,"address":[12866928,12867100],"length":1,"stats":{"Line":0}},{"line":33,"address":[12867135,12867241],"length":1,"stats":{"Line":0}},{"line":34,"address":[12868824,12869105,12868495,12868079,12869344,12869169,12868694],"length":1,"stats":{"Line":0}},{"line":35,"address":[12868899],"length":1,"stats":{"Line":0}},{"line":38,"address":[12867251],"length":1,"stats":{"Line":0}},{"line":39,"address":[12867271,12867683],"length":1,"stats":{"Line":0}},{"line":41,"address":[12867844],"length":1,"stats":{"Line":0}},{"line":46,"address":[12871088],"length":1,"stats":{"Line":0}},{"line":47,"address":[12871124,12871385],"length":1,"stats":{"Line":0}},{"line":48,"address":[12871134],"length":1,"stats":{"Line":0}},{"line":52,"address":[12871302],"length":1,"stats":{"Line":0}},{"line":55,"address":[12871487,12871584,12871424,12871623],"length":1,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[12872351,12871712,12872382],"length":1,"stats":{"Line":1}},{"line":81,"address":[12871742,12871873,12871818],"length":1,"stats":{"Line":3}},{"line":82,"address":[12871946,12872076,12872021],"length":1,"stats":{"Line":3}},{"line":88,"address":[12872400],"length":1,"stats":{"Line":1}},{"line":89,"address":[12872413],"length":1,"stats":{"Line":1}},{"line":91,"address":[12872480,12872499],"length":1,"stats":{"Line":2}},{"line":93,"address":[12872460],"length":1,"stats":{"Line":1}},{"line":96,"address":[12872656],"length":1,"stats":{"Line":1}},{"line":97,"address":[12872752,12872671,12872981],"length":1,"stats":{"Line":2}},{"line":98,"address":[12872761],"length":1,"stats":{"Line":1}},{"line":99,"address":[12872769,12872855],"length":1,"stats":{"Line":2}},{"line":100,"address":[12872930],"length":1,"stats":{"Line":1}},{"line":107,"address":[12873008],"length":1,"stats":{"Line":1}},{"line":108,"address":[12873021],"length":1,"stats":{"Line":1}},{"line":110,"address":[12873107,12873088],"length":1,"stats":{"Line":2}},{"line":111,"address":[8700625],"length":1,"stats":{"Line":1}},{"line":115,"address":[12873068],"length":1,"stats":{"Line":1}},{"line":118,"address":[8700688],"length":1,"stats":{"Line":1}},{"line":119,"address":[12873296,12873254,12873423],"length":1,"stats":{"Line":2}},{"line":120,"address":[12873323,12873391],"length":1,"stats":{"Line":2}},{"line":133,"address":[8700896,8701023],"length":1,"stats":{"Line":1}},{"line":134,"address":[12873473],"length":1,"stats":{"Line":1}},{"line":139,"address":[13043425,13042784],"length":1,"stats":{"Line":1}},{"line":140,"address":[13042937,13042971,13042804],"length":1,"stats":{"Line":3}},{"line":141,"address":[13043018,13043258],"length":1,"stats":{"Line":2}},{"line":145,"address":[13043456,13043789],"length":1,"stats":{"Line":1}},{"line":146,"address":[10498167,10498396,10498331],"length":1,"stats":{"Line":5}},{"line":149,"address":[13043824,13044473],"length":1,"stats":{"Line":1}},{"line":150,"address":[10498516,10498671,10498640],"length":1,"stats":{"Line":3}},{"line":151,"address":[13044056,13044296],"length":1,"stats":{"Line":2}},{"line":155,"address":[13044839,13044496],"length":1,"stats":{"Line":1}},{"line":156,"address":[13044701,13044769,13044522],"length":1,"stats":{"Line":5}},{"line":167,"address":[12873680],"length":1,"stats":{"Line":0}},{"line":168,"address":[8701137],"length":1,"stats":{"Line":0}},{"line":173,"address":[12873776],"length":1,"stats":{"Line":0}},{"line":174,"address":[12873781],"length":1,"stats":{"Line":0}},{"line":177,"address":[12873792],"length":1,"stats":{"Line":0}},{"line":178,"address":[12873801],"length":1,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[12874303,12873840],"length":1,"stats":{"Line":0}},{"line":188,"address":[12873870,12874132,12874206,12874336,12874344,12873944],"length":1,"stats":{"Line":0}}],"covered":40,"coverable":67},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","e2e.rs"],"content":"use plonky2::plonk::{circuit_data::VerifierOnlyCircuitData, proof::ProofWithPublicInputs};\n\nuse indicatif::ProgressBar;\nuse rayon::prelude::*;\n\nuse crate::{\n    account::Account,\n    circuit_registry::registry::CircuitRegistry,\n    merkle_sum_prover::prover::MerkleSumTreeProver,\n    recursive_prover::prover::RecursiveProver,\n    types::{C, D, F},\n};\n\npub fn batch_prove_accounts\u003cconst RECURSION_BRANCHOUT_NUM: usize\u003e(\n    circuit_registry: \u0026CircuitRegistry\u003cRECURSION_BRANCHOUT_NUM\u003e,\n    account_batches: Vec\u003cAccount\u003e,\n    parallism: usize,\n    batch_size: usize,\n) -\u003e Vec\u003cProofWithPublicInputs\u003cF, C, D\u003e\u003e {\n    let mut batch_proofs: Vec\u003cProofWithPublicInputs\u003cF, C, D\u003e\u003e = Vec::new();\n    let (batch_circuit, account_targets) = circuit_registry.get_batch_circuit();\n\n    let _ = account_batches\n        .chunks(parallism * batch_size)\n        .map(|chunk| {\n            let proofs: Vec\u003cProofWithPublicInputs\u003cF, C, D\u003e\u003e = chunk\n                .par_chunks(batch_size)\n                .map(|accounts| {\n                    let prover = MerkleSumTreeProver { accounts: accounts.to_owned() };\n                    let proof = prover.get_proof_with_circuit_data(account_targets, \u0026batch_circuit);\n                    proof\n                })\n                .collect();\n            batch_proofs.extend(proofs.into_iter());\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    batch_proofs\n}\n\npub fn prove_subproofs\u003cconst RECURSION_BRANCHOUT_NUM: usize\u003e(\n    subproofs: Vec\u003cProofWithPublicInputs\u003cF, C, D\u003e\u003e,\n    last_level_circuit_vd: VerifierOnlyCircuitData\u003cC, D\u003e,\n    circuit_registry: \u0026CircuitRegistry\u003cRECURSION_BRANCHOUT_NUM\u003e,\n    parallism: usize,\n    level: usize,\n) -\u003e Vec\u003cProofWithPublicInputs\u003cF, C, D\u003e\u003e {\n    let bar = ProgressBar::new(subproofs.len() as u64);\n    assert_eq!(subproofs.len() % RECURSION_BRANCHOUT_NUM, 0);\n    let last_level_vd_digest = last_level_circuit_vd.circuit_digest;\n\n    let (recursive_circuit, recursive_targets) =\n        circuit_registry.get_recursive_circuit(\u0026last_level_vd_digest).expect(\n            format!(\n                \"No recursive circuit found for inner circuit with vd {:?}\",\n                last_level_vd_digest\n            )\n            .as_str(),\n        );\n\n    let expected_this_level_proof_num = subproofs.len() / RECURSION_BRANCHOUT_NUM;\n    let mut this_level_proofs = vec![];\n\n    let _ = subproofs\n        .chunks(parallism * RECURSION_BRANCHOUT_NUM)\n        .map(|chunk| {\n            let proofs: Vec\u003cProofWithPublicInputs\u003cF, C, D\u003e\u003e = chunk\n                .par_chunks(RECURSION_BRANCHOUT_NUM)\n                .map(|subproofs| {\n                    let recursive_prover = RecursiveProver {\n                        sub_proofs: subproofs\n                            .to_owned()\n                            .try_into()\n                            .expect(\"subproofs length not equal to RECURSION_BRANCHOUT_NUM\"),\n                        sub_circuit_vd: last_level_circuit_vd.clone(),\n                    };\n                    let proof = recursive_prover\n                        .get_proof_with_circuit_data(recursive_targets.clone(), \u0026recursive_circuit);\n                    proof\n                })\n                .collect();\n            this_level_proofs.extend(proofs.into_iter());\n            bar.inc((this_level_proofs.len() * RECURSION_BRANCHOUT_NUM) as u64);\n            tracing::debug!(\n                \"finish {}/{} proofs in level {}/{}\",\n                this_level_proofs.len(),\n                expected_this_level_proof_num,\n                level,\n                circuit_registry.get_recursive_levels()\n            );\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    bar.finish();\n\n    this_level_proofs\n}\n\npub fn recursive_prove_subproofs\u003cconst RECURSION_BRANCHOUT_NUM: usize\u003e(\n    subproofs: Vec\u003cProofWithPublicInputs\u003cF, C, D\u003e\u003e,\n    circuit_registry: \u0026CircuitRegistry\u003cRECURSION_BRANCHOUT_NUM\u003e,\n    parallism: usize,\n) -\u003e ProofWithPublicInputs\u003cF, C, D\u003e {\n    let (batch_circuit, _) = circuit_registry.get_batch_circuit();\n    let mut last_level_circuit_vd = batch_circuit.verifier_only.clone();\n    let mut last_level_proofs = subproofs;\n    let recursive_levels = circuit_registry.get_recursive_levels();\n    tracing::info!(\"total recursive levels: {:?}\", recursive_levels);\n\n    for level in 1..=recursive_levels {\n        let start = std::time::Instant::now();\n\n        let last_level_vd_digest = last_level_circuit_vd.circuit_digest;\n        let last_level_empty_proof = circuit_registry\n            .get_empty_proof(\u0026last_level_vd_digest)\n            .expect(\n                format!(\"fail to find empty proof for circuit vd {:?}\", last_level_vd_digest)\n                    .as_str(),\n            )\n            .clone();\n\n        let subproof_len = last_level_proofs.len();\n\n        if subproof_len % RECURSION_BRANCHOUT_NUM != 0 {\n            let pad_num = RECURSION_BRANCHOUT_NUM - subproof_len % RECURSION_BRANCHOUT_NUM;\n            tracing::info!(\"At level {}, {} subproofs are not a multiple of RECURSION_BRANCHOUT_NUM {}, hence padding {} empty proofs. \", level, subproof_len, RECURSION_BRANCHOUT_NUM, pad_num);\n\n            last_level_proofs.resize(subproof_len + pad_num, last_level_empty_proof);\n        }\n\n        last_level_proofs = prove_subproofs(\n            last_level_proofs,\n            last_level_circuit_vd.clone(),\n            circuit_registry,\n            parallism,\n            level,\n        );\n\n        let recursive_circuit = circuit_registry\n            .get_recursive_circuit(\u0026last_level_circuit_vd.circuit_digest)\n            .expect(\n                format!(\n                    \"No recursive circuit found for inner circuit with vd {:?}\",\n                    last_level_circuit_vd.circuit_digest\n                )\n                .as_str(),\n            )\n            .0;\n\n        last_level_circuit_vd = recursive_circuit.verifier_only.clone();\n\n        tracing::info!(\n            \"finish recursive level {} with {} proofs in : {:?}\",\n            level,\n            last_level_proofs.len(),\n            start.elapsed()\n        );\n    }\n\n    if last_level_proofs.len() != 1 {\n        panic!(\"The last level proofs should be of length 1, but got {}\", last_level_proofs.len());\n    }\n    let root_proof = last_level_proofs.pop().unwrap();\n    circuit_registry\n        .get_root_circuit()\n        .verify(root_proof.clone())\n        .expect(\"fail to verify root proof\");\n    root_proof\n}\n","traces":[{"line":14,"address":[9186371,9185872],"length":1,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[9185988,9186034],"length":1,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[9186436],"length":1,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[9186326],"length":1,"stats":{"Line":0}},{"line":41,"address":[9183326,9181968],"length":1,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[9182140,9182193],"length":1,"stats":{"Line":0}},{"line":50,"address":[9182339],"length":1,"stats":{"Line":0}},{"line":52,"address":[9182752],"length":1,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[9182795],"length":1,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[9185764],"length":1,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[9183557,9183736],"length":1,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[9183175],"length":1,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":96},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","error.rs"],"content":"use config::ConfigError;\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum PoRError {\n    #[error(\"Proof is not valid\")]\n    InvalidProof,\n\n    #[error(\"Merkle proof is not valid for accountID {0}\")]\n    InvalidMerkleProof(String),\n\n    #[error(\"config error: {0}\")]\n    ConfigError(#[from] ConfigError),\n\n    #[error(\"IO error occurred: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"Unknown error\")]\n    Unknown,\n\n    #[error(\"Invalid parameter: {0}\")]\n    InvalidParameter(String),\n\n    #[error(\"The verification circuit digest does not match the prover. \")]\n    CircuitDigestMismatch,\n\n    #[error(\"User is not valid\")]\n    InvalidUser,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","global.rs"],"content":"use crate::{\n    database::PoRDB,\n    merkle_sum_prover::utils::hash_2_subhashes,\n    recursive_prover::prover::hash_n_subhashes,\n    types::{D, F},\n    util::{get_node_level, pad_to_multiple_of},\n};\nuse once_cell::sync::OnceCell;\nuse plonky2::{hash::hash_types::HashOut, util::log2_strict};\nuse std::{ops::Div, sync::RwLock};\nuse tracing::debug;\n\n#[derive(Debug, Clone, Copy)]\npub struct GlobalConfig {\n    pub num_of_tokens: usize,\n    pub num_of_batches: usize,\n    pub batch_size: usize, // num of accounts witin one batch\n    pub recursion_branchout_num: usize,\n}\n\npub static GLOBAL_MST: OnceCell\u003cRwLock\u003cGlobalMst\u003e\u003e = OnceCell::new();\n\npub struct GlobalMst {\n    pub inner: Vec\u003cHashOut\u003cF\u003e\u003e,\n    top_recursion_level: usize,\n    pub cfg: GlobalConfig,\n}\n\nimpl GlobalMst {\n    pub fn new(cfg: GlobalConfig) -\u003e Self {\n        let top_level =\n            (cfg.num_of_batches as f64).log(cfg.recursion_branchout_num as f64).ceil() as usize;\n\n        let mst_vec = vec![HashOut::default(); 0]; // will resize later\n        let mut mst = Self { inner: mst_vec, top_recursion_level: top_level, cfg: cfg };\n        // the number of hash is one smaller to the index of the root node of the last recursion level.\n        let root_node_idx = GlobalMst::get_recursive_global_index(\u0026cfg, top_level, 0);\n        let tree_size = root_node_idx + 1;\n        mst.inner.resize(tree_size, HashOut::default());\n        mst\n    }\n\n    pub fn get_tree_length(\u0026self) -\u003e usize {\n        self.inner.len()\n    }\n\n    pub fn get_num_of_leaves(cfg: \u0026GlobalConfig) -\u003e usize {\n        cfg.batch_size * cfg.num_of_batches\n    }\n\n    pub fn get_nodes(\u0026self, range: std::ops::Range\u003cusize\u003e) -\u003e \u0026[HashOut\u003cF\u003e] {\n        \u0026self.inner[range]\n    }\n\n    pub fn get_root(\u0026self) -\u003e Option\u003c\u0026HashOut\u003cF\u003e\u003e {\n        self.inner.last()\n    }\n\n    /// convert a mst node inner index to global index in gmst.\n    /// For a mst, the inner index is level-by-level, e.g.,\n    ///       14\n    ///   12      13\n    ///  8-9,   10-11\n    /// 0 - 3,  4 - 7\n    pub fn get_batch_tree_global_index(\n        cfg: \u0026GlobalConfig,\n        batch_idx: usize,\n        inner_tree_idx: usize,\n    ) -\u003e usize {\n        let batch_size = cfg.batch_size;\n        let tree_depth = log2_strict(batch_size);\n        let batch_tree_level = get_node_level(batch_size, inner_tree_idx);\n\n        let level_from_bottom = tree_depth - batch_tree_level;\n\n        let numeritor = 2 * batch_size * cfg.num_of_batches;\n        let global_tree_vertical_offset = numeritor - numeritor.div(1 \u003c\u003c level_from_bottom); // the gmst idx of the first node at {level_from_bottom} level\n\n        let level_node_counts = batch_size.div(1 \u003c\u003c level_from_bottom);\n        let global_inter_tree_horizontal_offset = level_node_counts * (batch_idx); // the number of preceding nodes at {level_from_bottom} level in the preceding mst.\n\n        let intra_tree_horizontal_offset =\n            inner_tree_idx - (2 * batch_size - 2 * batch_size.div(1 \u003c\u003c level_from_bottom));\n        // the number of preceding nodes at {level_from_bottom} level in the current mst.\n\n        let index = global_tree_vertical_offset\n            + global_inter_tree_horizontal_offset\n            + intra_tree_horizontal_offset;\n        index\n    }\n\n    // mst root node at level 0,\n    pub fn get_recursive_global_index(\n        cfg: \u0026GlobalConfig,\n        recursive_level: usize,\n        inner_level_idx: usize,\n    ) -\u003e usize {\n        let mst_node_num = 2 * cfg.batch_size - 1;\n        let batch_num = cfg.num_of_batches;\n        let branchout_num = cfg.recursion_branchout_num;\n        if recursive_level == 0 {\n            // level of merkle sum tree root\n            if inner_level_idx \u003c cfg.num_of_batches {\n                // the global index of the root of the batch tree\n                let mst_root_idx = mst_node_num - 1;\n                return GlobalMst::get_batch_tree_global_index(cfg, inner_level_idx, mst_root_idx);\n            } else {\n                return batch_num * mst_node_num + (inner_level_idx - cfg.num_of_batches);\n            }\n        }\n\n        // pad num_of_batches to be multiple of recursion_branchout_num.\n        let pad_num = if batch_num % branchout_num == 0 {\n            0\n        } else {\n            branchout_num - batch_num % branchout_num\n        };\n\n        let mut last_level_node_num = batch_num + pad_num;\n        assert_eq!(0, last_level_node_num % branchout_num);\n\n        let mut recursive_offset = batch_num * mst_node_num + pad_num;\n\n        let mut level = recursive_level;\n        while level \u003e 1 {\n            let mut this_level_node_num = last_level_node_num / cfg.recursion_branchout_num;\n            this_level_node_num =\n                pad_to_multiple_of(this_level_node_num, cfg.recursion_branchout_num);\n\n            recursive_offset += this_level_node_num;\n\n            last_level_node_num = this_level_node_num;\n            level -= 1;\n        }\n\n        let global_recursive_index = recursive_offset + inner_level_idx;\n        global_recursive_index\n    }\n\n    /// `batch_idx`: index indicating the batch index\n    /// `i`: the sub batch tree index; e.g the batch tree is of size 1\u003c\u003c10; i \\in [0, 2*batch_size)\n    pub fn set_batch_hash(\u0026mut self, batch_idx: usize, i: usize, hash: HashOut\u003cF\u003e) {\n        let global_mst_idx = GlobalMst::get_batch_tree_global_index(\u0026self.cfg, batch_idx, i);\n        self.inner[global_mst_idx] = hash;\n    }\n\n    pub fn get_batch_root_hash(\u0026self, batch_idx: usize) -\u003e HashOut\u003cF\u003e {\n        debug!(\"get batch root hash, batch_idx: {:?}\", batch_idx);\n        assert!(batch_idx \u003c self.cfg.num_of_batches);\n        let root_idx = GlobalMst::get_batch_tree_global_index(\n            \u0026self.cfg,\n            batch_idx,\n            2 * self.cfg.batch_size - 2,\n        );\n        self.inner[root_idx]\n    }\n\n    /// `recursive_level` count from bottom to top; recursive_level = 1 means the bottom layer; increase whilve moving to the top.\n    pub fn set_recursive_hash(\u0026mut self, recursive_level: usize, index: usize, hash: HashOut\u003cF\u003e) {\n        debug!(\n            \"set_recursive_hash, recursive_level: {:?}, index: {:?}, hash: {:?}\",\n            recursive_level, index, hash\n        );\n        let idx = GlobalMst::get_recursive_global_index(\u0026self.cfg, recursive_level, index);\n        self.inner[idx] = hash;\n    }\n\n    pub fn is_integral(\u0026self) -\u003e bool {\n        // we check all nodes are examined to ensure global_index-related functions are correct.\n        let mut visited_global_idx = vec![false; self.inner.len()];\n        let batch_num = self.cfg.num_of_batches;\n        for tree_idx in 0..self.cfg.num_of_batches {\n            let leaf_size = self.cfg.batch_size;\n            let mst_size = 2 * leaf_size - 1;\n            for inner_tree_idx in leaf_size..mst_size {\n                let inner_left_child_idx = 2 * (inner_tree_idx - leaf_size);\n                let inner_right_child_idx = 2 * (inner_tree_idx - leaf_size) + 1;\n\n                let global_parent_idx =\n                    GlobalMst::get_batch_tree_global_index(\u0026self.cfg, tree_idx, inner_tree_idx);\n                let global_left_child_idx = GlobalMst::get_batch_tree_global_index(\n                    \u0026self.cfg,\n                    tree_idx,\n                    inner_left_child_idx,\n                );\n                let global_right_child_idx = GlobalMst::get_batch_tree_global_index(\n                    \u0026self.cfg,\n                    tree_idx,\n                    inner_right_child_idx,\n                );\n\n                visited_global_idx[global_left_child_idx] = true;\n                visited_global_idx[global_right_child_idx] = true;\n\n                let expected_parent_hash = hash_2_subhashes::\u003cF, D\u003e(\n                    \u0026self.inner[global_left_child_idx],\n                    \u0026self.inner[global_right_child_idx],\n                );\n                if expected_parent_hash != self.inner[global_parent_idx] {\n                    tracing::error!(\"Inconsistent hash at mst tree {}, global index (parent: {:?}, left child: {:?}, right child: {:?}), inner index (parent: {:?}, left child: {:?}, right child: {:?}), expected parent hash: {:?}, actual parent hash: {:?}\", tree_idx, global_parent_idx, global_left_child_idx, global_right_child_idx,  inner_tree_idx, inner_left_child_idx, inner_right_child_idx, expected_parent_hash, self.inner[global_parent_idx]);\n                    return false;\n                }\n            }\n        }\n        let branchout_num = self.cfg.recursion_branchout_num;\n        let mut last_level_node_count = pad_to_multiple_of(batch_num, branchout_num);\n        for level in 1..=self.top_recursion_level {\n            let this_level_node_count = last_level_node_count / branchout_num;\n            for inner_idx in 0..this_level_node_count {\n                let inner_child_indexes = (0..branchout_num)\n                    .map(|i| inner_idx * branchout_num + i)\n                    .collect::\u003cVec\u003cusize\u003e\u003e();\n                let global_idx = GlobalMst::get_recursive_global_index(\u0026self.cfg, level, inner_idx);\n                let global_child_indexes = inner_child_indexes\n                    .iter()\n                    .map(|\u0026i| {\n                        let child_global_idx =\n                            GlobalMst::get_recursive_global_index(\u0026self.cfg, level - 1, i);\n                        visited_global_idx[child_global_idx] = true;\n                        child_global_idx\n                    })\n                    .collect::\u003cVec\u003cusize\u003e\u003e();\n\n                let children_hashes = global_child_indexes\n                    .iter()\n                    .map(|\u0026i| self.inner[i])\n                    .collect::\u003cVec\u003cHashOut\u003cF\u003e\u003e\u003e();\n\n                let expected_parent_hash = hash_n_subhashes::\u003cF, D\u003e(\u0026children_hashes);\n\n                if expected_parent_hash != self.inner[global_idx] {\n                    tracing::error!(\"Inconsistent hash at recursive level {}, Global index: {:?}, global child indexes: {:?}, inner index: {:?}, child indexes {:?}, expected parent hash: {:?}, actual parent hash: {:?}. \", level, global_idx, global_child_indexes, inner_idx, inner_child_indexes, expected_parent_hash, self.inner[global_idx]);\n                    return false;\n                }\n                last_level_node_count = pad_to_multiple_of(this_level_node_count, branchout_num);\n            }\n        }\n        let global_root_idx =\n            GlobalMst::get_recursive_global_index(\u0026self.cfg, self.top_recursion_level, 0);\n        visited_global_idx[global_root_idx] = true;\n\n        visited_global_idx.iter().all(|\u0026v| v)\n    }\n\n    pub fn persist(\u0026self, db: \u0026mut Box\u003cdyn PoRDB\u003e) {\n        let length = self.get_tree_length();\n        tracing::info!(\"start to persist gmst into db of size: {:?}\", length);\n        let chunk_size = 1 \u003c\u003c 12;\n        let mut i = 0;\n        while i \u003c length {\n            let end = if i + chunk_size \u003c= length { i + chunk_size } else { length };\n            let nodes = self.get_nodes(i..end);\n            let batches = (i..end)\n                .into_iter()\n                .enumerate()\n                .map(|(chunk_idx, j)| ((j).try_into().unwrap(), nodes[chunk_idx]))\n                .collect::\u003cVec\u003c(i32, HashOut\u003cF\u003e)\u003e\u003e();\n            db.add_batch_gmst_nodes(batches);\n            i += chunk_size;\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::GlobalMst;\n    use crate::{\n        account::gen_accounts_with_random_data,\n        merkle_sum_tree::MerkleSumTree,\n        recursive_prover::prover::hash_n_subhashes,\n        types::{D, F},\n        util::pad_to_multiple_of,\n    };\n    use plonky2::hash::hash_types::HashOut;\n    use zk_por_tracing::{init_tracing, TraceConfig};\n\n    #[test]\n    fn test_index() {\n        let gmst = GlobalMst::new(super::GlobalConfig {\n            num_of_tokens: 22,\n            num_of_batches: 6,\n            batch_size: 8,\n            recursion_branchout_num: 4,\n        });\n        let total_len = gmst.get_tree_length();\n\n        /*\n        L2:                                 96\n        L1:         92            93                 94                95\n        L0:     84,    85,    86,     87,        88,      89,       90e,  91e\n                72-73, 74-75,  76-77,  78-79,    80-81,   82-83,\n                48-51, 52-55,  56-59,   60-63,   64-67,   68-71\n                0 - 7, 8 - 15, 16 - 23, 24 - 31, 32 - 39, 40 - 47\n        */\n        assert_eq!(total_len, 97);\n        assert_eq!(gmst.top_recursion_level, 2);\n\n        assert_eq!(GlobalMst::get_batch_tree_global_index(\u0026gmst.cfg, 0, 1), 1);\n        assert_eq!(GlobalMst::get_batch_tree_global_index(\u0026gmst.cfg, 0, 14), 84);\n        assert_eq!(GlobalMst::get_batch_tree_global_index(\u0026gmst.cfg, 1, 1), 9);\n        assert_eq!(GlobalMst::get_batch_tree_global_index(\u0026gmst.cfg, 1, 14), 85);\n        assert_eq!(GlobalMst::get_batch_tree_global_index(\u0026gmst.cfg, 5, 7), 47);\n        assert_eq!(GlobalMst::get_batch_tree_global_index(\u0026gmst.cfg, 5, 14), 89);\n\n        assert_eq!(GlobalMst::get_recursive_global_index(\u0026gmst.cfg, 0, 7), 91);\n        assert_eq!(GlobalMst::get_recursive_global_index(\u0026gmst.cfg, 0, 1), 85);\n        assert_eq!(GlobalMst::get_recursive_global_index(\u0026gmst.cfg, 1, 0), 92);\n        assert_eq!(GlobalMst::get_recursive_global_index(\u0026gmst.cfg, 1, 1), 93);\n        assert_eq!(GlobalMst::get_recursive_global_index(\u0026gmst.cfg, 1, 2), 94);\n        assert_eq!(GlobalMst::get_recursive_global_index(\u0026gmst.cfg, 1, 3), 95);\n        assert_eq!(GlobalMst::get_recursive_global_index(\u0026gmst.cfg, 2, 0), 96);\n    }\n\n    #[test]\n    fn test_integrity() {\n        let cfg = TraceConfig {\n            prefix: \"zkpor\".to_string(),\n            dir: \"logs\".to_string(),\n            level: tracing::Level::DEBUG,\n            console: true,\n            flame: false,\n        };\n\n        {\n            init_tracing(cfg)\n        };\n\n        let mut gmst = GlobalMst::new(super::GlobalConfig {\n            num_of_tokens: 22,\n            num_of_batches: 6,\n            batch_size: 8,\n            recursion_branchout_num: 4,\n        });\n\n        assert!(!gmst.is_integral());\n        let batch_num = gmst.cfg.num_of_batches;\n        let batch_size = gmst.cfg.batch_size;\n        let branchout_num = gmst.cfg.recursion_branchout_num;\n\n        for batch_idx in 0..batch_num {\n            let accounts = gen_accounts_with_random_data(batch_size, 1);\n            let mst = MerkleSumTree::new_tree_from_accounts(\u0026accounts);\n\n            for i in 0..batch_size * 2 - 1 {\n                gmst.set_batch_hash(batch_idx, i, mst.merkle_sum_tree[i].hash);\n            }\n        }\n\n        let mut last_level_node_num = pad_to_multiple_of(batch_num, branchout_num);\n        for level in 1..=gmst.top_recursion_level {\n            let this_level_node_count = last_level_node_num / branchout_num;\n            for inner_idx in 0..this_level_node_count {\n                let children_hashes = (0..branchout_num)\n                    .map(|i| {\n                        let child_global_idx = GlobalMst::get_recursive_global_index(\n                            \u0026gmst.cfg,\n                            level - 1,\n                            inner_idx * branchout_num + i,\n                        );\n                        gmst.inner[child_global_idx]\n                    })\n                    .collect::\u003cVec\u003cHashOut\u003cF\u003e\u003e\u003e();\n\n                let expected_parent_hash = hash_n_subhashes::\u003cF, D\u003e(\u0026children_hashes);\n                gmst.set_recursive_hash(level, inner_idx, expected_parent_hash);\n            }\n\n            last_level_node_num = pad_to_multiple_of(this_level_node_count, branchout_num);\n        }\n        assert!(gmst.is_integral());\n    }\n}\n","traces":[{"line":30,"address":[12874384,12874896],"length":1,"stats":{"Line":1}},{"line":31,"address":[8701814],"length":1,"stats":{"Line":1}},{"line":34,"address":[12874574],"length":1,"stats":{"Line":1}},{"line":35,"address":[12874632],"length":1,"stats":{"Line":1}},{"line":37,"address":[12874754,12874689],"length":1,"stats":{"Line":2}},{"line":38,"address":[8702154,8702196],"length":1,"stats":{"Line":1}},{"line":39,"address":[12874833,12874789],"length":1,"stats":{"Line":2}},{"line":40,"address":[12874865],"length":1,"stats":{"Line":1}},{"line":43,"address":[12874928],"length":1,"stats":{"Line":1}},{"line":44,"address":[12874933],"length":1,"stats":{"Line":1}},{"line":47,"address":[12874944],"length":1,"stats":{"Line":1}},{"line":48,"address":[12874953,12874981],"length":1,"stats":{"Line":1}},{"line":51,"address":[12875008],"length":1,"stats":{"Line":0}},{"line":52,"address":[12875026],"length":1,"stats":{"Line":0}},{"line":55,"address":[12875056],"length":1,"stats":{"Line":0}},{"line":56,"address":[12875061],"length":1,"stats":{"Line":0}},{"line":65,"address":[12875088],"length":1,"stats":{"Line":1}},{"line":70,"address":[8702510],"length":1,"stats":{"Line":1}},{"line":71,"address":[12875151],"length":1,"stats":{"Line":1}},{"line":72,"address":[12875180],"length":1,"stats":{"Line":1}},{"line":74,"address":[12875202,12875256],"length":1,"stats":{"Line":1}},{"line":76,"address":[8702715,8702611,8702657],"length":1,"stats":{"Line":2}},{"line":77,"address":[12875366,12875332,12875458],"length":1,"stats":{"Line":2}},{"line":79,"address":[12875536,12875484,12875450],"length":1,"stats":{"Line":2}},{"line":80,"address":[12875562,12875590,12875521],"length":1,"stats":{"Line":2}},{"line":82,"address":[12875611,12875570,12875831],"length":1,"stats":{"Line":2}},{"line":86,"address":[12875816,12875857,12875907],"length":1,"stats":{"Line":2}},{"line":93,"address":[8703312],"length":1,"stats":{"Line":1}},{"line":98,"address":[12875991,12876137],"length":1,"stats":{"Line":1}},{"line":99,"address":[12876095],"length":1,"stats":{"Line":1}},{"line":100,"address":[12876112],"length":1,"stats":{"Line":1}},{"line":101,"address":[12876129],"length":1,"stats":{"Line":1}},{"line":103,"address":[12876169],"length":1,"stats":{"Line":1}},{"line":105,"address":[12876423,12876447,12876233],"length":1,"stats":{"Line":2}},{"line":106,"address":[8703807],"length":1,"stats":{"Line":1}},{"line":108,"address":[12876210,12876276],"length":1,"stats":{"Line":2}},{"line":113,"address":[8703889,8703996,8703848,8703558],"length":1,"stats":{"Line":4}},{"line":114,"address":[12876502],"length":1,"stats":{"Line":1}},{"line":116,"address":[12876623,12876564,12876521],"length":1,"stats":{"Line":2}},{"line":119,"address":[12876649,12876678,12876534],"length":1,"stats":{"Line":2}},{"line":120,"address":[12876657,12876704],"length":1,"stats":{"Line":2}},{"line":122,"address":[12876863,12876948],"length":1,"stats":{"Line":1}},{"line":124,"address":[12876938],"length":1,"stats":{"Line":1}},{"line":125,"address":[12877275,12876946,12876964],"length":1,"stats":{"Line":3}},{"line":126,"address":[12877097,12877011,12877175],"length":1,"stats":{"Line":2}},{"line":127,"address":[8704513],"length":1,"stats":{"Line":1}},{"line":128,"address":[12877121],"length":1,"stats":{"Line":1}},{"line":130,"address":[12877247,12877196,12877147],"length":1,"stats":{"Line":2}},{"line":132,"address":[12877204],"length":1,"stats":{"Line":1}},{"line":133,"address":[12877220,12877267,12877280],"length":1,"stats":{"Line":2}},{"line":136,"address":[12876983,12877071,12877050],"length":1,"stats":{"Line":2}},{"line":137,"address":[8704433],"length":1,"stats":{"Line":1}},{"line":142,"address":[12877296],"length":1,"stats":{"Line":1}},{"line":143,"address":[12877325],"length":1,"stats":{"Line":1}},{"line":144,"address":[12877348],"length":1,"stats":{"Line":1}},{"line":147,"address":[8704784],"length":1,"stats":{"Line":0}},{"line":148,"address":[8705559,8705602,8705774,8705417,8705269,8705486,8704938],"length":1,"stats":{"Line":0}},{"line":149,"address":[8705517,8706054],"length":1,"stats":{"Line":0}},{"line":151,"address":[8706087],"length":1,"stats":{"Line":0}},{"line":153,"address":[8706261,8706099],"length":1,"stats":{"Line":0}},{"line":155,"address":[8706198],"length":1,"stats":{"Line":0}},{"line":159,"address":[8706288],"length":1,"stats":{"Line":1}},{"line":160,"address":[12879545,12879618,12879066,12879397,12880170,12879763,12879806],"length":1,"stats":{"Line":7}},{"line":164,"address":[8707025],"length":1,"stats":{"Line":1}},{"line":165,"address":[12879685],"length":1,"stats":{"Line":1}},{"line":168,"address":[12888453,12880512,12884932],"length":1,"stats":{"Line":1}},{"line":170,"address":[8707895],"length":1,"stats":{"Line":1}},{"line":171,"address":[8707944],"length":1,"stats":{"Line":1}},{"line":172,"address":[12880858,12880608,12880701],"length":1,"stats":{"Line":3}},{"line":173,"address":[12880874],"length":1,"stats":{"Line":1}},{"line":174,"address":[8708246,8712225,8712320],"length":1,"stats":{"Line":2}},{"line":175,"address":[12885017,12885081],"length":1,"stats":{"Line":2}},{"line":176,"address":[12885203,12885335],"length":1,"stats":{"Line":1}},{"line":177,"address":[12885306,12885364,12885519],"length":1,"stats":{"Line":2}},{"line":179,"address":[8712828,8712756],"length":1,"stats":{"Line":2}},{"line":182,"address":[12885564],"length":1,"stats":{"Line":1}},{"line":187,"address":[8712895],"length":1,"stats":{"Line":1}},{"line":192,"address":[12885682],"length":1,"stats":{"Line":1}},{"line":193,"address":[8712999],"length":1,"stats":{"Line":1}},{"line":196,"address":[12885796],"length":1,"stats":{"Line":1}},{"line":197,"address":[8713098],"length":1,"stats":{"Line":1}},{"line":199,"address":[8713167],"length":1,"stats":{"Line":1}},{"line":200,"address":[8715311,8714166,8713371,8715195,8713766,8714230,8714065,8713953],"length":1,"stats":{"Line":7}},{"line":201,"address":[8714121],"length":1,"stats":{"Line":1}},{"line":205,"address":[12880811],"length":1,"stats":{"Line":1}},{"line":206,"address":[12880940,12880823],"length":1,"stats":{"Line":2}},{"line":207,"address":[8708519,8708300],"length":1,"stats":{"Line":2}},{"line":208,"address":[8708535,8708822,8708889],"length":1,"stats":{"Line":2}},{"line":209,"address":[8708925,8708862],"length":1,"stats":{"Line":2}},{"line":210,"address":[8709039],"length":1,"stats":{"Line":1}},{"line":211,"address":[12888480,12888499],"length":1,"stats":{"Line":2}},{"line":213,"address":[12881777,12881868],"length":1,"stats":{"Line":2}},{"line":214,"address":[12881876,12882018],"length":1,"stats":{"Line":2}},{"line":216,"address":[8715824,8715843,8709310],"length":1,"stats":{"Line":3}},{"line":218,"address":[8715856,8715962],"length":1,"stats":{"Line":1}},{"line":219,"address":[12888699],"length":1,"stats":{"Line":1}},{"line":224,"address":[12882167,12882072],"length":1,"stats":{"Line":2}},{"line":226,"address":[12888752,12888778],"length":1,"stats":{"Line":2}},{"line":229,"address":[12882264],"length":1,"stats":{"Line":1}},{"line":231,"address":[12882343],"length":1,"stats":{"Line":1}},{"line":232,"address":[12883646,12884398,12883108,12883307,12884526,12882692,12883570,12883437],"length":1,"stats":{"Line":0}},{"line":233,"address":[12883502],"length":1,"stats":{"Line":0}},{"line":235,"address":[12882617,12882432],"length":1,"stats":{"Line":2}},{"line":238,"address":[12881231,12881137],"length":1,"stats":{"Line":2}},{"line":240,"address":[12881239],"length":1,"stats":{"Line":1}},{"line":242,"address":[12888864,12888874,12881284],"length":1,"stats":{"Line":3}},{"line":245,"address":[8716112],"length":1,"stats":{"Line":0}},{"line":246,"address":[12888929],"length":1,"stats":{"Line":0}},{"line":247,"address":[12889727,12889900,12889607,12889538,12889059,12889390,12889684],"length":1,"stats":{"Line":0}},{"line":248,"address":[12889633],"length":1,"stats":{"Line":0}},{"line":249,"address":[8716860],"length":1,"stats":{"Line":0}},{"line":250,"address":[12890180,12889657,12890545],"length":1,"stats":{"Line":0}},{"line":251,"address":[12890203,12890503],"length":1,"stats":{"Line":0}},{"line":252,"address":[12890310],"length":1,"stats":{"Line":0}},{"line":253,"address":[12890357],"length":1,"stats":{"Line":0}},{"line":256,"address":[12890631,12890576,12890785],"length":1,"stats":{"Line":0}},{"line":258,"address":[12890454],"length":1,"stats":{"Line":0}},{"line":259,"address":[12890472,12890550,12890537],"length":1,"stats":{"Line":0}}],"covered":94,"coverable":118},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","lib.rs"],"content":"use plonky2::{hash::hash_types::HashOut, plonk::proof::ProofWithPublicInputs};\nuse serde::*;\nuse types::{C, D, F};\n\npub mod account;\npub mod circuit_config;\npub mod circuit_registry;\npub mod circuit_utils;\npub mod config;\npub mod database;\npub mod e2e;\npub mod error;\npub mod global;\npub mod merkle_proof;\npub mod merkle_sum_prover;\npub mod merkle_sum_tree;\npub mod parser;\npub mod recursive_prover;\npub mod types;\npub mod util;\n\n#[derive(Serialize, Deserialize)]\npub struct General {\n    pub round_num: usize,\n    pub batch_num: usize,\n    pub recursion_branchout_num: usize,\n    pub batch_size: usize,\n    pub token_num: usize,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct Proof {\n    pub general: General,\n    pub root_vd_digest: HashOut\u003cF\u003e,\n    pub proof: ProofWithPublicInputs\u003cF, C, D\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","main.rs"],"content":"use tracing::{debug, Level};\nuse zk_por_tracing::{init_tracing, TraceConfig};\n\npub fn main() {\n    let cfg = TraceConfig {\n        prefix: \"zkpor\".to_string(),\n        dir: \"logs\".to_string(),\n        level: Level::DEBUG,\n        console: true,\n        flame: false,\n    };\n    let guard = init_tracing(cfg);\n    debug!(\"tracing works\");\n    drop(guard)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","merkle_proof.rs"],"content":"use itertools::Itertools;\nuse plonky2::{\n    hash::{hash_types::HashOut, poseidon::PoseidonHash},\n    plonk::config::Hasher,\n};\nuse rayon::iter::{IntoParallelRefIterator, ParallelIterator};\nuse serde::{Deserialize, Serialize};\n\nuse crate::{\n    account::Account,\n    database::{PoRDB, UserId},\n    error::PoRError,\n    global::{GlobalConfig, GlobalMst},\n    merkle_sum_prover::utils::hash_2_subhashes,\n    types::{D, F},\n};\n\nuse std::sync::Arc;\n\n/// We use this wrapper struct for the left and right indexes of our recursive siblings. This is needed so a user knows the position of\n/// their own hash when hashing.\n#[derive(Debug, Clone, PartialEq)]\npub struct RecursiveIndex {\n    left_indexes: Vec\u003cusize\u003e,\n    right_indexes: Vec\u003cusize\u003e,\n}\n\n/// Indexes for a given users merkle proof of inclusion siblings in the Global Merkle Sum Tree\n#[derive(Debug, Clone, PartialEq)]\npub struct MerkleProofIndex {\n    pub sum_tree_siblings: Vec\u003cusize\u003e,\n    pub recursive_tree_siblings: Vec\u003cRecursiveIndex\u003e,\n}\n\nimpl MerkleProofIndex {\n    pub fn new_from_user_index(user_index: usize, global_mst: \u0026GlobalConfig) -\u003e MerkleProofIndex {\n        let sum_tree_siblings = get_mst_siblings_index(user_index, global_mst);\n        let recursive_tree_siblings = get_recursive_siblings_index(user_index, global_mst);\n\n        MerkleProofIndex { sum_tree_siblings, recursive_tree_siblings }\n    }\n}\n\n/// Get the siblings index for the merkle proof of inclusion given a leaf index of a binary merkle sum tree.\n/// We get the parent index of a leaf using the formula: parent = index / 2 + num_leaves\npub fn get_mst_siblings_index(global_leaf_index: usize, cfg: \u0026GlobalConfig) -\u003e Vec\u003cusize\u003e {\n    // Make sure our global index is within the number of leaves\n    assert!(global_leaf_index \u003c GlobalMst::get_num_of_leaves(cfg));\n\n    let batch_id = global_leaf_index / cfg.batch_size;\n    let mut siblings = Vec::new();\n\n    // This is the index in the local mst tree\n    let mut local_index = global_leaf_index % cfg.batch_size;\n\n    while local_index \u003c (cfg.batch_size * 2 - 2) {\n        if local_index % 2 == 1 {\n            let sibling_index = local_index - 1;\n            siblings.push(sibling_index);\n        } else {\n            let sibling_index = local_index + 1;\n            siblings.push(sibling_index);\n        }\n\n        let local_parent_index = local_index / 2 + cfg.batch_size;\n        local_index = local_parent_index;\n    }\n\n    siblings.par_iter().map(|x| GlobalMst::get_batch_tree_global_index(cfg, batch_id, *x)).collect()\n}\n\n/// Gets the recursive siblings indexes (recursive tree is n-ary tree) as a Vec of vecs, each inner vec is one layer of siblings.\npub fn get_recursive_siblings_index(\n    global_index: usize,\n    cfg: \u0026GlobalConfig,\n) -\u003e Vec\u003cRecursiveIndex\u003e {\n    // Make sure our global index is within the number of leaves\n    assert!(global_index \u003c GlobalMst::get_num_of_leaves(cfg));\n\n    let mut siblings = Vec::new();\n    let local_mst_root_index = cfg.batch_size * 2 - 2;\n    let mst_batch_idx = global_index / cfg.batch_size;\n    let this_mst_root_idx =\n        GlobalMst::get_batch_tree_global_index(cfg, mst_batch_idx, local_mst_root_index);\n\n    let first_mst_root_idx = GlobalMst::get_batch_tree_global_index(cfg, 0, local_mst_root_index);\n    assert!(this_mst_root_idx \u003e= first_mst_root_idx);\n\n    let this_mst_root_offset = this_mst_root_idx - first_mst_root_idx;\n    let mut recursive_idx = this_mst_root_offset / cfg.recursion_branchout_num;\n    let mut recursive_offset = this_mst_root_offset % cfg.recursion_branchout_num;\n\n    let layers = (cfg.num_of_batches.next_power_of_two() as f64)\n        .log(cfg.recursion_branchout_num as f64)\n        .ceil() as usize;\n\n    for i in 0..layers {\n        let mut left_layer = Vec::new();\n        let mut right_layer = Vec::new();\n        if i == 0 {\n            for j in 0..cfg.recursion_branchout_num {\n                if j \u003c recursive_offset {\n                    let index =\n                        first_mst_root_idx + (cfg.recursion_branchout_num * recursive_idx) + j;\n                    left_layer.push(index);\n                }\n\n                if j \u003e recursive_offset {\n                    let index =\n                        first_mst_root_idx + (cfg.recursion_branchout_num * recursive_idx) + j;\n                    right_layer.push(index);\n                }\n            }\n        } else {\n            for j in 0..cfg.recursion_branchout_num {\n                if j \u003c recursive_offset {\n                    let index = GlobalMst::get_recursive_global_index(\n                        cfg,\n                        i,\n                        recursive_idx * cfg.recursion_branchout_num + j,\n                    );\n                    left_layer.push(index);\n                }\n\n                if j \u003e recursive_offset {\n                    let index = GlobalMst::get_recursive_global_index(\n                        cfg,\n                        i,\n                        recursive_idx * cfg.recursion_branchout_num + j,\n                    );\n                    right_layer.push(index);\n                }\n            }\n        }\n\n        siblings.push(RecursiveIndex { left_indexes: left_layer, right_indexes: right_layer });\n\n        recursive_offset = recursive_idx % cfg.recursion_branchout_num;\n        recursive_idx = recursive_idx / cfg.recursion_branchout_num;\n    }\n\n    siblings\n}\n\n/// We use this wrapper struct for the left and right hashes of our recursive siblings. This is needed so a user knows the position of\n/// their own hash when hashing.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct RecursiveHashes {\n    left_hashes: Vec\u003cHashOut\u003cF\u003e\u003e,\n    right_hashes: Vec\u003cHashOut\u003cF\u003e\u003e,\n}\n\nimpl RecursiveHashes {\n    pub fn new_from_index(indexes: \u0026RecursiveIndex, db: Arc\u003cdyn PoRDB\u003e) -\u003e Self {\n        let left_hashes = indexes\n            .left_indexes\n            .iter()\n            .map(|y| db.get_gmst_node_hash(*y as i32).unwrap())\n            .collect_vec();\n        let right_hashes = indexes\n            .right_indexes\n            .iter()\n            .map(|y| db.get_gmst_node_hash(*y as i32).unwrap())\n            .collect_vec();\n        RecursiveHashes { left_hashes, right_hashes }\n    }\n\n    /// Calculated Hash = Left hashes || own hash || Right hashes\n    pub fn get_calculated_hash(self, own_hash: HashOut\u003cF\u003e) -\u003e HashOut\u003cF\u003e {\n        let mut hash_inputs = self.left_hashes;\n        hash_inputs.push(own_hash);\n        hash_inputs.extend(self.right_hashes);\n\n        let inputs: Vec\u003cF\u003e = hash_inputs.iter().map(|x| x.elements).flatten().collect();\n\n        PoseidonHash::hash_no_pad(inputs.as_slice())\n    }\n}\n\n/// Hashes for a given users merkle proof of inclusion siblings in the Global Merkle Sum Tree, also includes account data as it is needed for the verification\n/// of the merkle proof (needed to calculate own hash)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MerkleProof {\n    pub account: Account,\n    pub index: usize,\n    pub sum_tree_siblings: Vec\u003cHashOut\u003cF\u003e\u003e,\n    pub recursive_tree_siblings: Vec\u003cRecursiveHashes\u003e,\n}\n\nimpl MerkleProof {\n    pub fn new_from_account(\n        account: \u0026Account,\n        db: Arc\u003cdyn PoRDB\u003e,\n        cfg: \u0026GlobalConfig,\n    ) -\u003e Result\u003cMerkleProof, PoRError\u003e {\n        let user_id_res = UserId::from_hex_string(account.id.clone());\n        if user_id_res.is_err() {\n            return Err(user_id_res.unwrap_err());\n        }\n\n        let user_id = user_id_res.unwrap();\n\n        let user_index = db.get_user_index(user_id.clone());\n        if user_index.is_none() {\n            tracing::error!(\"User with id: {:?} does not exist\", user_id.to_string());\n            return Err(PoRError::InvalidParameter(user_id.to_string()));\n        }\n\n        let merkle_proof_indexes =\n            MerkleProofIndex::new_from_user_index(user_index.unwrap() as usize, cfg);\n        let merkle_proof = get_merkle_proof_hashes_from_indexes(\n            account,\n            \u0026merkle_proof_indexes,\n            user_index.unwrap() as usize,\n            db,\n        );\n        Ok(merkle_proof)\n    }\n\n    pub fn verify_merkle_proof(\u0026self, gmst_root: HashOut\u003cF\u003e) -\u003e Result\u003c(), PoRError\u003e {\n        let account_hash = self.account.get_hash();\n\n        let mut index = self.index;\n\n        let calculated_mst_hash = self.sum_tree_siblings.iter().fold(account_hash, |acc, x| {\n            if index % 2 == 0 {\n                index /= 2;\n                hash_2_subhashes::\u003cF, D\u003e(\u0026acc, x)\n            } else {\n                index /= 2;\n                hash_2_subhashes::\u003cF, D\u003e(x, \u0026acc)\n            }\n        });\n\n        let calculated_hash = self\n            .recursive_tree_siblings\n            .iter()\n            .fold(calculated_mst_hash, |acc, x| x.clone().get_calculated_hash(acc));\n\n        if calculated_hash == gmst_root {\n            Ok(())\n        } else {\n            Err(PoRError::InvalidMerkleProof(self.account.id.clone()))\n        }\n    }\n}\n\n/// Given the indexes for the MST siblings, get the hashes from the database for the merkle proof of inclusion.\npub fn get_merkle_proof_hashes_from_indexes(\n    account: \u0026Account,\n    indexes: \u0026MerkleProofIndex,\n    user_index: usize,\n    db: Arc\u003cdyn PoRDB\u003e,\n) -\u003e MerkleProof {\n    let mst_hashes: Vec\u003cHashOut\u003cF\u003e\u003e = indexes\n        .sum_tree_siblings\n        .iter()\n        .map(|x| db.get_gmst_node_hash(*x as i32).unwrap())\n        .collect();\n\n    let recursive_hashes: Vec\u003cRecursiveHashes\u003e = indexes\n        .recursive_tree_siblings\n        .iter()\n        .map(|x| RecursiveHashes::new_from_index(x, db.clone()))\n        .collect();\n\n    MerkleProof {\n        account: account.clone(),\n        sum_tree_siblings: mst_hashes,\n        recursive_tree_siblings: recursive_hashes,\n        index: user_index,\n    }\n}\n\n#[cfg(test)]\npub mod test {\n    use itertools::Itertools;\n    use plonky2::hash::hash_types::HashOut;\n\n    use crate::{\n        account::Account,\n        global::{GlobalConfig, GlobalMst},\n        merkle_proof::{get_recursive_siblings_index, MerkleProofIndex, RecursiveIndex},\n        types::F,\n    };\n    use plonky2_field::types::Field;\n\n    use super::{get_mst_siblings_index, MerkleProof, RecursiveHashes};\n\n    #[test]\n    pub fn test_get_siblings_index() {\n        let gmst = GlobalMst::new(GlobalConfig {\n            num_of_tokens: 100,\n            num_of_batches: 4,\n            batch_size: 8,\n            recursion_branchout_num: 4,\n        });\n\n        let global_index = 0;\n\n        let siblings = get_mst_siblings_index(global_index, \u0026gmst.cfg);\n        assert_eq!(siblings, vec![1, 33, 49]);\n\n        let gmst = GlobalMst::new(GlobalConfig {\n            num_of_tokens: 100,\n            num_of_batches: 8,\n            batch_size: 8,\n            recursion_branchout_num: 4,\n        });\n\n        let global_index = 0;\n\n        let siblings = get_mst_siblings_index(global_index, \u0026gmst.cfg);\n        assert_eq!(siblings, vec![1, 65, 97]);\n\n        let gmst = GlobalMst::new(GlobalConfig {\n            num_of_tokens: 100,\n            num_of_batches: 6,\n            batch_size: 8,\n            recursion_branchout_num: 4,\n        });\n\n        let global_index = 0;\n\n        let siblings = get_mst_siblings_index(global_index, \u0026gmst.cfg);\n        assert_eq!(siblings, vec![1, 49, 73]);\n    }\n\n    #[test]\n    pub fn test_get_recursive_siblings_index() {\n        let gmst = GlobalMst::new(GlobalConfig {\n            num_of_tokens: 100,\n            num_of_batches: 15,\n            batch_size: 4,\n            recursion_branchout_num: 4,\n        });\n\n        let global_index = 0;\n\n        let siblings = get_recursive_siblings_index(global_index, \u0026gmst.cfg);\n\n        assert_eq!(\n            siblings,\n            vec![\n                RecursiveIndex { left_indexes: vec![], right_indexes: vec![91, 92, 93] },\n                RecursiveIndex { left_indexes: vec![], right_indexes: vec![107, 108, 109] }\n            ]\n        );\n\n        let gmst = GlobalMst::new(GlobalConfig {\n            num_of_tokens: 100,\n            num_of_batches: 30,\n            batch_size: 8,\n            recursion_branchout_num: 4,\n        });\n\n        let global_index = 163;\n\n        let siblings = get_recursive_siblings_index(global_index, \u0026gmst.cfg);\n        assert_eq!(\n            siblings,\n            vec![\n                RecursiveIndex { left_indexes: vec![], right_indexes: vec![441, 442, 443] },\n                RecursiveIndex { left_indexes: vec![456], right_indexes: vec![458, 459] },\n                RecursiveIndex { left_indexes: vec![460], right_indexes: vec![462, 463] }\n            ]\n        );\n\n        let gmst = GlobalMst::new(GlobalConfig {\n            num_of_tokens: 10,\n            num_of_batches: 6,\n            batch_size: 4,\n            recursion_branchout_num: 4,\n        });\n\n        let global_index = 20;\n\n        let siblings = get_recursive_siblings_index(global_index, \u0026gmst.cfg);\n        assert_eq!(\n            siblings,\n            vec![\n                RecursiveIndex { left_indexes: vec![40], right_indexes: vec![42, 43] },\n                RecursiveIndex { left_indexes: vec![44], right_indexes: vec![46, 47] },\n            ]\n        );\n    }\n\n    #[test]\n    pub fn test_get_new_merkle_index_from_user_index() {\n        let gmst = GlobalMst::new(GlobalConfig {\n            num_of_tokens: 100,\n            num_of_batches: 15,\n            batch_size: 4,\n            recursion_branchout_num: 4,\n        });\n\n        let global_index = 0;\n\n        let merkle_proof_indexes = MerkleProofIndex::new_from_user_index(global_index, \u0026gmst.cfg);\n\n        assert_eq!(\n            merkle_proof_indexes,\n            MerkleProofIndex {\n                sum_tree_siblings: vec![1, 61],\n                recursive_tree_siblings: vec![\n                    RecursiveIndex { left_indexes: vec![], right_indexes: vec![91, 92, 93] },\n                    RecursiveIndex { left_indexes: vec![], right_indexes: vec![107, 108, 109] }\n                ],\n            }\n        );\n    }\n\n    #[test]\n    pub fn test_verify_merkle_proof() {\n        let _gmst = GlobalMst::new(GlobalConfig {\n            num_of_tokens: 3,\n            num_of_batches: 4,\n            batch_size: 2,\n            recursion_branchout_num: 4,\n        });\n\n        let equity = vec![3, 3, 3].iter().map(|x| F::from_canonical_u32(*x)).collect_vec();\n        let debt = vec![1, 1, 1].iter().map(|x| F::from_canonical_u32(*x)).collect_vec();\n\n        let sum_tree_siblings = vec![HashOut::from_vec(\n            vec![\n                7609058119952049295,\n                8895839458156070742,\n                1052773619972611009,\n                6038312163525827182,\n            ]\n            .iter()\n            .map(|x| F::from_canonical_u64(*x))\n            .collect::\u003cVec\u003cF\u003e\u003e(),\n        )];\n\n        let recursive_tree_siblings = vec![RecursiveHashes {\n            left_hashes: vec![],\n            right_hashes: vec![\n                HashOut::from_vec(\n                    vec![\n                        15026394135096265436,\n                        13313300609834454638,\n                        10151802728958521275,\n                        6200471959130767555,\n                    ]\n                    .iter()\n                    .map(|x| F::from_canonical_u64(*x))\n                    .collect::\u003cVec\u003cF\u003e\u003e(),\n                ),\n                HashOut::from_vec(\n                    vec![\n                        2010803994799996791,\n                        568450490466247075,\n                        18209684900543488748,\n                        7678193912819861368,\n                    ]\n                    .iter()\n                    .map(|x| F::from_canonical_u64(*x))\n                    .collect::\u003cVec\u003cF\u003e\u003e(),\n                ),\n                HashOut::from_vec(\n                    vec![\n                        13089029781628355232,\n                        10704046654659337561,\n                        15794212269117984095,\n                        15948192230150472783,\n                    ]\n                    .iter()\n                    .map(|x| F::from_canonical_u64(*x))\n                    .collect::\u003cVec\u003cF\u003e\u003e(),\n                ),\n            ],\n        }];\n\n        let account = Account {\n            id: \"320b5ea99e653bc2b593db4130d10a4efd3a0b4cc2e1a6672b678d71dfbd33ad\".to_string(),\n            equity: equity.clone(),\n            debt: debt.clone(),\n        };\n\n        let merkle_proof =\n            MerkleProof { account, sum_tree_siblings, recursive_tree_siblings, index: 0 };\n\n        let root = HashOut::from_vec(\n            vec![\n                10628303359772907103,\n                7478459528589413745,\n                12007196562137971174,\n                2652030368197917032,\n            ]\n            .iter()\n            .map(|x| F::from_canonical_u64(*x))\n            .collect::\u003cVec\u003cF\u003e\u003e(),\n        );\n\n        let res = merkle_proof.verify_merkle_proof(root);\n\n        res.unwrap();\n    }\n\n    // THIS IS THE TEST DATA FOR VERIFY\n    // #[test]\n    // pub fn poseidon_hash() {\n    //     let equity = vec![3,3,3,].iter().map(|x| F::from_canonical_u32(*x)).collect_vec();\n    //     let debt = vec![1,1,1,].iter().map(|x| F::from_canonical_u32(*x)).collect_vec();\n\n    //     let accounts = vec![\n    //         Account{\n    //             id: \"320b5ea99e653bc2b593db4130d10a4efd3a0b4cc2e1a6672b678d71dfbd33ad\".to_string(),\n    //             equity: equity.clone(),\n    //             debt: debt.clone(),\n    //         },\n    //         Account{\n    //             id: \"320b5ea99e653bc2b593db4130d10a4efd3a0b4cc2e1a6672b678d71dfbd33ac\".to_string(),\n    //             equity: equity.clone(),\n    //             debt: debt.clone(),\n    //         },\n    //         Account{\n    //             id: \"320b5ea99e653bc2b593db4130d10a4efd3a0b4cc2e1a6672b678d71dfbd33ab\".to_string(),\n    //             equity: equity.clone(),\n    //             debt: debt.clone(),\n    //         },\n    //         Account{\n    //             id: \"320b5ea99e653bc2b593db4130d10a4efd3a0b4cc2e1a6672b678d71dfbd33aa\".to_string(),\n    //             equity: equity.clone(),\n    //             debt: debt.clone(),\n    //         },\n    //         Account{\n    //             id: \"320b5ea99e653bc2b593db4130d10a4efd3a0b4cc2e1a6672b678d71dfbd33a1\".to_string(),\n    //             equity: equity.clone(),\n    //             debt: debt.clone(),\n    //         },\n    //         Account{\n    //             id: \"320b5ea99e653bc2b593db4130d10a4efd3a0b4cc2e1a6672b678d71dfbd33a2\".to_string(),\n    //             equity: equity.clone(),\n    //             debt: debt.clone(),\n    //         },\n    //         Account{\n    //             id: \"320b5ea99e653bc2b593db4130d10a4efd3a0b4cc2e1a6672b678d71dfbd33a3\".to_string(),\n    //             equity: equity.clone(),\n    //             debt: debt.clone(),\n    //         },\n    //         Account{\n    //             id: \"320b5ea99e653bc2b593db4130d10a4efd3a0b4cc2e1a6672b678d71dfbd33a4\".to_string(),\n    //             equity: equity.clone(),\n    //             debt: debt.clone(),\n    //         }\n    //     ];\n\n    //     let msts: Vec\u003cMerkleSumTree\u003e = accounts\n    //         .chunks(2)\n    //         .map(|account_batch| MerkleSumTree::new_tree_from_accounts(\u0026account_batch.to_vec()))\n    //         .collect();\n\n    //     let mst_hashes = msts.iter().map(|x| x.merkle_sum_tree.iter().map(|y| y.hash).collect_vec()).collect_vec();\n    //     println!(\"msts:{:?}\", mst_hashes);\n    //     let inputs = vec![\n    //         HashOut::from_vec(\n    //             vec![\n    //                 8699257539652901730,\n    //                 12847577670763395377,\n    //                 14540605839220144846,\n    //                 1921995570040415498,\n    //             ]\n    //             .iter()\n    //             .map(|x| F::from_canonical_u64(*x))\n    //             .collect::\u003cVec\u003cF\u003e\u003e(),\n    //         ),\n    //         HashOut::from_vec(\n    //             vec![\n    //                 15026394135096265436,\n    //                 13313300609834454638,\n    //                 10151802728958521275,\n    //                 6200471959130767555,\n    //             ]\n    //             .iter()\n    //             .map(|x| F::from_canonical_u64(*x))\n    //             .collect::\u003cVec\u003cF\u003e\u003e(),\n    //         ),\n    //         HashOut::from_vec(\n    //             vec![\n    //                 2010803994799996791,\n    //                 568450490466247075,\n    //                 18209684900543488748,\n    //                 7678193912819861368,\n    //             ]\n    //             .iter()\n    //             .map(|x| F::from_canonical_u64(*x))\n    //             .collect::\u003cVec\u003cF\u003e\u003e(),\n    //         ),\n    //         HashOut::from_vec(\n    //             vec![\n    //                 13089029781628355232,\n    //                 10704046654659337561,\n    //                 15794212269117984095,\n    //                 15948192230150472783,\n    //             ]\n    //             .iter()\n    //             .map(|x| F::from_canonical_u64(*x))\n    //             .collect::\u003cVec\u003cF\u003e\u003e(),\n    //         ),\n    //     ];\n\n    //     let hash = PoseidonHash::hash_no_pad(\n    //         inputs.iter().map(|x| x.elements).flatten().collect_vec().as_slice(),\n    //     );\n    //     println!(\"Hash: {:?}\", hash);\n    // }\n}\n","traces":[{"line":36,"address":[12891158,12890944],"length":1,"stats":{"Line":1}},{"line":37,"address":[8718185],"length":1,"stats":{"Line":1}},{"line":38,"address":[12891004],"length":1,"stats":{"Line":1}},{"line":46,"address":[12891184,12891996],"length":1,"stats":{"Line":1}},{"line":48,"address":[12891238],"length":1,"stats":{"Line":1}},{"line":50,"address":[12891367,12891290],"length":1,"stats":{"Line":1}},{"line":51,"address":[12891331],"length":1,"stats":{"Line":1}},{"line":54,"address":[12891411,12891350,12891396],"length":1,"stats":{"Line":2}},{"line":56,"address":[12891970,12891480,12891409],"length":1,"stats":{"Line":3}},{"line":57,"address":[12891622,12891735],"length":1,"stats":{"Line":2}},{"line":58,"address":[12891745,12891829,12891802],"length":1,"stats":{"Line":0}},{"line":59,"address":[12891850,12891810],"length":1,"stats":{"Line":0}},{"line":61,"address":[12891773,12891872,12891899],"length":1,"stats":{"Line":2}},{"line":62,"address":[12891880,12891920],"length":1,"stats":{"Line":2}},{"line":65,"address":[12891852,12891932,12891975],"length":1,"stats":{"Line":2}},{"line":66,"address":[8719149],"length":1,"stats":{"Line":1}},{"line":69,"address":[12891652,12891593,12892032,12892052],"length":1,"stats":{"Line":4}},{"line":73,"address":[12895040,12895009,12892080],"length":1,"stats":{"Line":1}},{"line":78,"address":[12892146],"length":1,"stats":{"Line":1}},{"line":80,"address":[8719392],"length":1,"stats":{"Line":1}},{"line":81,"address":[12892367,12892231,12892395],"length":1,"stats":{"Line":2}},{"line":82,"address":[12892375,12892437,12892480],"length":1,"stats":{"Line":2}},{"line":83,"address":[12892461,12892525],"length":1,"stats":{"Line":2}},{"line":86,"address":[12892533],"length":1,"stats":{"Line":1}},{"line":87,"address":[12892580],"length":1,"stats":{"Line":1}},{"line":89,"address":[8719804,8719867],"length":1,"stats":{"Line":1}},{"line":90,"address":[8719904,8719847,8719948],"length":1,"stats":{"Line":2}},{"line":91,"address":[12892815,12892758,12892855],"length":1,"stats":{"Line":2}},{"line":93,"address":[8720062,8720125,8720006],"length":1,"stats":{"Line":3}},{"line":94,"address":[12892931],"length":1,"stats":{"Line":1}},{"line":97,"address":[12893092,12894595,12893288],"length":1,"stats":{"Line":3}},{"line":98,"address":[12893312],"length":1,"stats":{"Line":1}},{"line":99,"address":[12893331],"length":1,"stats":{"Line":1}},{"line":100,"address":[12893407],"length":1,"stats":{"Line":1}},{"line":101,"address":[12893839,12893429,12893567],"length":1,"stats":{"Line":3}},{"line":102,"address":[12893863],"length":1,"stats":{"Line":1}},{"line":103,"address":[12893908,12894078],"length":1,"stats":{"Line":1}},{"line":105,"address":[8721225,8721265],"length":1,"stats":{"Line":2}},{"line":108,"address":[12893881],"length":1,"stats":{"Line":1}},{"line":109,"address":[8721436,8721278],"length":1,"stats":{"Line":1}},{"line":111,"address":[12894291,12894251],"length":1,"stats":{"Line":2}},{"line":115,"address":[12893472,12894312],"length":1,"stats":{"Line":2}},{"line":116,"address":[12894419],"length":1,"stats":{"Line":1}},{"line":120,"address":[8721920,8721819],"length":1,"stats":{"Line":1}},{"line":122,"address":[12894792],"length":1,"stats":{"Line":1}},{"line":125,"address":[8721792],"length":1,"stats":{"Line":1}},{"line":129,"address":[8721986,8722087],"length":1,"stats":{"Line":1}},{"line":131,"address":[12894963],"length":1,"stats":{"Line":1}},{"line":136,"address":[12893665],"length":1,"stats":{"Line":1}},{"line":138,"address":[12894446,12894535],"length":1,"stats":{"Line":1}},{"line":139,"address":[12894600,12894505,12894566],"length":1,"stats":{"Line":2}},{"line":142,"address":[12893245],"length":1,"stats":{"Line":1}},{"line":154,"address":[8722698,8722224],"length":1,"stats":{"Line":0}},{"line":155,"address":[12895104,12895176],"length":1,"stats":{"Line":0}},{"line":158,"address":[12895613,12895715,12895584],"length":1,"stats":{"Line":0}},{"line":160,"address":[12895336,12895260],"length":1,"stats":{"Line":0}},{"line":163,"address":[12895859,12895728,12895757],"length":1,"stats":{"Line":0}},{"line":169,"address":[12895872,12896401],"length":1,"stats":{"Line":1}},{"line":170,"address":[12895894],"length":1,"stats":{"Line":1}},{"line":171,"address":[12895927],"length":1,"stats":{"Line":1}},{"line":172,"address":[8723148],"length":1,"stats":{"Line":1}},{"line":174,"address":[12896076,12896461,12896448],"length":1,"stats":{"Line":3}},{"line":176,"address":[8723332,8723408],"length":1,"stats":{"Line":2}},{"line":191,"address":[12896496,12898081,12899720],"length":1,"stats":{"Line":0}},{"line":196,"address":[12896651,12896567],"length":1,"stats":{"Line":0}},{"line":197,"address":[8723869,8723778],"length":1,"stats":{"Line":0}},{"line":198,"address":[8724233,8726692],"length":1,"stats":{"Line":0}},{"line":201,"address":[12896799],"length":1,"stats":{"Line":0}},{"line":203,"address":[12897298],"length":1,"stats":{"Line":0}},{"line":204,"address":[8724518],"length":1,"stats":{"Line":0}},{"line":205,"address":[8725541,8725146,8725728,8726018,8725840,8725954,8726230],"length":1,"stats":{"Line":0}},{"line":206,"address":[8726549,8725912],"length":1,"stats":{"Line":0}},{"line":209,"address":[8724551,8724788],"length":1,"stats":{"Line":0}},{"line":214,"address":[12897743,12897880],"length":1,"stats":{"Line":0}},{"line":215,"address":[12897884],"length":1,"stats":{"Line":0}},{"line":217,"address":[8724999],"length":1,"stats":{"Line":0}},{"line":220,"address":[8726784],"length":1,"stats":{"Line":1}},{"line":221,"address":[12899795],"length":1,"stats":{"Line":1}},{"line":223,"address":[12899811],"length":1,"stats":{"Line":1}},{"line":225,"address":[12899820,12900192],"length":1,"stats":{"Line":2}},{"line":226,"address":[12900230],"length":1,"stats":{"Line":1}},{"line":227,"address":[12900265],"length":1,"stats":{"Line":1}},{"line":228,"address":[8727288],"length":1,"stats":{"Line":1}},{"line":230,"address":[12900307],"length":1,"stats":{"Line":0}},{"line":231,"address":[12900322],"length":1,"stats":{"Line":0}},{"line":235,"address":[12899926],"length":1,"stats":{"Line":1}},{"line":238,"address":[12900397,12900352],"length":1,"stats":{"Line":2}},{"line":240,"address":[12900027,12900150],"length":1,"stats":{"Line":1}},{"line":241,"address":[8727173],"length":1,"stats":{"Line":1}},{"line":243,"address":[12900047],"length":1,"stats":{"Line":0}},{"line":249,"address":[12900496,12901172],"length":1,"stats":{"Line":0}},{"line":255,"address":[12900570,12900642],"length":1,"stats":{"Line":0}},{"line":258,"address":[12901200,12901229,12901331],"length":1,"stats":{"Line":0}},{"line":261,"address":[12900726,12900802],"length":1,"stats":{"Line":0}},{"line":264,"address":[12901373,12901344],"length":1,"stats":{"Line":0}},{"line":268,"address":[12900895],"length":1,"stats":{"Line":0}}],"covered":67,"coverable":96},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","merkle_sum_prover","circuits","account_circuit.rs"],"content":"use plonky2::{\n    hash::{hash_types::HashOutTarget, poseidon::PoseidonHash},\n    iop::{\n        target::Target,\n        witness::{PartialWitness, WitnessWrite},\n    },\n    plonk::circuit_builder::CircuitBuilder,\n};\n\nuse crate::{\n    account::Account,\n    circuit_utils::assert_non_negative_unsigned,\n    types::{D, F},\n};\n\n#[derive(Debug, Clone)]\n/// Targets representing a users account, where their equity and debt are split into individual tokens.\npub struct AccountTargets {\n    pub id: [Target; 5],\n    pub equity: Vec\u003cTarget\u003e,\n    pub debt: Vec\u003cTarget\u003e,\n}\n\nimpl AccountTargets {\n    pub fn new_from_account(\n        account: \u0026Account,\n        builder: \u0026mut CircuitBuilder\u003cF, D\u003e,\n    ) -\u003e AccountTargets {\n        let id: [Target; 5] = std::array::from_fn(|_| builder.add_virtual_target());\n        let equity = builder.add_virtual_targets(account.equity.len());\n        let debt = builder.add_virtual_targets(account.debt.len());\n\n        AccountTargets { id, equity, debt }\n    }\n\n    pub fn set_account_targets(\u0026self, account_info: \u0026Account, pw: \u0026mut PartialWitness\u003cF\u003e) {\n        assert_eq!(self.equity.len(), account_info.equity.len());\n        assert_eq!(self.debt.len(), account_info.debt.len());\n\n        pw.set_target_arr(self.equity.as_slice(), account_info.equity.as_slice());\n        pw.set_target_arr(self.debt.as_slice(), account_info.debt.as_slice());\n        pw.set_target_arr(self.id.as_slice(), account_info.get_user_id_in_field().as_slice());\n    }\n}\n\n#[derive(Debug, Clone)]\n/// Targets representing a users account, where their equity and liabilities are summed into 2 summed values.\npub struct AccountSumTargets {\n    pub id: [Target; 5],\n    pub sum_equity: Target,\n    pub sum_debt: Target,\n}\n\nimpl AccountSumTargets {\n    /// Given Account Targets, sum the account equity and liabilities and return a AccountSumTargets.\n    pub fn from_account_target(\n        account: \u0026AccountTargets,\n        builder: \u0026mut CircuitBuilder\u003cF, D\u003e,\n    ) -\u003e AccountSumTargets {\n        let sum_equity = account.equity.iter().fold(builder.zero(), |x, y| builder.add(x, *y));\n\n        let sum_debt = account.debt.iter().fold(builder.zero(), |x, y| builder.add(x, *y));\n\n        let diff_between_equity_debt = builder.sub(sum_equity, sum_debt);\n\n        // Ensure the equity is greater than the debt. This works as long as we constrict our equity to 62 bits.\n        assert_non_negative_unsigned(builder, diff_between_equity_debt);\n\n        AccountSumTargets { id: account.id, sum_equity, sum_debt }\n    }\n\n    /// Get account hash targets\n    pub fn get_account_hash_targets(\u0026self, builder: \u0026mut CircuitBuilder\u003cF, D\u003e) -\u003e HashOutTarget {\n        #[allow(clippy::useless_vec)]\n        let hash_inputs = vec![self.id.to_vec(), vec![self.sum_equity, self.sum_debt]].concat();\n        builder.hash_n_to_hash_no_pad::\u003cPoseidonHash\u003e(hash_inputs)\n    }\n}\n\n#[cfg(test)]\npub mod test {\n    use crate::{\n        circuit_utils::run_circuit_test,\n        parser::{FileManager, JsonFileManager},\n    };\n\n    use super::{AccountSumTargets, AccountTargets};\n\n    #[test]\n    fn test_account_target() {\n        run_circuit_test(|builder, pw| {\n            let fm = FileManager {};\n            let path = \"../../test-data/batch0.json\";\n            let tokens = vec![\"BTC\".to_owned(), \"ETH\".to_owned()];\n            let accounts = fm.read_json_into_accounts_vec(path, \u0026tokens);\n\n            let account_target =\n                AccountTargets::new_from_account(accounts.get(0).unwrap(), builder);\n            account_target.set_account_targets(accounts.get(0).unwrap(), pw);\n        });\n    }\n\n    #[test]\n    fn test_account_sum_target() {\n        run_circuit_test(|builder, pw| {\n            let path = \"../../test-data/batch0.json\";\n            let fm = FileManager {};\n            let tokens = vec![\"BTC\".to_owned(), \"ETH\".to_owned()];\n            let accounts = fm.read_json_into_accounts_vec(path, \u0026tokens);\n\n            let account_target =\n                AccountTargets::new_from_account(accounts.get(0).unwrap(), builder);\n\n            let account_sum_target =\n                AccountSumTargets::from_account_target(\u0026account_target, builder);\n\n            let total_equity =\n                account_target.equity.iter().fold(builder.zero(), |x, y| builder.add(x, *y));\n            let total_debt =\n                account_target.debt.iter().fold(builder.zero(), |x, y| builder.add(x, *y));\n\n            builder.connect(account_sum_target.sum_equity, total_equity);\n            builder.connect(account_sum_target.sum_debt, total_debt);\n\n            account_target.set_account_targets(accounts.get(0).unwrap(), pw);\n        });\n    }\n}\n","traces":[{"line":25,"address":[10078146,10077776],"length":1,"stats":{"Line":1}},{"line":29,"address":[11835765,11835379,11835744],"length":1,"stats":{"Line":3}},{"line":30,"address":[11835398],"length":1,"stats":{"Line":1}},{"line":31,"address":[11835451,11835518],"length":1,"stats":{"Line":2}},{"line":36,"address":[11836491,11835792],"length":1,"stats":{"Line":1}},{"line":37,"address":[11835838],"length":1,"stats":{"Line":1}},{"line":38,"address":[11835990],"length":1,"stats":{"Line":1}},{"line":40,"address":[11836157],"length":1,"stats":{"Line":1}},{"line":41,"address":[11836251],"length":1,"stats":{"Line":1}},{"line":42,"address":[11836322],"length":1,"stats":{"Line":1}},{"line":56,"address":[10078880],"length":1,"stats":{"Line":1}},{"line":60,"address":[11836579,11837072,11837093],"length":1,"stats":{"Line":3}},{"line":62,"address":[11837184,11836661,11837205],"length":1,"stats":{"Line":3}},{"line":64,"address":[11836754],"length":1,"stats":{"Line":1}},{"line":67,"address":[11836870],"length":1,"stats":{"Line":1}},{"line":69,"address":[11836937],"length":1,"stats":{"Line":1}},{"line":73,"address":[11838098,11837296,11838069],"length":1,"stats":{"Line":1}},{"line":75,"address":[11837339,11838107],"length":1,"stats":{"Line":1}},{"line":76,"address":[11837995],"length":1,"stats":{"Line":1}}],"covered":19,"coverable":19},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","merkle_sum_prover","circuits","merkle_sum_circuit.rs"],"content":"use plonky2::{\n    hash::{\n        hash_types::{HashOutTarget, NUM_HASH_OUT_ELTS},\n        poseidon::PoseidonHash,\n    },\n    iop::target::Target,\n    plonk::{\n        circuit_builder::CircuitBuilder,\n        circuit_data::{CircuitConfig, CircuitData},\n    },\n};\n\nuse plonky2_field::types::Field;\n\nuse crate::{\n    circuit_utils::assert_non_negative_unsigned,\n    types::{C, D, F},\n};\n\nuse super::account_circuit::{AccountSumTargets, AccountTargets};\n\n/// A node in the merkle sum tree, contains the total amount of equity (in usd) and the total amount of debt (in usd) and the hash.\n///\n/// The hash is Hash(hash_left, hash_right).\n///\n/// The amount of equity and amount of debt is the sum of the equity and debt of the children.\n#[derive(Debug, Copy, Clone)]\npub struct MerkleSumNodeTarget {\n    pub sum_equity: Target,\n    pub sum_debt: Target,\n    pub hash: HashOutTarget,\n}\n\nimpl MerkleSumNodeTarget {\n    /// Given children nodes, generate the MerkleSumNodeTarget\n    pub fn get_parent_from_children\u003cconst N: usize\u003e(\n        builder: \u0026mut CircuitBuilder\u003cF, D\u003e,\n        children: \u0026[MerkleSumNodeTarget],\n    ) -\u003e MerkleSumNodeTarget {\n        assert_eq!(N, children.len());\n        let mut sum_equity = builder.constant(F::ZERO);\n        let mut sum_debt = builder.constant(F::ZERO);\n        let mut hash_inputs = Vec::new();\n        children.iter().for_each(|child| {\n            sum_equity = builder.add(sum_equity, child.sum_equity);\n            sum_debt = builder.add(sum_debt, child.sum_debt);\n\n            // Ensure the amount of equity at this node is greater than the total amount of debt\n            let diff_between_equity_debt = builder.sub(sum_equity, sum_debt);\n            assert_non_negative_unsigned(builder, diff_between_equity_debt);\n\n            // Ensure no overflow. We only need to check one child since in any overflow, the new value will be less than both the left and\n            // right children.\n            let diff_between_equity_child_and_sum = builder.sub(sum_equity, child.sum_equity);\n            assert_non_negative_unsigned(builder, diff_between_equity_child_and_sum);\n            let diff_between_debt_child_and_sum = builder.sub(sum_debt, child.sum_debt);\n            assert_non_negative_unsigned(builder, diff_between_debt_child_and_sum);\n\n            hash_inputs.extend(child.hash.elements.iter());\n        });\n        let hash = builder.hash_n_to_hash_no_pad::\u003cPoseidonHash\u003e(hash_inputs);\n        MerkleSumNodeTarget { sum_equity, sum_debt, hash }\n    }\n\n    /// Get a merkle sum node target from account sum targets.\n    pub fn get_node_from_account_targets(\n        builder: \u0026mut CircuitBuilder\u003cF, D\u003e,\n        account_targets: \u0026AccountSumTargets,\n    ) -\u003e MerkleSumNodeTarget {\n        let hash = account_targets.get_account_hash_targets(builder);\n        MerkleSumNodeTarget {\n            sum_equity: account_targets.sum_equity,\n            sum_debt: account_targets.sum_debt,\n            hash,\n        }\n    }\n\n    #[inline(always)]\n    pub fn pub_input_equity_offset() -\u003e usize {\n        0\n    }\n\n    #[inline(always)]\n    pub fn pub_input_debt_offset() -\u003e usize {\n        1\n    }\n\n    pub fn pub_input_root_hash_offset() -\u003e std::ops::Range\u003cusize\u003e {\n        // the first two targets are sum_equity and sum_debt.\n        2..6\n    }\n\n    /// Register this node targets as a public input\n    pub fn register_as_public_input(\u0026self, builder: \u0026mut CircuitBuilder\u003cF, D\u003e) {\n        builder.register_public_input(self.sum_equity);\n        builder.register_public_input(self.sum_debt);\n        builder.register_public_inputs(\u0026self.hash.elements);\n    }\n}\n\nimpl From\u003cMerkleSumNodeTarget\u003e for Vec\u003cTarget\u003e {\n    fn from(node: MerkleSumNodeTarget) -\u003e Vec\u003cTarget\u003e {\n        #[allow(clippy::useless_vec)]\n        vec![vec![node.sum_equity, node.sum_debt], node.hash.elements.to_vec()].concat()\n    }\n}\n\nimpl From\u003cVec\u003cTarget\u003e\u003e for MerkleSumNodeTarget {\n    /// the parsing order must be consistent with the order of public input registration in `registered_as_public_inputs`\n    fn from(inputs: Vec\u003cTarget\u003e) -\u003e MerkleSumNodeTarget {\n        let mut iter = inputs.into_iter();\n        let sum_equity_target = iter.next().unwrap();\n        let sum_debt_target = iter.next().unwrap();\n        let hash_target = HashOutTarget::from_vec(iter.by_ref().take(NUM_HASH_OUT_ELTS).collect());\n\n        MerkleSumNodeTarget {\n            sum_equity: sum_equity_target,\n            sum_debt: sum_debt_target,\n            hash: hash_target,\n        }\n    }\n}\n/// We can represent the Merkle Sum Tree as a vector of merkle sum nodes, with the root being the last node in the vector.    \npub struct MerkleSumTreeTarget {\n    pub sum_tree: Vec\u003cMerkleSumNodeTarget\u003e,\n}\n\nimpl MerkleSumTreeTarget {\n    pub fn get_root(\u0026self) -\u003e \u0026MerkleSumNodeTarget {\n        self.sum_tree.last().unwrap()\n    }\n\n    /// Register the root hash, sum_equity and sum_debt as public inputs to be used in recursive proving.\n    pub fn register_public_inputs(\u0026self, builder: \u0026mut CircuitBuilder\u003cF, D\u003e) {\n        let root = self.get_root();\n        root.register_as_public_input(builder);\n    }\n\n    /// Builds a merkle sum tree of a given size (based on the number of leaves). It will build the merkle sum tree on top of the leaves vector\n    /// in order to do the task in place. There is no return value as the input leaves vector is mutated.\n    pub fn build_merkle_sum_tree(\n        builder: \u0026mut CircuitBuilder\u003cF, D\u003e,\n        leaves: \u0026mut Vec\u003cMerkleSumNodeTarget\u003e,\n    ) {\n        let num_leaves = leaves.len();\n\n        for i in num_leaves..(num_leaves * 2 - 1) {\n            let left_child_index = 2 * (i - num_leaves);\n            let right_child_index = 2 * (i - num_leaves) + 1;\n            let left_child = leaves.get(left_child_index).unwrap();\n            let right_child = leaves.get(right_child_index).unwrap();\n            leaves.push(MerkleSumNodeTarget::get_parent_from_children::\u003c2\u003e(\n                builder,\n                \u0026vec![*left_child, *right_child],\n            ));\n        }\n    }\n\n    /// Given a list of account targets, build the corresponding merkle sum tree.\n    pub fn build_new_from_account_targets(\n        builder: \u0026mut CircuitBuilder\u003cF, D\u003e,\n        accounts: \u0026mut [AccountSumTargets],\n    ) -\u003e MerkleSumTreeTarget {\n        let mut leaves: Vec\u003cMerkleSumNodeTarget\u003e = accounts\n            .iter()\n            .map(|x| MerkleSumNodeTarget::get_node_from_account_targets(builder, x))\n            .collect();\n\n        MerkleSumTreeTarget::build_merkle_sum_tree(builder, \u0026mut leaves);\n\n        let tree = MerkleSumTreeTarget { sum_tree: leaves };\n\n        tree.register_public_inputs(builder);\n\n        tree\n    }\n}\n\npub fn build_merkle_sum_tree_circuit(\n    num_of_leaves: usize,\n    token_num: usize,\n    config: CircuitConfig,\n) -\u003e (CircuitData\u003cF, C, D\u003e, Vec\u003cAccountTargets\u003e) {\n    // assert num_of_leaves is a power of 2\n    assert!(num_of_leaves.is_power_of_two(), \"num_of_leaves must be a power of 2.\");\n\n    let mut builder = CircuitBuilder::\u003cF, D\u003e::new(config);\n    let mut account_targets: Vec\u003cAccountTargets\u003e = Vec::new();\n    (0..num_of_leaves).for_each(|_| {\n        let id: [Target; 5] = std::array::from_fn(|_| builder.add_virtual_target());\n        let equity_targets = builder.add_virtual_targets(token_num);\n        let debt_targets = builder.add_virtual_targets(token_num);\n        let account_target = AccountTargets { id, equity: equity_targets, debt: debt_targets };\n        account_targets.push(account_target);\n    });\n    let mut account_sum_targets: Vec\u003cAccountSumTargets\u003e = account_targets\n        .iter()\n        .map(|x| AccountSumTargets::from_account_target(x, \u0026mut builder))\n        .collect();\n\n    _ = MerkleSumTreeTarget::build_new_from_account_targets(\u0026mut builder, \u0026mut account_sum_targets);\n    let circuit_data = builder.build::\u003cC\u003e();\n    (circuit_data, account_targets)\n}\n\n#[cfg(test)]\npub mod test {\n    use crate::{\n        circuit_utils::run_circuit_test,\n        merkle_sum_prover::circuits::account_circuit::{AccountSumTargets, AccountTargets},\n        parser::{FileManager, JsonFileManager},\n    };\n\n    use super::MerkleSumNodeTarget;\n\n    #[test]\n    pub fn test_merkle_sum_node() {\n        run_circuit_test(|builder, pw| {\n            let path = \"../../test-data/batch0.json\";\n            let fm = FileManager {};\n            let tokens = vec![\"BTC\".to_owned(), \"ETH\".to_owned()];\n            let accounts = fm.read_json_into_accounts_vec(path, \u0026tokens);\n\n            let account_target_1 =\n                AccountTargets::new_from_account(accounts.get(0).unwrap(), builder);\n            let account_target_2 =\n                AccountTargets::new_from_account(accounts.get(1).unwrap(), builder);\n\n            let account_sum_target_1 =\n                AccountSumTargets::from_account_target(\u0026account_target_1, builder);\n            let account_sum_target_2 =\n                AccountSumTargets::from_account_target(\u0026account_target_2, builder);\n\n            let merkle_sum_node_target_1 =\n                MerkleSumNodeTarget::get_node_from_account_targets(builder, \u0026account_sum_target_1);\n            let merkle_sum_node_target_2 =\n                MerkleSumNodeTarget::get_node_from_account_targets(builder, \u0026account_sum_target_2);\n\n            let merkle_sum_node_target_3 = MerkleSumNodeTarget::get_parent_from_children::\u003c2\u003e(\n                builder,\n                \u0026vec![merkle_sum_node_target_1, merkle_sum_node_target_2],\n            );\n\n            let sum_equity =\n                builder.add(account_sum_target_1.sum_equity, account_sum_target_2.sum_equity);\n            let sum_debt =\n                builder.add(account_sum_target_1.sum_debt, account_sum_target_2.sum_debt);\n\n            builder.connect(merkle_sum_node_target_3.sum_equity, sum_equity);\n            builder.connect(merkle_sum_node_target_3.sum_debt, sum_debt);\n\n            account_target_1.set_account_targets(accounts.get(0).unwrap(), pw);\n            account_target_2.set_account_targets(accounts.get(1).unwrap(), pw);\n        });\n    }\n}\n","traces":[{"line":36,"address":[9279200,9279924,9279892],"length":1,"stats":{"Line":1}},{"line":40,"address":[8728440],"length":1,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[8728592],"length":1,"stats":{"Line":1}},{"line":43,"address":[11838334],"length":1,"stats":{"Line":1}},{"line":44,"address":[9279457,9279542,9279936],"length":1,"stats":{"Line":3}},{"line":45,"address":[8729139],"length":1,"stats":{"Line":1}},{"line":46,"address":[9280089],"length":1,"stats":{"Line":1}},{"line":49,"address":[8729389],"length":1,"stats":{"Line":1}},{"line":50,"address":[11839266],"length":1,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[9280524],"length":1,"stats":{"Line":1}},{"line":56,"address":[8729761],"length":1,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[9280787],"length":1,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[8730000],"length":1,"stats":{"Line":1}},{"line":70,"address":[11839820],"length":1,"stats":{"Line":1}},{"line":72,"address":[11839840],"length":1,"stats":{"Line":1}},{"line":73,"address":[11839879],"length":1,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[11840032],"length":1,"stats":{"Line":1}},{"line":94,"address":[11840048],"length":1,"stats":{"Line":1}},{"line":95,"address":[11840083],"length":1,"stats":{"Line":1}},{"line":96,"address":[11840130],"length":1,"stats":{"Line":1}},{"line":97,"address":[11840178],"length":1,"stats":{"Line":1}},{"line":102,"address":[10375337,10374720],"length":1,"stats":{"Line":0}},{"line":104,"address":[10374762,10375302,10375359],"length":1,"stats":{"Line":0}},{"line":110,"address":[11840700,11840208],"length":1,"stats":{"Line":0}},{"line":111,"address":[8730459],"length":1,"stats":{"Line":0}},{"line":112,"address":[8730474],"length":1,"stats":{"Line":0}},{"line":113,"address":[11840371],"length":1,"stats":{"Line":0}},{"line":114,"address":[11840481],"length":1,"stats":{"Line":0}},{"line":129,"address":[11840736],"length":1,"stats":{"Line":1}},{"line":130,"address":[8730936],"length":1,"stats":{"Line":1}},{"line":134,"address":[11840816],"length":1,"stats":{"Line":1}},{"line":135,"address":[11840835],"length":1,"stats":{"Line":1}},{"line":136,"address":[11840854],"length":1,"stats":{"Line":1}},{"line":141,"address":[11840880,11841949],"length":1,"stats":{"Line":1}},{"line":145,"address":[11840932],"length":1,"stats":{"Line":1}},{"line":147,"address":[11841129,11840954],"length":1,"stats":{"Line":2}},{"line":148,"address":[8731325,8731426],"length":1,"stats":{"Line":1}},{"line":149,"address":[11841658,11841233,11841272],"length":1,"stats":{"Line":2}},{"line":150,"address":[11841370,11841467],"length":1,"stats":{"Line":2}},{"line":151,"address":[8731648,8731735],"length":1,"stats":{"Line":2}},{"line":152,"address":[11841884],"length":1,"stats":{"Line":1}},{"line":154,"address":[8731743,8731879],"length":1,"stats":{"Line":2}},{"line":160,"address":[11841984,11842374],"length":1,"stats":{"Line":1}},{"line":164,"address":[11842056],"length":1,"stats":{"Line":1}},{"line":166,"address":[8732549,8732528],"length":1,"stats":{"Line":2}},{"line":169,"address":[11842142],"length":1,"stats":{"Line":1}},{"line":171,"address":[8732327],"length":1,"stats":{"Line":1}},{"line":173,"address":[11842262],"length":1,"stats":{"Line":1}},{"line":175,"address":[8732449],"length":1,"stats":{"Line":1}},{"line":179,"address":[11843595,11843542,11842464],"length":1,"stats":{"Line":1}},{"line":185,"address":[11842507,11842857,11842705],"length":1,"stats":{"Line":2}},{"line":187,"address":[11842739,11842882],"length":1,"stats":{"Line":2}},{"line":188,"address":[8733006],"length":1,"stats":{"Line":1}},{"line":189,"address":[11844058,11842955,11844090,11843632],"length":1,"stats":{"Line":2}},{"line":190,"address":[8733707,8734128,8734149],"length":1,"stats":{"Line":3}},{"line":191,"address":[11843690],"length":1,"stats":{"Line":1}},{"line":192,"address":[8733767],"length":1,"stats":{"Line":1}},{"line":193,"address":[11843808],"length":1,"stats":{"Line":1}},{"line":194,"address":[11844019],"length":1,"stats":{"Line":1}},{"line":196,"address":[11843072],"length":1,"stats":{"Line":1}},{"line":198,"address":[11844160,11844195],"length":1,"stats":{"Line":2}},{"line":201,"address":[11843279,11843196],"length":1,"stats":{"Line":2}},{"line":202,"address":[11843325],"length":1,"stats":{"Line":1}},{"line":203,"address":[11843397],"length":1,"stats":{"Line":1}}],"covered":61,"coverable":72},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","merkle_sum_prover","circuits","mod.rs"],"content":"pub mod account_circuit;\npub mod merkle_sum_circuit;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","merkle_sum_prover","mod.rs"],"content":"pub mod circuits;\npub mod prover;\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","merkle_sum_prover","prover.rs"],"content":"use crate::{\n    account::Account,\n    circuit_config::STANDARD_CONFIG,\n    circuit_utils::prove_timing,\n    merkle_sum_prover::circuits::account_circuit::{AccountSumTargets, AccountTargets},\n    types::{C, D, F},\n};\nuse plonky2::{\n    iop::witness::PartialWitness,\n    plonk::{\n        circuit_builder::CircuitBuilder, circuit_data::CircuitData, proof::ProofWithPublicInputs,\n        prover::prove,\n    },\n};\n\nuse tracing::{error, info};\n\nuse super::circuits::merkle_sum_circuit::MerkleSumTreeTarget;\n\n/// A merkle sum tree prover with a batch id representing its index in the recursive proof tree and a Vec of accounts representing accounts in this batch.\n#[derive(Debug)]\npub struct MerkleSumTreeProver {\n    // batch_id: usize,\n    pub accounts: Vec\u003cAccount\u003e,\n}\n\nimpl MerkleSumTreeProver {\n    /// Sets provided account targets with values from accounts in the prover batch.\n    pub fn set_merkle_tree_targets(\n        \u0026self,\n        pw: \u0026mut PartialWitness\u003cF\u003e,\n        account_targets: \u0026[AccountTargets],\n    ) {\n        for i in 0..self.accounts.len() {\n            // Set account targets\n            account_targets.get(i).unwrap().set_account_targets(self.accounts.get(i).unwrap(), pw);\n        }\n    }\n\n    /// Builds a merkle sum tree targets and returns the account targets to be set with input values.\n    pub fn build_merkle_tree_targets(\n        \u0026self,\n        builder: \u0026mut CircuitBuilder\u003cF, D\u003e,\n    ) -\u003e Vec\u003cAccountTargets\u003e {\n        let mut account_targets: Vec\u003cAccountTargets\u003e = Vec::new();\n\n        for i in 0..self.accounts.len() {\n            // Build account targets\n            let account_target =\n                AccountTargets::new_from_account(self.accounts.get(i).unwrap(), builder);\n            // Set account targets\n            account_targets.push(account_target);\n        }\n\n        let mut account_sum_targets: Vec\u003cAccountSumTargets\u003e = account_targets\n            .iter()\n            .map(|x| AccountSumTargets::from_account_target(x, builder))\n            .collect();\n\n        // build merkle sum tree\n        let _merkle_tree_targets =\n            MerkleSumTreeTarget::build_new_from_account_targets(builder, \u0026mut account_sum_targets);\n\n        account_targets\n    }\n\n    /// Get the merkle sum tree proof of this batch of accounts.\n    pub fn get_proof(\u0026self) -\u003e ProofWithPublicInputs\u003cF, C, D\u003e {\n        let mut builder = CircuitBuilder::\u003cF, D\u003e::new(STANDARD_CONFIG);\n        let mut pw = PartialWitness::\u003cF\u003e::new();\n\n        // Build and set merkle tree targets\n        let account_targets = self.build_merkle_tree_targets(\u0026mut builder);\n        self.set_merkle_tree_targets(\u0026mut pw, \u0026account_targets);\n\n        builder.print_gate_counts(0);\n\n        let mut t = prove_timing();\n        let data = builder.build::\u003cC\u003e();\n\n        let CircuitData { prover_only, common, verifier_only: _ } = \u0026data;\n\n        info!(\"Started Proving\");\n\n        let proof_res = prove(prover_only, common, pw, \u0026mut t);\n\n        match proof_res {\n            Ok(proof) =\u003e {\n                let proof_verification_res = data.verify(proof.clone());\n                match proof_verification_res {\n                    Ok(_) =\u003e proof,\n                    Err(e) =\u003e {\n                        error!(\"Proof verification failed: {:?}\", e);\n                        panic!(\"Proof verification failed!\");\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                error!(\"Proof generation failed: {:?}\", e);\n                panic!(\"Proof generation failed!\");\n            }\n        }\n    }\n\n    /// Get proof with a pre-compiled merkle sum circuit and account targets. In this method we do not need to build the circuit as we use a pre-built circuit.\n    pub fn get_proof_with_circuit_data(\n        \u0026self,\n        account_targets: \u0026[AccountTargets],\n        circuit_data: \u0026CircuitData\u003cF, C, D\u003e,\n    ) -\u003e ProofWithPublicInputs\u003cF, C, D\u003e {\n        let mut pw = PartialWitness::\u003cF\u003e::new();\n        for i in 0..self.accounts.len() {\n            // Build account targets\n            let account_target = account_targets.get(i).unwrap();\n            // Set account targets\n            account_target.set_account_targets(self.accounts.get(i).unwrap(), \u0026mut pw);\n        }\n\n        let CircuitData { prover_only, common, verifier_only: _ } = \u0026circuit_data;\n\n        let mut t = prove_timing();\n        let proof_res = prove(prover_only, common, pw, \u0026mut t);\n\n        match proof_res {\n            Ok(proof) =\u003e {\n                let proof_verification_res = circuit_data.verify(proof.clone());\n                match proof_verification_res {\n                    Ok(_) =\u003e proof,\n                    Err(e) =\u003e {\n                        error!(\"Proof verification failed: {:?}\", e);\n                        panic!(\"Proof verification failed!\");\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                error!(\"Proof generation failed: {:?}\", e);\n                panic!(\"Proof generation failed!\");\n            }\n        }\n    }\n\n    /// Get the merkle sum tree proof of this batch of accounts and the circuit data of the corresponding proof.\n    pub fn get_proof_and_circuit_data(\n        \u0026self,\n    ) -\u003e (ProofWithPublicInputs\u003cF, C, D\u003e, CircuitData\u003cF, C, D\u003e) {\n        let mut builder = CircuitBuilder::\u003cF, D\u003e::new(STANDARD_CONFIG);\n        let mut pw = PartialWitness::\u003cF\u003e::new();\n\n        // Build and set merkle tree targets\n        let account_targets = self.build_merkle_tree_targets(\u0026mut builder);\n        self.set_merkle_tree_targets(\u0026mut pw, \u0026account_targets);\n\n        builder.print_gate_counts(0);\n\n        let data = builder.build::\u003cC\u003e();\n\n        let CircuitData { prover_only, common, verifier_only: _ } = \u0026data;\n\n        tracing::debug!(\"Starting proving!\");\n\n        let mut t = prove_timing();\n        let proof_res = prove(prover_only, common, pw, \u0026mut t);\n\n        match proof_res {\n            Ok(proof) =\u003e {\n                let proof_verification_res = data.verify(proof.clone());\n                match proof_verification_res {\n                    Ok(_) =\u003e (proof, data),\n                    Err(e) =\u003e {\n                        error!(\"Proof verification failed: {:?}\", e);\n                        panic!(\"Proof verification failed!\");\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                error!(\"Proof generation failed: {:?}\", e);\n                panic!(\"Proof generation failed!\");\n            }\n        }\n    }\n}\n\n#[cfg(test)]\npub mod test {\n    use crate::{\n        circuit_utils::run_circuit_test,\n        parser::{FileManager, JsonFileManager},\n    };\n\n    use super::MerkleSumTreeProver;\n\n    #[test]\n    pub fn test_build_and_set_merkle_targets() {\n        run_circuit_test(|builder, pw| {\n            let path = \"../../test-data/batch0.json\";\n            let fm = FileManager {};\n            let tokens = vec![\"BTC\".to_owned(), \"ETH\".to_owned()];\n            let accounts = fm.read_json_into_accounts_vec(path, \u0026tokens);\n            let prover = MerkleSumTreeProver {\n                // batch_id: 0,\n                accounts,\n            };\n\n            // Build and set merkle tree targets\n            let account_targets = prover.build_merkle_tree_targets(builder);\n            prover.set_merkle_tree_targets(pw, \u0026account_targets);\n        });\n    }\n\n    #[test]\n    pub fn test_get_proof() {\n        let path = \"../../test-data/batch0.json\";\n        let fm = FileManager {};\n        let tokens = vec![\"BTC\".to_owned(), \"ETH\".to_owned()];\n        let accounts = fm.read_json_into_accounts_vec(path, \u0026tokens);\n        let prover = MerkleSumTreeProver {\n            // batch_id: 0,\n            accounts,\n        };\n\n        let _proof = prover.get_proof();\n    }\n}\n","traces":[{"line":29,"address":[8734240],"length":1,"stats":{"Line":1}},{"line":34,"address":[12901547,12901471],"length":1,"stats":{"Line":2}},{"line":36,"address":[12901722,12901562,12901638],"length":1,"stats":{"Line":3}},{"line":41,"address":[12902578,12901744,12902404],"length":1,"stats":{"Line":1}},{"line":45,"address":[12901796],"length":1,"stats":{"Line":1}},{"line":47,"address":[12902059,12901837,12901905],"length":1,"stats":{"Line":3}},{"line":49,"address":[8735180,8735283,8734868],"length":1,"stats":{"Line":3}},{"line":52,"address":[12902546],"length":1,"stats":{"Line":1}},{"line":55,"address":[12902022,12902114],"length":1,"stats":{"Line":2}},{"line":57,"address":[12902624,12902659],"length":1,"stats":{"Line":2}},{"line":61,"address":[8735056,8734976],"length":1,"stats":{"Line":2}},{"line":64,"address":[12902311],"length":1,"stats":{"Line":1}},{"line":68,"address":[8735424,8739673,8741110],"length":1,"stats":{"Line":1}},{"line":69,"address":[12902742],"length":1,"stats":{"Line":1}},{"line":70,"address":[12902904],"length":1,"stats":{"Line":1}},{"line":73,"address":[12902972],"length":1,"stats":{"Line":1}},{"line":74,"address":[12903045,12903145],"length":1,"stats":{"Line":2}},{"line":76,"address":[12903164],"length":1,"stats":{"Line":1}},{"line":78,"address":[12903187],"length":1,"stats":{"Line":1}},{"line":79,"address":[12903222],"length":1,"stats":{"Line":1}},{"line":81,"address":[12903295],"length":1,"stats":{"Line":1}},{"line":83,"address":[12904284,12904557,12903539,12904154,12904481,12903955],"length":1,"stats":{"Line":5}},{"line":85,"address":[12904357],"length":1,"stats":{"Line":1}},{"line":87,"address":[12904870],"length":1,"stats":{"Line":1}},{"line":88,"address":[12904905],"length":1,"stats":{"Line":1}},{"line":89,"address":[12904959,12905188],"length":1,"stats":{"Line":2}},{"line":90,"address":[12905239],"length":1,"stats":{"Line":1}},{"line":91,"address":[12905276],"length":1,"stats":{"Line":1}},{"line":92,"address":[12905336],"length":1,"stats":{"Line":0}},{"line":93,"address":[12906536,12906727,12906216,12906017,12906346,12905601,12906472],"length":1,"stats":{"Line":0}},{"line":94,"address":[12906411,12906977],"length":1,"stats":{"Line":0}},{"line":98,"address":[12904981],"length":1,"stats":{"Line":0}},{"line":99,"address":[12907898,12907087,12907781,12907962,12907482,12907669,12908153],"length":1,"stats":{"Line":0}},{"line":100,"address":[12907837,12908403],"length":1,"stats":{"Line":0}},{"line":106,"address":[12908496,12911181,12912880],"length":1,"stats":{"Line":1}},{"line":111,"address":[12908575],"length":1,"stats":{"Line":1}},{"line":112,"address":[12908624,12908692,12908922],"length":1,"stats":{"Line":3}},{"line":114,"address":[12912708,12908946],"length":1,"stats":{"Line":2}},{"line":116,"address":[12912856,12912716],"length":1,"stats":{"Line":2}},{"line":119,"address":[12908833],"length":1,"stats":{"Line":1}},{"line":121,"address":[12908992,12908887],"length":1,"stats":{"Line":2}},{"line":122,"address":[12909000],"length":1,"stats":{"Line":1}},{"line":124,"address":[12909075],"length":1,"stats":{"Line":1}},{"line":125,"address":[8741746],"length":1,"stats":{"Line":1}},{"line":126,"address":[8742025,8741808],"length":1,"stats":{"Line":2}},{"line":127,"address":[8742072],"length":1,"stats":{"Line":1}},{"line":128,"address":[12909481],"length":1,"stats":{"Line":1}},{"line":129,"address":[8742167],"length":1,"stats":{"Line":0}},{"line":130,"address":[12910169,12910630,12910706,12910498,12910368,12909753,12910900],"length":1,"stats":{"Line":0}},{"line":131,"address":[12910563,12911153],"length":1,"stats":{"Line":0}},{"line":135,"address":[12909186],"length":1,"stats":{"Line":0}},{"line":136,"address":[12911854,12911966,12911667,12912083,12911263,12912147,12912338],"length":1,"stats":{"Line":0}},{"line":137,"address":[8745204,8744642],"length":1,"stats":{"Line":0}},{"line":143,"address":[12912912,12917389,12918860],"length":1,"stats":{"Line":0}},{"line":146,"address":[8745574],"length":1,"stats":{"Line":0}},{"line":147,"address":[12913136],"length":1,"stats":{"Line":0}},{"line":150,"address":[8745804],"length":1,"stats":{"Line":0}},{"line":151,"address":[12913377,12913277],"length":1,"stats":{"Line":0}},{"line":153,"address":[8745992],"length":1,"stats":{"Line":0}},{"line":155,"address":[12913419],"length":1,"stats":{"Line":0}},{"line":157,"address":[12913500],"length":1,"stats":{"Line":0}},{"line":159,"address":[12914157,12914611,12914356,12913741,12914687,12914486],"length":1,"stats":{"Line":0}},{"line":161,"address":[12914551,12915016],"length":1,"stats":{"Line":0}},{"line":162,"address":[12915024],"length":1,"stats":{"Line":0}},{"line":164,"address":[12915107],"length":1,"stats":{"Line":0}},{"line":165,"address":[12915142],"length":1,"stats":{"Line":0}},{"line":166,"address":[8747768,8748001],"length":1,"stats":{"Line":0}},{"line":167,"address":[12915476],"length":1,"stats":{"Line":0}},{"line":168,"address":[8748065],"length":1,"stats":{"Line":0}},{"line":169,"address":[12915739],"length":1,"stats":{"Line":0}},{"line":170,"address":[12916401,12916920,12917111,12915985,12916730,12916600,12916856],"length":1,"stats":{"Line":0}},{"line":171,"address":[12916795,12917361],"length":1,"stats":{"Line":0}},{"line":175,"address":[12915218],"length":1,"stats":{"Line":0}},{"line":176,"address":[12918053,12918537,12918346,12917866,12918165,12917471,12918282],"length":1,"stats":{"Line":0}},{"line":177,"address":[12918787,12918221],"length":1,"stats":{"Line":0}}],"covered":41,"coverable":75},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","merkle_sum_prover","utils.rs"],"content":"use plonky2::{\n    hash::{\n        hash_types::{HashOut, RichField},\n        poseidon::PoseidonHash,\n    },\n    plonk::config::Hasher,\n};\nuse plonky2_field::extension::Extendable;\n\npub fn hash_2_subhashes\u003cF: RichField + Extendable\u003cD\u003e, const D: usize\u003e(\n    hash_1: \u0026HashOut\u003cF\u003e,\n    hash_2: \u0026HashOut\u003cF\u003e,\n) -\u003e HashOut\u003cF\u003e {\n    #[allow(clippy::useless_vec)]\n    let inputs = vec![hash_1.elements.to_vec(), hash_2.elements.to_vec()].concat();\n    hash_inputs(inputs)\n}\n\npub fn hash_inputs\u003cF: RichField\u003e(inputs: Vec\u003cF\u003e) -\u003e HashOut\u003cF\u003e {\n    let hash = PoseidonHash::hash_no_pad(inputs.as_slice());\n    hash\n}\n","traces":[{"line":10,"address":[11234821,11234792,11234224],"length":1,"stats":{"Line":1}},{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":0}}],"covered":5,"coverable":6},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","merkle_sum_tree.rs"],"content":"use plonky2::{hash::hash_types::HashOut, util::log2_strict};\n\nuse crate::{\n    account::Account,\n    merkle_sum_prover::utils::hash_2_subhashes,\n    types::{D, F},\n};\n\nuse plonky2_field::types::Field;\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct MerkleSumNode {\n    pub sum_equity: F,\n    pub sum_debt: F,\n    pub hash: HashOut\u003cF\u003e,\n}\n\nimpl MerkleSumNode {\n    /// Get a new merkle sum node given a account.\n    pub fn new_from_account(account: \u0026Account) -\u003e MerkleSumNode {\n        let sum_equity = account.equity.iter().fold(F::ZERO, |acc, x| acc + *x);\n\n        let sum_debt = account.debt.iter().fold(F::ZERO, |acc, x| acc + *x);\n\n        let hash = account.get_hash();\n        MerkleSumNode { hash, sum_equity, sum_debt }\n    }\n\n    /// Get a new MerkleSumNode given its 2 child nodes.\n    pub fn new_from_children_nodes(node1: \u0026MerkleSumNode, node2: \u0026MerkleSumNode) -\u003e MerkleSumNode {\n        let hash = hash_2_subhashes::\u003cF, D\u003e(\u0026node1.hash, \u0026node2.hash);\n        let sum_equity = node1.sum_equity + node2.sum_equity;\n        let sum_debt = node2.sum_debt + node2.sum_debt;\n        MerkleSumNode { hash, sum_equity, sum_debt }\n    }\n}\n\n/// Struct representing a merkle sum tree, it is represented as a vector of Merkle Sum Nodes.\n#[derive(Debug, Clone)]\npub struct MerkleSumTree {\n    pub merkle_sum_tree: Vec\u003cMerkleSumNode\u003e,\n    pub tree_depth: usize,\n}\n\nimpl MerkleSumTree {\n    pub fn new_tree_from_accounts(accounts: \u0026[Account]) -\u003e MerkleSumTree {\n        let num_leaves = accounts.len();\n        let tree_depth = log2_strict(num_leaves);\n        let mut merkle_sum_tree: Vec\u003cMerkleSumNode\u003e = Vec::new();\n\n        for i in 0..num_leaves * 2 - 1 {\n            if i \u003c num_leaves {\n                let acct = accounts.get(i).unwrap();\n                merkle_sum_tree.push(MerkleSumNode::new_from_account(acct));\n            } else {\n                let left_child_index = 2 * (i - num_leaves);\n                let right_child_index = 2 * (i - num_leaves) + 1;\n                let left_child = merkle_sum_tree.get(left_child_index).unwrap();\n                let right_child = merkle_sum_tree.get(right_child_index).unwrap();\n                let node = MerkleSumNode::new_from_children_nodes(left_child, right_child);\n                merkle_sum_tree.push(node);\n            }\n        }\n\n        MerkleSumTree { merkle_sum_tree, tree_depth }\n    }\n\n    pub fn get_root(\u0026self) -\u003e MerkleSumNode {\n        *self.merkle_sum_tree.last().unwrap()\n    }\n\n    pub fn get_from_index(\u0026self, index: usize) -\u003e Option\u003c\u0026MerkleSumNode\u003e {\n        return self.merkle_sum_tree.get(index);\n    }\n}\n\n#[cfg(test)]\npub mod test {\n    use crate::{\n        account::gen_accounts_with_random_data,\n        circuit_config::STANDARD_CONFIG,\n        merkle_sum_prover::{\n            circuits::merkle_sum_circuit::{build_merkle_sum_tree_circuit, MerkleSumNodeTarget},\n            prover::MerkleSumTreeProver,\n        },\n        parser::{FileManager, JsonFileManager},\n        types::F,\n    };\n    use plonky2::hash::hash_types::HashOut;\n    use plonky2_field::types::Field;\n\n    use super::{MerkleSumNode, MerkleSumTree};\n\n    #[test]\n    pub fn test_new_from_account() {\n        let path = \"../../test-data/batch0.json\";\n        let fm = FileManager {};\n        let tokens = vec![\"BTC\".to_owned(), \"ETH\".to_owned()];\n        let accounts = fm.read_json_into_accounts_vec(path, \u0026tokens);\n\n        let account = accounts.get(0).unwrap();\n        let node = MerkleSumNode::new_from_account(account);\n        let btc_amount = 574041;\n        let eth_amount = 38553;\n        assert_eq!(node.sum_equity, F::from_canonical_u64(btc_amount + eth_amount));\n        assert_eq!(node.sum_debt, F::from_canonical_u64(0));\n    }\n\n    #[test]\n    pub fn test_new_from_children_nodes() {\n        let fm = FileManager {};\n        let path = \"../../test-data/batch0.json\";\n        let tokens = vec![\"BTC\".to_owned(), \"ETH\".to_owned()];\n        let accounts = fm.read_json_into_accounts_vec(path, \u0026tokens);\n\n        let account1 = accounts.get(0).unwrap();\n        let node1 = MerkleSumNode::new_from_account(account1);\n        let acc1_btc_amount = 574041;\n        let acc1_eth_amount = 38553;\n        let acc2_btc_amount = 4864585;\n        let acc2_eth_amount = 6877764;\n\n        let account2 = accounts.get(1).unwrap();\n        let node2 = MerkleSumNode::new_from_account(account2);\n        let node3 = MerkleSumNode::new_from_children_nodes(\u0026node1, \u0026node2);\n        assert_eq!(\n            node3.sum_equity,\n            F::from_canonical_u64(\n                acc1_btc_amount + acc1_eth_amount + acc2_btc_amount + acc2_eth_amount\n            ),\n        );\n        assert_eq!(node3.sum_debt, F::from_canonical_u64(0));\n    }\n\n    #[test]\n    pub fn test_new_tree_from_accounts() {\n        let fm = FileManager {};\n        let path = \"../../test-data/batch0.json\";\n        let tokens = vec![\"BTC\".to_owned(), \"ETH\".to_owned()];\n        let accounts = fm.read_json_into_accounts_vec(path, \u0026tokens);\n        let mut sum_equity = F::ZERO;\n\n        for i in 0..accounts.len() {\n            let account = accounts.get(i).unwrap();\n            account.equity.iter().for_each(|x| {\n                sum_equity = sum_equity + *x;\n            });\n        }\n\n        let tree = MerkleSumTree::new_tree_from_accounts(\u0026accounts);\n\n        let root = tree.get_root();\n        assert_eq!(root.sum_equity, sum_equity);\n        assert_eq!(root.sum_debt, F::ZERO);\n    }\n\n    #[test]\n    fn test_identical_root_hash_with_proving() {\n        let batch_num = 4;\n        let num_assets = 4;\n        let accounts = gen_accounts_with_random_data(4, num_assets);\n\n        let merkle_sum_tree = MerkleSumTree::new_tree_from_accounts(\u0026accounts);\n\n        let (batch_circuit, account_targets) =\n            build_merkle_sum_tree_circuit(batch_num, num_assets, STANDARD_CONFIG);\n\n        let prover = MerkleSumTreeProver { accounts };\n        let proof = prover.get_proof_with_circuit_data(\u0026account_targets, \u0026batch_circuit);\n\n        let hash_offset = MerkleSumNodeTarget::pub_input_root_hash_offset();\n        let proof_root_hash = HashOut::\u003cF\u003e::from_partial(\u0026proof.public_inputs[hash_offset]);\n        assert_eq!(proof_root_hash, merkle_sum_tree.get_root().hash);\n    }\n}\n","traces":[{"line":20,"address":[12918896],"length":1,"stats":{"Line":1}},{"line":21,"address":[12919120,12918928,12919152],"length":1,"stats":{"Line":3}},{"line":23,"address":[12918981,12919168,12919200],"length":1,"stats":{"Line":3}},{"line":25,"address":[12919034],"length":1,"stats":{"Line":1}},{"line":30,"address":[10353968],"length":1,"stats":{"Line":1}},{"line":31,"address":[12919249],"length":1,"stats":{"Line":1}},{"line":32,"address":[12919269],"length":1,"stats":{"Line":1}},{"line":33,"address":[12919297],"length":1,"stats":{"Line":1}},{"line":46,"address":[12920787,12919392],"length":1,"stats":{"Line":1}},{"line":47,"address":[12919458],"length":1,"stats":{"Line":1}},{"line":48,"address":[12919466],"length":1,"stats":{"Line":1}},{"line":49,"address":[12919488],"length":1,"stats":{"Line":1}},{"line":51,"address":[12919510,12919634,12919920],"length":1,"stats":{"Line":3}},{"line":52,"address":[12919941],"length":1,"stats":{"Line":1}},{"line":53,"address":[10354745,10355447],"length":1,"stats":{"Line":2}},{"line":54,"address":[12920736],"length":1,"stats":{"Line":1}},{"line":56,"address":[12920022,12919959,12920107],"length":1,"stats":{"Line":2}},{"line":57,"address":[12920089,12920258,12920133],"length":1,"stats":{"Line":2}},{"line":58,"address":[10355125,10355033,10354980],"length":1,"stats":{"Line":3}},{"line":59,"address":[12920543,12920398],"length":1,"stats":{"Line":2}},{"line":60,"address":[12920551],"length":1,"stats":{"Line":1}},{"line":61,"address":[12920570],"length":1,"stats":{"Line":1}},{"line":68,"address":[12920816],"length":1,"stats":{"Line":1}},{"line":69,"address":[12920920,12920848],"length":1,"stats":{"Line":2}},{"line":72,"address":[12920944],"length":1,"stats":{"Line":0}},{"line":73,"address":[12920962],"length":1,"stats":{"Line":0}}],"covered":24,"coverable":26},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","parser.rs"],"content":"use super::account::{gen_accounts_with_random_data, Account};\nuse crate::types::F;\nuse plonky2_field::types::Field;\nuse serde_json::{Map, Value};\nuse std::{\n    fs,\n    fs::File,\n    io::BufReader,\n    ops::Div,\n    path::{Path, PathBuf},\n};\nuse tracing::{debug, error, info};\n\n#[derive(Debug, Clone)]\npub struct FilesCfg {\n    pub dir: PathBuf,\n    pub batch_size: usize,\n    pub tokens: Vec\u003cString\u003e,\n}\n\npub trait AccountParser {\n    fn read_n_accounts(\n        \u0026mut self,\n        offset: usize,\n        n: usize,\n        fm: \u0026impl JsonFileManager,\n    ) -\u003e Vec\u003cAccount\u003e;\n    fn total_num_of_users(\u0026self) -\u003e usize;\n}\n\n#[derive(Debug)]\npub struct FileManager {}\n\npub trait JsonFileManager {\n    fn list_json_files(\u0026self, dir: \u0026Path) -\u003e std::io::Result\u003cVec\u003cPathBuf\u003e\u003e;\n    fn read_json_into_accounts_vec(\u0026self, path: \u0026str, tokens: \u0026Vec\u003cString\u003e) -\u003e Vec\u003cAccount\u003e;\n    fn read_json_file_into_map(\u0026self, path: \u0026str) -\u003e Vec\u003cMap\u003cString, Value\u003e\u003e;\n}\n\nimpl JsonFileManager for FileManager {\n    fn list_json_files(\u0026self, dir: \u0026Path) -\u003e std::io::Result\u003cVec\u003cPathBuf\u003e\u003e {\n        let mut json_files = Vec::new();\n        if dir.is_dir() {\n            for entry in fs::read_dir(dir)? {\n                let entry = entry?;\n                let path = entry.path();\n                if path.is_file() {\n                    if let Some(extension) = path.extension() {\n                        if extension == \"json\" {\n                            json_files.push(path);\n                        }\n                    }\n                } else if path.is_dir() {\n                    json_files.extend(self.list_json_files(\u0026path)?);\n                }\n            }\n        }\n        json_files.sort();\n        Ok(json_files)\n    }\n\n    /// Read a json file and return the vec of associated accounts.\n    /// tokens is a list of all possible token names. It is used to fill the account with zero for missing tokens.\n    fn read_json_into_accounts_vec(\u0026self, path: \u0026str, tokens: \u0026Vec\u003cString\u003e) -\u003e Vec\u003cAccount\u003e {\n        let parsed_data = self.read_json_file_into_map(path);\n        parse_exchange_state(\u0026parsed_data, tokens)\n    }\n\n    /// Reads a json file into a json string.\n    fn read_json_file_into_map(\u0026self, path: \u0026str) -\u003e Vec\u003cMap\u003cString, Value\u003e\u003e {\n        let file = File::open(path);\n        match file {\n            Ok(f) =\u003e {\n                let reader = BufReader::new(f);\n                // Deserialize the binary data to a struct\n                serde_json::from_reader(reader).expect(\"Unable to parse Json Data\")\n            }\n            Err(e) =\u003e {\n                error!(\"file open error, {:?}\", e);\n                panic!(\"File not found at specified path\");\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct FileAccountReader {\n    pub cfg: FilesCfg,\n    pub total_num_of_batches: usize,\n    pub total_num_of_users: usize,\n    num_of_docs: usize,\n    num_of_batches_per_doc: usize,\n    file_idx: usize,\n    offset: usize, // an offset to the buffered_accounts\n    buffered_accounts: Vec\u003cAccount\u003e,\n    last_doc_accounts: Vec\u003cAccount\u003e, // we keep this avoiding double loading of last doc\n    docs: Vec\u003cPathBuf\u003e,\n}\n\nimpl FileAccountReader {\n    pub fn new(cfg: FilesCfg, fm: \u0026impl JsonFileManager) -\u003e Self {\n        let user_data_path = std::path::Path::new(\u0026(cfg.dir));\n        if !user_data_path.exists() {\n            panic!(\"dir: {:?} does not exist\", user_data_path);\n        }\n        let json_files = fm.list_json_files(user_data_path);\n        let mut parser = Self {\n            buffered_accounts: vec![],\n            last_doc_accounts: vec![],\n            file_idx: 0,\n            offset: 0,\n            num_of_docs: 0,\n            cfg: cfg.clone(),\n            num_of_batches_per_doc: 0,\n            total_num_of_users: 0,\n            total_num_of_batches: 0,\n            docs: vec![],\n        };\n\n        match json_files {\n            Ok(docs) =\u003e {\n                info!(\"files: {:?}\", docs);\n                let doc_len = docs.len();\n                parser.docs = docs;\n                parser.num_of_docs = doc_len;\n                if doc_len \u003c 1 {\n                    panic!(\"no json files under the folder: {:?}\", user_data_path);\n                }\n                let first_doc_accounts =\n                    fm.read_json_into_accounts_vec(parser.docs[0].to_str().unwrap(), \u0026cfg.tokens);\n                let first_doc_accounts_len = first_doc_accounts.len();\n\n                if doc_len \u003e 1 {\n                    assert_eq!(first_doc_accounts_len % parser.cfg.batch_size, 0);\n                }\n                parser.num_of_batches_per_doc = first_doc_accounts_len.div(parser.cfg.batch_size);\n                parser.buffered_accounts = first_doc_accounts;\n                parser.file_idx = 0;\n\n                if doc_len \u003e 1 {\n                    let last_doc_accounts = fm.read_json_into_accounts_vec(\n                        parser.docs[doc_len - 1].to_str().unwrap(),\n                        \u0026cfg.tokens,\n                    );\n                    assert!(last_doc_accounts.len() \u003c= first_doc_accounts_len);\n                    parser.last_doc_accounts = last_doc_accounts;\n                }\n\n                let total_num_of_users =\n                    (doc_len - 1) * first_doc_accounts_len + parser.last_doc_accounts.len();\n\n                let num_of_batches = total_num_of_users.div_ceil(parser.cfg.batch_size);\n                parser.total_num_of_users = total_num_of_users;\n                parser.total_num_of_batches = num_of_batches;\n            }\n            Err(e) =\u003e panic!(\"list json files err: {:?}\", e),\n        }\n\n        parser\n    }\n\n    pub fn log_state(\u0026self) {\n        debug!(\"cfg: {:?},\\n num_of_files: {:?},\\n num_of_batches_per_doc: {:?},\\n file_idx: {:?},\\n offset: {:?},\\n total_num_of_users: {:?},\\n total_num_of_batches: {:?}\",\n        self.cfg, self.num_of_docs, self.num_of_batches_per_doc, self.file_idx, self.offset, self.total_num_of_users, self.total_num_of_batches);\n    }\n}\n\nimpl AccountParser for FileAccountReader {\n    fn total_num_of_users(\u0026self) -\u003e usize {\n        self.total_num_of_users\n    }\n\n    /// `offset` is to the global user vectors;\n    fn read_n_accounts(\n        \u0026mut self,\n        offset: usize,\n        n: usize,\n        fm: \u0026impl JsonFileManager,\n    ) -\u003e Vec\u003cAccount\u003e {\n        debug!(\"read with offset: {:?}, account_num: {:?}\", offset, n);\n        self.log_state();\n        // to make it simpler, we assume only read by a multiple of batch size;\n        // if try to read cross multiple docs; simply can run this function multiple times;\n        assert!(n % self.cfg.batch_size == 0);\n        let min_offset: usize = self.file_idx * self.cfg.batch_size * self.num_of_batches_per_doc;\n        assert!(offset \u003e= min_offset);\n\n        let acct_len =\n            if offset + n \u003e self.total_num_of_users { self.total_num_of_users - offset } else { n };\n        let num_of_tokens = self.cfg.tokens.len();\n        let mut result = vec![Account::get_empty_account(num_of_tokens); acct_len];\n        if (n + offset - min_offset) \u003c= (self.buffered_accounts.len()) {\n            // we have enough account in the buffer\n            result.clone_from_slice(\u0026self.buffered_accounts[self.offset..(self.offset + n)]);\n            self.offset += n;\n        } else {\n            let mut filled_len = 0;\n\n            if self.offset \u003c self.buffered_accounts.len() {\n                let filled_len = self.buffered_accounts.len() - self.offset;\n                result[0..filled_len].clone_from_slice(\u0026self.buffered_accounts[(self.offset)..]);\n            }\n            let mut missing_len = result.len() - (self.buffered_accounts.len() - self.offset);\n            debug!(\n                \"result len: {:?}, self.offset: {:?}, missing_len: {:?}\",\n                result.len(),\n                self.offset,\n                missing_len\n            );\n\n            while missing_len \u003e 0 {\n                let to_read =\n                    std::cmp::min(self.num_of_batches_per_doc * self.cfg.batch_size, missing_len);\n                if self.file_idx \u003c (self.num_of_docs - 1) {\n                    // load the next file; TODO: assert_eq!(accounts_len, last_doc_account_num);\n                    self.file_idx += 1;\n                    self.buffered_accounts = fm.read_json_into_accounts_vec(\n                        self.docs[self.file_idx].to_str().unwrap(),\n                        \u0026self.cfg.tokens,\n                    );\n                    result[filled_len..(filled_len + to_read)]\n                        .clone_from_slice(\u0026self.buffered_accounts[0..to_read]);\n                    filled_len += to_read;\n                    self.offset = to_read;\n                } else {\n                    self.offset += result.len();\n                    break;\n                }\n                missing_len -= to_read;\n            }\n        }\n        result\n    }\n}\n\n/// Parses the exchanges state at some snapshot and returns.\nfn parse_exchange_state(\n    parsed_data: \u0026Vec\u003cMap\u003cString, Value\u003e\u003e,\n    tokens: \u0026Vec\u003cString\u003e,\n) -\u003e Vec\u003cAccount\u003e {\n    let mut accounts_data: Vec\u003cAccount\u003e = Vec::new();\n    for obj in parsed_data {\n        accounts_data.push(parse_account_state(obj, tokens));\n    }\n    accounts_data\n}\n\n/// Parses the exchanges state at some snapshot and returns.\npub fn parse_account_state(parsed_data: \u0026Map\u003cString, Value\u003e, tokens: \u0026Vec\u003cString\u003e) -\u003e Account {\n    let account_id = parsed_data\n        .get(\"id\")\n        .expect(format!(\"Account {:?} dont have key `id`\", parsed_data).as_str())\n        .as_str()\n        .unwrap();\n\n    let equities = parsed_data\n        .get(\"equity\")\n        .expect(format!(\"Account {:?} dont have key `equity`\", parsed_data).as_str())\n        .as_object()\n        .unwrap();\n    let mut parsed_equities = Vec::new();\n    for token in tokens.iter() {\n        let parsed_equity = equities.get(token).map_or(F::ZERO, |val| {\n            F::from_canonical_u64(val.as_str().unwrap().parse::\u003cu64\u003e().unwrap())\n        });\n        parsed_equities.push(parsed_equity);\n    }\n\n    let mut parsed_debts = Vec::new();\n    if let Some(debts) = parsed_data.get(\"debt\") {\n        let debts = debts.as_object().unwrap();\n        for token in tokens.iter() {\n            let parsed_debt = debts.get(token).map_or(F::ZERO, |val| {\n                F::from_canonical_u64(val.as_str().unwrap().parse::\u003cu64\u003e().unwrap())\n            });\n            parsed_debts.push(parsed_debt);\n        }\n    } else {\n        // if there is no debt, we fill it with zero\n        parsed_debts = vec![F::ZERO; parsed_equities.len()];\n    }\n\n    Account { id: account_id.into(), equity: parsed_equities, debt: parsed_debts }\n}\n\npub struct RandomAccountParser {\n    pub total_num_of_users: usize,\n    pub num_of_tokens: usize,\n}\nimpl RandomAccountParser {\n    pub fn new(total_num_of_users: usize, num_of_tokens: usize) -\u003e Self {\n        RandomAccountParser { total_num_of_users: total_num_of_users, num_of_tokens: num_of_tokens }\n    }\n}\n\nimpl AccountParser for RandomAccountParser {\n    fn total_num_of_users(\u0026self) -\u003e usize {\n        self.total_num_of_users\n    }\n    /// `offset` is to the global user vectors;\n    fn read_n_accounts(\n        \u0026mut self,\n        offset: usize,\n        n: usize,\n        _: \u0026impl JsonFileManager,\n    ) -\u003e Vec\u003cAccount\u003e {\n        let n = std::cmp::min(n, self.total_num_of_users - offset);\n        gen_accounts_with_random_data(n, self.num_of_tokens)\n    }\n}\n\n#[cfg(test)]\nmod test {\n\n    use crate::{\n        account::Account,\n        parser::{parse_exchange_state, FileManager, FilesCfg},\n    };\n    use mockall::*;\n    use serde_json::{Map, Value};\n    use std::{\n        path::{Path, PathBuf},\n        str::FromStr,\n    };\n\n    use super::{AccountParser, FileAccountReader, JsonFileManager};\n\n    #[test]\n    pub fn test_read_json_file_into_map() {\n        let fm = FileManager {};\n        let path = \"../../test-data/batch0.json\";\n        let maps = fm.read_json_file_into_map(path);\n\n        let id_0 = \"4282aed0318e3271db2649f3a4a6855d9f83285d04ea541d741fd53a602eb73e\";\n        let parsed_id_0 = maps.get(0).unwrap().get(\"id\").unwrap();\n        assert_eq!(id_0, parsed_id_0);\n\n        let id_1 = \"bfad15056e9c14831ee4351f180b7cbd141a1b372ba8696c8505f7335282126d\";\n        let parsed_id_1 = maps.get(1).unwrap().get(\"id\").unwrap();\n        assert_eq!(id_1, parsed_id_1);\n    }\n\n    #[test]\n    pub fn test_parse_exchange_state() {\n        let fm = FileManager {};\n        let path = \"../../test-data/batch0.json\";\n        let maps = fm.read_json_file_into_map(path);\n        let tokens = vec![\"BTC\".to_string(), \"ETH\".to_string()];\n        let accounts = parse_exchange_state(\u0026maps, \u0026tokens);\n\n        let id_0 = \"4282aed0318e3271db2649f3a4a6855d9f83285d04ea541d741fd53a602eb73e\";\n        let account_0 = accounts.get(0).unwrap();\n        assert_eq!(id_0, account_0.id);\n\n        let id_1 = \"bfad15056e9c14831ee4351f180b7cbd141a1b372ba8696c8505f7335282126d\";\n        let account_1 = accounts.get(1).unwrap();\n        assert_eq!(id_1, account_1.id);\n    }\n\n    #[test]\n    pub fn test_read_json_into_accounts_vec() {\n        let fm = FileManager {};\n        let path = \"../../test-data/batch0.json\";\n        let tokens = vec![\"BTC\".to_string(), \"ETH\".to_string()];\n        let accounts = fm.read_json_into_accounts_vec(\u0026path, \u0026tokens);\n\n        let id_0 = \"4282aed0318e3271db2649f3a4a6855d9f83285d04ea541d741fd53a602eb73e\";\n        let account_0 = accounts.get(0).unwrap();\n        assert_eq!(id_0, account_0.id);\n\n        let id_1 = \"bfad15056e9c14831ee4351f180b7cbd141a1b372ba8696c8505f7335282126d\";\n        let account_1 = accounts.get(1).unwrap();\n        assert_eq!(id_1, account_1.id);\n    }\n\n    mock! {\n      pub FileManager {}\n\n      impl JsonFileManager for FileManager {\n          fn list_json_files(\u0026self, dir: \u0026Path) -\u003e std::io::Result\u003cVec\u003cPathBuf\u003e\u003e;\n          fn read_json_into_accounts_vec(\u0026self, path: \u0026str, tokens : \u0026Vec\u003cString\u003e) -\u003e Vec\u003cAccount\u003e;\n          fn read_json_file_into_map(\u0026self, path: \u0026str) -\u003e Vec\u003cMap\u003cString, Value\u003e\u003e;\n      }\n    }\n\n    #[test]\n    fn test_file_account_reader() {\n        let mut mock_file_manager = MockFileManager::new();\n        mock_file_manager.expect_list_json_files().returning(|_| {\n            let paths = vec![\n                std::path::PathBuf::from_str(\"file0\").unwrap(),\n                std::path::PathBuf::from_str(\"file1\").unwrap(),\n                std::path::PathBuf::from_str(\"file2\").unwrap(),\n                std::path::PathBuf::from_str(\"file3\").unwrap(),\n                std::path::PathBuf::from_str(\"file4\").unwrap(),\n                std::path::PathBuf::from_str(\"file5\").unwrap(),\n            ];\n            Ok(paths)\n        });\n\n        mock_file_manager.expect_read_json_into_accounts_vec().times(1).returning(|_, _| {\n            let accounts = vec![Account::get_empty_account(20); 4];\n            accounts\n        });\n        mock_file_manager.expect_read_json_into_accounts_vec().times(1).returning(|_, _| {\n            let accounts = vec![Account::get_empty_account(20); 3];\n            accounts\n        });\n\n        let dir = tempdir::TempDir::new(\"user_input_test\").unwrap().into_path();\n\n        let mut file_acct_reader = FileAccountReader::new(\n            FilesCfg { dir, batch_size: 4, tokens: vec![\"BTC\".to_owned(), \"ETH\".to_owned()] },\n            \u0026mock_file_manager,\n        );\n        assert_eq!(file_acct_reader.total_num_of_users(), 23);\n\n        mock_file_manager.expect_read_json_into_accounts_vec().times(1).returning(|_, _| {\n            let accounts = vec![Account::get_empty_account(20); 4];\n            accounts\n        });\n        let users = file_acct_reader.read_n_accounts(0, 8, \u0026mock_file_manager);\n        assert_eq!(users.len(), 8);\n\n        mock_file_manager.expect_read_json_into_accounts_vec().times(1).returning(|_, _| {\n            let accounts = vec![Account::get_empty_account(20); 4];\n            accounts\n        });\n        let users = file_acct_reader.read_n_accounts(8, 4, \u0026mock_file_manager);\n        assert_eq!(users.len(), 4);\n\n        mock_file_manager.expect_read_json_into_accounts_vec().times(3).returning(|_, _| {\n            let accounts = vec![Account::get_empty_account(20); 4];\n            accounts\n        });\n        let users = file_acct_reader.read_n_accounts(12, 12, \u0026mock_file_manager);\n        assert_eq!(users.len(), 11);\n    }\n}\n","traces":[{"line":41,"address":[8753203,8751424,8753169],"length":1,"stats":{"Line":0}},{"line":42,"address":[12921063],"length":1,"stats":{"Line":0}},{"line":43,"address":[12921104,12921173],"length":1,"stats":{"Line":0}},{"line":44,"address":[12921535,12921230,12921502,12922837],"length":1,"stats":{"Line":0}},{"line":45,"address":[12921904,12921744,12921583,12922813],"length":1,"stats":{"Line":0}},{"line":46,"address":[12921869,12921985],"length":1,"stats":{"Line":0}},{"line":47,"address":[12922066,12922001],"length":1,"stats":{"Line":0}},{"line":48,"address":[12922506,12922124],"length":1,"stats":{"Line":0}},{"line":49,"address":[12922618],"length":1,"stats":{"Line":0}},{"line":50,"address":[12922661],"length":1,"stats":{"Line":0}},{"line":53,"address":[12922099,12922154],"length":1,"stats":{"Line":0}},{"line":54,"address":[12922206],"length":1,"stats":{"Line":0}},{"line":58,"address":[8752023,8751611],"length":1,"stats":{"Line":0}},{"line":59,"address":[12921645],"length":1,"stats":{"Line":0}},{"line":64,"address":[12922864,12922995],"length":1,"stats":{"Line":1}},{"line":65,"address":[12922902],"length":1,"stats":{"Line":1}},{"line":66,"address":[8753284],"length":1,"stats":{"Line":1}},{"line":70,"address":[12923024,12924769],"length":1,"stats":{"Line":1}},{"line":71,"address":[12923094],"length":1,"stats":{"Line":1}},{"line":72,"address":[12923108],"length":1,"stats":{"Line":1}},{"line":73,"address":[12923121],"length":1,"stats":{"Line":1}},{"line":74,"address":[12923135],"length":1,"stats":{"Line":1}},{"line":76,"address":[8753485],"length":1,"stats":{"Line":1}},{"line":78,"address":[12923225],"length":1,"stats":{"Line":0}},{"line":79,"address":[12924238,12924121,12924302,12924492,12923427,12924009,12923822],"length":1,"stats":{"Line":0}},{"line":80,"address":[12924177,12924741],"length":1,"stats":{"Line":0}},{"line":101,"address":[9191814,9192159,9186816],"length":1,"stats":{"Line":1}},{"line":102,"address":[9186997,9186874],"length":1,"stats":{"Line":2}},{"line":103,"address":[8755329],"length":1,"stats":{"Line":1}},{"line":104,"address":[9187211],"length":1,"stats":{"Line":0}},{"line":106,"address":[9187289,9187176],"length":1,"stats":{"Line":2}},{"line":108,"address":[9187305],"length":1,"stats":{"Line":1}},{"line":109,"address":[9187390],"length":1,"stats":{"Line":1}},{"line":113,"address":[9187466],"length":1,"stats":{"Line":1}},{"line":117,"address":[9187514],"length":1,"stats":{"Line":1}},{"line":120,"address":[9187816],"length":1,"stats":{"Line":1}},{"line":121,"address":[8756143],"length":1,"stats":{"Line":1}},{"line":122,"address":[9189136,9189004,9188256,9188672,9188871,9189215,9189409],"length":1,"stats":{"Line":6}},{"line":123,"address":[9189077,9189670],"length":1,"stats":{"Line":2}},{"line":124,"address":[9189678],"length":1,"stats":{"Line":1}},{"line":125,"address":[9189868],"length":1,"stats":{"Line":1}},{"line":126,"address":[9189876],"length":1,"stats":{"Line":1}},{"line":127,"address":[9191845],"length":1,"stats":{"Line":0}},{"line":129,"address":[9190039,9190254,9189882],"length":1,"stats":{"Line":3}},{"line":131,"address":[9190285,9190369],"length":1,"stats":{"Line":2}},{"line":133,"address":[9190377],"length":1,"stats":{"Line":1}},{"line":134,"address":[9190424],"length":1,"stats":{"Line":1}},{"line":136,"address":[9190391,9190624],"length":1,"stats":{"Line":2}},{"line":137,"address":[9190632],"length":1,"stats":{"Line":1}},{"line":138,"address":[9190822],"length":1,"stats":{"Line":1}},{"line":140,"address":[9190834,9191489],"length":1,"stats":{"Line":2}},{"line":141,"address":[9191156],"length":1,"stats":{"Line":1}},{"line":142,"address":[9190883],"length":1,"stats":{"Line":1}},{"line":143,"address":[9191152],"length":1,"stats":{"Line":1}},{"line":145,"address":[8759512,8759446],"length":1,"stats":{"Line":2}},{"line":146,"address":[8759550],"length":1,"stats":{"Line":1}},{"line":149,"address":[8759893,8759754,8759107],"length":1,"stats":{"Line":2}},{"line":152,"address":[8759867,8759931],"length":1,"stats":{"Line":2}},{"line":153,"address":[8759939],"length":1,"stats":{"Line":1}},{"line":154,"address":[8759947],"length":1,"stats":{"Line":1}},{"line":156,"address":[8760191,8756357],"length":1,"stats":{"Line":0}},{"line":159,"address":[8759971],"length":1,"stats":{"Line":1}},{"line":162,"address":[8760400],"length":1,"stats":{"Line":1}},{"line":163,"address":[12925838,12926030,12925742,12925543,12925934,12925270,12924939,12926126,12925487,12925583,12926222,12926314,12925418],"length":1,"stats":{"Line":13}},{"line":169,"address":[8762368],"length":1,"stats":{"Line":1}},{"line":170,"address":[8762373],"length":1,"stats":{"Line":1}},{"line":174,"address":[8762384,8768461],"length":1,"stats":{"Line":1}},{"line":180,"address":[8763170,8763275,8763612,8763318,8762926,8762574,8763092],"length":1,"stats":{"Line":7}},{"line":181,"address":[9218416],"length":1,"stats":{"Line":1}},{"line":184,"address":[9219223,9218430,9219152],"length":1,"stats":{"Line":2}},{"line":185,"address":[9219267,9219333,9219197],"length":1,"stats":{"Line":2}},{"line":186,"address":[9219321,9219349],"length":1,"stats":{"Line":1}},{"line":188,"address":[8764166,8764410],"length":1,"stats":{"Line":2}},{"line":190,"address":[9219519],"length":1,"stats":{"Line":1}},{"line":191,"address":[8764329],"length":1,"stats":{"Line":1}},{"line":192,"address":[9219665,9219584,9219758,9223701],"length":1,"stats":{"Line":3}},{"line":194,"address":[9223499,9219886],"length":1,"stats":{"Line":0}},{"line":195,"address":[9223706,9223656],"length":1,"stats":{"Line":0}},{"line":197,"address":[9219828],"length":1,"stats":{"Line":1}},{"line":199,"address":[9219840,9219928],"length":1,"stats":{"Line":2}},{"line":200,"address":[9220094,9219971],"length":1,"stats":{"Line":1}},{"line":201,"address":[9220052,9220155],"length":1,"stats":{"Line":2}},{"line":203,"address":[9220258,9220548,9219933],"length":1,"stats":{"Line":2}},{"line":204,"address":[8766371],"length":1,"stats":{"Line":1}},{"line":211,"address":[8766149,8768199],"length":1,"stats":{"Line":2}},{"line":212,"address":[9222328],"length":1,"stats":{"Line":1}},{"line":214,"address":[8767178],"length":1,"stats":{"Line":1}},{"line":216,"address":[8767427,8767296,8767470],"length":1,"stats":{"Line":2}},{"line":217,"address":[8767839,8767726],"length":1,"stats":{"Line":2}},{"line":218,"address":[8767434,8767499],"length":1,"stats":{"Line":2}},{"line":219,"address":[9222972],"length":1,"stats":{"Line":1}},{"line":221,"address":[9223141,9223329],"length":1,"stats":{"Line":2}},{"line":222,"address":[8768011],"length":1,"stats":{"Line":1}},{"line":223,"address":[8768085,8768165],"length":1,"stats":{"Line":1}},{"line":224,"address":[8768132],"length":1,"stats":{"Line":1}},{"line":226,"address":[8767273,8767342,8767390],"length":1,"stats":{"Line":0}},{"line":229,"address":[9223405,9223457,9223470],"length":1,"stats":{"Line":2}},{"line":232,"address":[9222277],"length":1,"stats":{"Line":1}},{"line":237,"address":[8768496,8768775],"length":1,"stats":{"Line":1}},{"line":241,"address":[8768544],"length":1,"stats":{"Line":1}},{"line":242,"address":[12927032,12926918,12926846],"length":1,"stats":{"Line":3}},{"line":243,"address":[12927045],"length":1,"stats":{"Line":1}},{"line":245,"address":[12926993],"length":1,"stats":{"Line":1}},{"line":249,"address":[12927120,12929559,12929628],"length":1,"stats":{"Line":1}},{"line":250,"address":[8769163,8769357,8768847],"length":1,"stats":{"Line":3}},{"line":252,"address":[12927275,12927392],"length":1,"stats":{"Line":2}},{"line":256,"address":[8769728,8769866,8769412],"length":1,"stats":{"Line":3}},{"line":258,"address":[12927844,12927961],"length":1,"stats":{"Line":2}},{"line":261,"address":[12928219],"length":1,"stats":{"Line":1}},{"line":262,"address":[12928526,12928331,12928244],"length":1,"stats":{"Line":3}},{"line":263,"address":[12928542,12929573,12929648],"length":1,"stats":{"Line":3}},{"line":264,"address":[12929657,12929727],"length":1,"stats":{"Line":2}},{"line":266,"address":[8771264],"length":1,"stats":{"Line":1}},{"line":269,"address":[12928499],"length":1,"stats":{"Line":1}},{"line":270,"address":[12928561,12928646,12929327],"length":1,"stats":{"Line":3}},{"line":271,"address":[12928830,12928699],"length":1,"stats":{"Line":2}},{"line":272,"address":[8770510,8770735],"length":1,"stats":{"Line":2}},{"line":273,"address":[12929904,12929079],"length":1,"stats":{"Line":2}},{"line":274,"address":[8771577,8771647],"length":1,"stats":{"Line":2}},{"line":276,"address":[12929133],"length":1,"stats":{"Line":1}},{"line":280,"address":[12928715,12929162],"length":1,"stats":{"Line":2}},{"line":283,"address":[12929029,12929348],"length":1,"stats":{"Line":2}},{"line":291,"address":[12930160],"length":1,"stats":{"Line":0}},{"line":297,"address":[12930192],"length":1,"stats":{"Line":0}},{"line":298,"address":[12930197],"length":1,"stats":{"Line":0}}],"covered":99,"coverable":125},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","recursive_prover","mod.rs"],"content":"pub mod prover;\npub mod recursive_circuit;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","recursive_prover","prover.rs"],"content":"use plonky2::{\n    hash::{\n        hash_types::{HashOut, RichField},\n        poseidon::PoseidonHash,\n    },\n    iop::witness::PartialWitness,\n    plonk::{\n        circuit_data::{CircuitData, VerifierOnlyCircuitData},\n        config::{AlgebraicHasher, GenericConfig, Hasher},\n        proof::ProofWithPublicInputs,\n        prover::prove,\n    },\n};\nuse plonky2_field::extension::Extendable;\n\nuse tracing::error;\n\nuse crate::{\n    circuit_utils::prove_timing,\n    types::{D, F},\n};\n\nuse super::recursive_circuit::RecursiveTargets;\n\npub struct RecursiveProver\u003cC: GenericConfig\u003cD, F = F\u003e, const N: usize\u003e {\n    // pub batch_id: usize,\n    pub sub_proofs: [ProofWithPublicInputs\u003cF, C, D\u003e; N],\n    pub sub_circuit_vd: VerifierOnlyCircuitData\u003cC, D\u003e,\n}\n\nimpl\u003cC: GenericConfig\u003cD, F = F\u003e, const N: usize\u003e RecursiveProver\u003cC, N\u003e {\n    /// Get proof with a pre-compiled merkle sum circuit and recursive targets. In this method we do not need to build the circuit as we use a pre-built circuit.\n    pub fn get_proof_with_circuit_data(\n        \u0026self,\n        recursive_targets: RecursiveTargets\u003cN\u003e,\n        cd: \u0026CircuitData\u003cF, C, D\u003e,\n    ) -\u003e ProofWithPublicInputs\u003cF, C, D\u003e\n    where\n        \u003cC as GenericConfig\u003c2\u003e\u003e::Hasher: AlgebraicHasher\u003cF\u003e,\n    {\n        let mut pw = PartialWitness::\u003cF\u003e::new();\n        let CircuitData { prover_only, common, .. } = \u0026cd;\n\n        recursive_targets.set_targets(\u0026mut pw, self.sub_proofs.to_vec(), \u0026self.sub_circuit_vd);\n\n        let mut t = prove_timing();\n        let proof_res = prove(prover_only, common, pw, \u0026mut t);\n\n        match proof_res {\n            Ok(proof) =\u003e {\n                let proof_verification_res = cd.verify(proof.clone());\n                match proof_verification_res {\n                    Ok(_) =\u003e proof,\n                    Err(e) =\u003e {\n                        error!(\"Proof verification failed: {:?}\", e);\n                        panic!(\"Proof verification failed!\");\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                error!(\"Proof generation failed: {:?}\", e);\n                panic!(\"Proof generation failed!\");\n            }\n        }\n    }\n}\n\npub fn hash_n_subhashes\u003cF: RichField + Extendable\u003cD\u003e, const D: usize\u003e(\n    hashes: \u0026Vec\u003cHashOut\u003cF\u003e\u003e,\n) -\u003e HashOut\u003cF\u003e {\n    let inputs: Vec\u003cF\u003e = hashes.iter().map(|h| h.elements.to_vec()).flatten().collect();\n    let hash = PoseidonHash::hash_no_pad(inputs.as_slice());\n    hash\n}\n","traces":[{"line":33,"address":[9181854,9180393,9177856],"length":1,"stats":{"Line":0}},{"line":41,"address":[9177911],"length":1,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[9178289],"length":1,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[9179396,9179728,9179595,9178980,9179857,9179924,9180115],"length":1,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[9178400],"length":1,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[12930443,12930208],"length":1,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":21},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","recursive_prover","recursive_circuit.rs"],"content":"use plonky2::{\n    iop::{\n        target::Target,\n        witness::{PartialWitness, WitnessWrite},\n    },\n    plonk::{\n        circuit_builder::CircuitBuilder,\n        circuit_data::{\n            CircuitConfig, CircuitData, CommonCircuitData, VerifierCircuitTarget,\n            VerifierOnlyCircuitData,\n        },\n        config::{AlgebraicHasher, GenericConfig},\n        proof::{ProofWithPublicInputs, ProofWithPublicInputsTarget},\n    },\n};\n\nuse crate::merkle_sum_prover::circuits::merkle_sum_circuit::MerkleSumNodeTarget;\n\nuse crate::types::{C, D, F};\n\n/// Struct representing the targets of a recusive circuit. Since we have the same type of subproofs, we only need one type of verifier circuit as\n/// we can verify all the targets using the same circuit.\n#[derive(Clone)]\npub struct RecursiveTargets\u003cconst N: usize\u003e {\n    pub proof_with_pub_input_targets: Vec\u003cProofWithPublicInputsTarget\u003cD\u003e\u003e,\n    pub verifier_circuit_target: VerifierCircuitTarget, // Only one needed instead of N\n}\n\nimpl\u003cconst N: usize\u003e RecursiveTargets\u003cN\u003e {\n    pub fn pub_input_hash_offset() -\u003e std::ops::Range\u003cusize\u003e {\n        // the hash offset of recursive pub input is the same as the merkle sum tree node target\n        MerkleSumNodeTarget::pub_input_root_hash_offset()\n    }\n\n    #[inline]\n    pub fn pub_input_equity_offset() -\u003e usize {\n        MerkleSumNodeTarget::pub_input_equity_offset()\n    }\n\n    #[inline]\n    pub fn pub_input_debt_offset() -\u003e usize {\n        MerkleSumNodeTarget::pub_input_debt_offset()\n    }\n\n    /// Builds a N-ary merkle sum tree and sets its root as a public input. We use a N-ary merkle sum tree instead of the binary one since it requires less hash gates.\n    pub fn build_recursive_merkle_sum_tree_circuit(\u0026mut self, builder: \u0026mut CircuitBuilder\u003cF, D\u003e) {\n        let mut merkle_sum_tree_node_targets: Vec\u003cMerkleSumNodeTarget\u003e = Vec::new();\n\n        (0..N).for_each(|i| {\n            let targets = std::mem::take(\u0026mut self.proof_with_pub_input_targets[i].public_inputs);\n            merkle_sum_tree_node_targets.push(MerkleSumNodeTarget::from(targets));\n        });\n\n        let parent_merkle_sum_node_target = MerkleSumNodeTarget::get_parent_from_children::\u003cN\u003e(\n            builder,\n            \u0026merkle_sum_tree_node_targets,\n        );\n\n        (0..N).for_each(|i| {\n            let public_input_target = Vec::\u003cTarget\u003e::from(merkle_sum_tree_node_targets[i]);\n            self.proof_with_pub_input_targets[i].public_inputs = public_input_target;\n        });\n\n        parent_merkle_sum_node_target.register_as_public_input(builder);\n    }\n\n    /// Sets recursive targets with values from subproof PIs and the verifier cd.\n    pub fn set_targets\u003cC: GenericConfig\u003cD, F = F\u003e\u003e(\n        \u0026self,\n        pw: \u0026mut PartialWitness\u003cF\u003e,\n        sub_proofs: Vec\u003cProofWithPublicInputs\u003cF, C, D\u003e\u003e,\n        inner_circuit_vd: \u0026VerifierOnlyCircuitData\u003cC, D\u003e,\n    ) where\n        C::Hasher: AlgebraicHasher\u003cF\u003e,\n    {\n        pw.set_verifier_data_target(\u0026self.verifier_circuit_target, inner_circuit_vd);\n\n        (0..N).for_each(|i| {\n            pw.set_proof_with_pis_target(\u0026self.proof_with_pub_input_targets[i], \u0026sub_proofs[i]);\n        });\n    }\n}\n\n/// We verify N subproofs in the circuit using the verifier CD. We also ensure the verifier data = constant vd_digest in the circuit to ensure the\n/// vd is embedded in circuit.\npub fn verify_n_subproof_circuit\u003c\n    // C: GenericConfig\u003cD, F = F\u003e,\n    InnerC: GenericConfig\u003cD, F = F\u003e,\n    const N: usize,\n\u003e(\n    builder: \u0026mut CircuitBuilder\u003cF, D\u003e,\n    subproof_common_cd: \u0026CommonCircuitData\u003cF, D\u003e,\n    subproof_verifier_cd: \u0026VerifierOnlyCircuitData\u003cInnerC, D\u003e,\n) -\u003e RecursiveTargets\u003cN\u003e\nwhere\n    InnerC::Hasher: AlgebraicHasher\u003cF\u003e,\n{\n    let verifier_circuit_targets = VerifierCircuitTarget {\n        constants_sigmas_cap: builder\n            .add_virtual_cap(subproof_common_cd.config.fri_config.cap_height),\n        circuit_digest: builder.add_virtual_hash(),\n    };\n\n    let vd_digest = subproof_verifier_cd.circuit_digest;\n    let vd_digest_target = builder.constant_hash(vd_digest);\n    builder.connect_hashes(verifier_circuit_targets.circuit_digest, vd_digest_target);\n\n    // _inner_verifier_circuit_data.circuit_digest;\n    let mut proof_with_pis_targets: Vec\u003cProofWithPublicInputsTarget\u003cD\u003e\u003e = vec![];\n    (0..N).for_each(|_| {\n        let proof_with_pub_input_target =\n            builder.add_virtual_proof_with_pis::\u003cInnerC\u003e(subproof_common_cd);\n        builder.verify_proof::\u003cInnerC\u003e(\n            \u0026proof_with_pub_input_target,\n            \u0026verifier_circuit_targets,\n            subproof_common_cd,\n        );\n        proof_with_pis_targets.push(proof_with_pub_input_target);\n    });\n\n    RecursiveTargets {\n        verifier_circuit_target: verifier_circuit_targets,\n        proof_with_pub_input_targets: proof_with_pis_targets,\n    }\n}\n\n/// build recursive circuit that proves N subproofs and geneate parent merkle sum node targets\n// This circuit hardcode the constraint that the verifier_circuit_target.circuit_digest must be equal to that inner_verifier_circuit_data.circuit_digest;\npub fn build_recursive_n_circuit\u003c\n    // C: GenericConfig\u003cD, F = F\u003e,\n    InnerC: GenericConfig\u003cD, F = F\u003e,\n    const N: usize,\n\u003e(\n    inner_common_circuit_data: \u0026CommonCircuitData\u003cF, D\u003e,\n    inner_verifier_circuit_data: \u0026VerifierOnlyCircuitData\u003cInnerC, D\u003e,\n    circuit_config: CircuitConfig,\n) -\u003e (CircuitData\u003cF, C, D\u003e, RecursiveTargets\u003cN\u003e)\nwhere\n    InnerC::Hasher: AlgebraicHasher\u003cF\u003e,\n{\n    let mut builder = CircuitBuilder::\u003cF, D\u003e::new(circuit_config);\n    let mut recursive_targets = verify_n_subproof_circuit(\n        \u0026mut builder,\n        inner_common_circuit_data,\n        inner_verifier_circuit_data,\n    );\n    recursive_targets.build_recursive_merkle_sum_tree_circuit(\u0026mut builder);\n    let circuit_data = builder.build::\u003cC\u003e();\n    (circuit_data, recursive_targets)\n}\n","traces":[{"line":30,"address":[8924960],"length":1,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[8925234,8924992],"length":1,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[8924640,8924799],"length":1,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[8927127,8926256],"length":1,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[8926543],"length":1,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[8925824,8926205],"length":1,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":44},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","types.rs"],"content":"use plonky2::plonk::{\n    circuit_data::{CommonCircuitData, VerifierOnlyCircuitData},\n    config::{GenericConfig, PoseidonGoldilocksConfig},\n    proof::ProofWithPublicInputs,\n};\n\n// Extension of size 2\npub const D: usize = 2;\n\n// Constrict our values to 62 bits.\npub const MAX_POSITIVE_AMOUNT_LOG: usize = 62;\n\n// Number of accounts in one merkle sum tree batch.\npub const MERKLE_SUM_TREE_BATCH_SIZE: usize = 1;\n\npub type C = PoseidonGoldilocksConfig;\npub type F = \u003cC as GenericConfig\u003cD\u003e\u003e::F;\n\npub type ProofTuple\u003cF, C, const D: usize\u003e =\n    (ProofWithPublicInputs\u003cF, C, D\u003e, VerifierOnlyCircuitData\u003cC, D\u003e, CommonCircuitData\u003cF, D\u003e);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","src","util.rs"],"content":"use crate::types::F;\nuse plonky2::hash::hash_types::HashOut;\nuse plonky2_field::types::Field;\n\npub fn pad_to_multiple_of(n: usize, multiple: usize) -\u003e usize {\n    if multiple == 0 {\n        return n; // Avoid division by zero\n    }\n    let remainder = n % multiple;\n    if remainder == 0 {\n        n\n    } else {\n        n + multiple - remainder\n    }\n}\n\n/// node level is the level from tree root; the root node has level of 0;\n/// `node_idx` is the index of the nodes in a vector; the root node has the largest ndoe_idx\npub fn get_node_level(batch_size: usize, node_idx: usize) -\u003e usize {\n    let total_nums = 2 * batch_size - 1;\n    ((total_nums - node_idx) as f64).log(2.0).floor() as usize\n}\n\n/// Given a hash string, get a hashout\npub fn get_hash_from_hash_string(hash_string: String) -\u003e HashOut\u003cF\u003e {\n    let without_brackets = hash_string.trim_matches(|c| c == '[' || c == ']').to_string(); // Remove brackets\n\n    let hash_as_vec_f: Vec\u003cF\u003e = without_brackets\n        .split(',')\n        .map(|s| F::from_canonical_u64(s.parse::\u003cu64\u003e().unwrap()))\n        .collect();\n\n    if hash_as_vec_f.len() != 4 {\n        panic!(\"Incorrect format of hash\");\n    }\n\n    HashOut::from_vec(hash_as_vec_f)\n}\n\n#[cfg(test)]\npub mod test_util {\n    use plonky2::hash::hash_types::HashOut;\n\n    use crate::util::get_node_level;\n\n    use super::{get_hash_from_hash_string, pad_to_multiple_of};\n\n    #[test]\n    fn test_get_node_level() {\n        assert_eq!(get_node_level(8, 14), 0);\n        assert_eq!(get_node_level(8, 13), 1);\n        assert_eq!(get_node_level(8, 9), 2);\n        assert_eq!(get_node_level(8, 11), 2);\n        assert_eq!(get_node_level(8, 0), 3);\n        assert_eq!(get_node_level(8, 4), 3);\n        assert_eq!(get_node_level(8, 7), 3);\n    }\n\n    #[test]\n    fn test_pad_to_multiple_of() {\n        assert_eq!(pad_to_multiple_of(23, 4), 24);\n        assert_eq!(pad_to_multiple_of(24, 4), 24);\n        assert_eq!(pad_to_multiple_of(27, 4), 28);\n    }\n\n    #[test]\n    fn test_get_hash_from_hash_string() {\n        let hash = get_hash_from_hash_string(\"[0000,0000,0000,0000]\".to_string());\n        assert_eq!(hash, HashOut::ZERO);\n    }\n}\n","traces":[{"line":5,"address":[8772176],"length":1,"stats":{"Line":1}},{"line":6,"address":[12930568],"length":1,"stats":{"Line":1}},{"line":7,"address":[12930579],"length":1,"stats":{"Line":0}},{"line":9,"address":[12930591,12930642,12930619],"length":1,"stats":{"Line":2}},{"line":10,"address":[12930634,12930668,12930745],"length":1,"stats":{"Line":3}},{"line":11,"address":[12930663],"length":1,"stats":{"Line":1}},{"line":13,"address":[12930680,12930750],"length":1,"stats":{"Line":1}},{"line":19,"address":[12930768],"length":1,"stats":{"Line":1}},{"line":20,"address":[12930790,12930885],"length":1,"stats":{"Line":1}},{"line":21,"address":[12931044,12930864,12930905],"length":1,"stats":{"Line":2}},{"line":25,"address":[12931072,12931627],"length":1,"stats":{"Line":1}},{"line":26,"address":[12931102,12931664,12931677,12931178],"length":1,"stats":{"Line":4}},{"line":28,"address":[12931226,12931294],"length":1,"stats":{"Line":2}},{"line":30,"address":[12931728,12931747,12931915],"length":1,"stats":{"Line":3}},{"line":33,"address":[12931442,12931377],"length":1,"stats":{"Line":2}},{"line":34,"address":[12931506,12931580],"length":1,"stats":{"Line":0}},{"line":37,"address":[12931453],"length":1,"stats":{"Line":1}}],"covered":15,"coverable":17},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","tests","e2e.rs"],"content":"use plonky2_field::types::Field;\nuse zk_por_core::{\n    account::gen_accounts_with_random_data,\n    circuit_config::STANDARD_CONFIG,\n    circuit_registry::registry::CircuitRegistry,\n    e2e::{batch_prove_accounts, recursive_prove_subproofs},\n    types::F,\n};\n\nuse zk_por_tracing::{init_tracing, TraceConfig};\n\n#[test]\nfn test_prove() {\n    let cfg = TraceConfig {\n        prefix: \"zkpor\".to_string(),\n        dir: \"logs\".to_string(),\n        level: tracing::Level::DEBUG,\n        console: true,\n        flame: false,\n    };\n\n    {\n        init_tracing(cfg)\n    };\n\n    const RECURSION_BRANCHOUT_NUM: usize = 4;\n    let batch_size = 8;\n    let token_num = 4;\n\n    let circuit_registry = CircuitRegistry::\u003cRECURSION_BRANCHOUT_NUM\u003e::init(\n        batch_size,\n        token_num,\n        STANDARD_CONFIG,\n        vec![STANDARD_CONFIG; 2],\n    );\n\n    let proving_thread_num = 2;\n\n    // a total of 9 batches (3x3) to test for padding in each level.\n    let mut equity_sum = 0;\n    let mut debt_sum = 0;\n    let mut batch_proofs = vec![];\n    for _ in 0..3 {\n        let accounts = gen_accounts_with_random_data(batch_size * 3, 4);\n\n        equity_sum += accounts\n            .iter()\n            .map(|account| account.equity.iter().map(|e| e.0).sum::\u003cu64\u003e())\n            .sum::\u003cu64\u003e();\n        debt_sum += accounts\n            .iter()\n            .map(|account| account.debt.iter().map(|e| e.0).sum::\u003cu64\u003e())\n            .sum::\u003cu64\u003e();\n\n        let proofs =\n            batch_prove_accounts(\u0026circuit_registry, accounts, proving_thread_num, batch_size);\n        batch_proofs.extend(proofs.into_iter());\n    }\n\n    let root_proof = recursive_prove_subproofs(batch_proofs, \u0026circuit_registry, proving_thread_num);\n\n    tracing::debug!(\"equity_sum: {}, debt_sum: {}\", equity_sum, debt_sum);\n    assert_eq!(F::from_canonical_u64(equity_sum), root_proof.public_inputs[0],);\n    assert_eq!(F::from_canonical_u64(debt_sum), root_proof.public_inputs[1],);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","tests","recursive_circuit.rs"],"content":"use plonky2::{hash::hash_types::HashOut, plonk::proof::ProofWithPublicInputs};\nuse zk_por_core::{\n    account::gen_accounts_with_random_data,\n    circuit_config::STANDARD_CONFIG,\n    merkle_sum_prover::circuits::merkle_sum_circuit::build_merkle_sum_tree_circuit,\n    recursive_prover::{prover::RecursiveProver, recursive_circuit::RecursiveTargets},\n    types::{C, D, F},\n};\n\nuse zk_por_core::{\n    merkle_sum_prover::prover::MerkleSumTreeProver,\n    recursive_prover::{prover::hash_n_subhashes, recursive_circuit::build_recursive_n_circuit},\n};\n\nuse plonky2_field::types::Field;\n\n#[test]\nfn test() {\n    let batch_size = 4;\n    let token_num = 2;\n    const RECURSION_BRANCHOUT_NUM: usize = 8;\n\n    let accounts = gen_accounts_with_random_data(batch_size, token_num);\n\n    let equity_sum = accounts\n        .iter()\n        .fold(F::ZERO, |acc, x| acc + x.equity.iter().fold(F::ZERO, |acc_2, y| acc_2 + *y));\n\n    let debt_sum = accounts\n        .iter()\n        .fold(F::ZERO, |acc, x| acc + x.debt.iter().fold(F::ZERO, |acc_2, y| acc_2 + *y));\n\n    let start = std::time::Instant::now();\n    let (merkle_sum_circuit, account_targets) =\n        build_merkle_sum_tree_circuit(batch_size, token_num, STANDARD_CONFIG);\n    println!(\"build merkle sum tree circuit in : {:?}\", start.elapsed());\n\n    let prover = MerkleSumTreeProver { accounts };\n\n    let start = std::time::Instant::now();\n    let merkle_sum_proof =\n        prover.get_proof_with_circuit_data(account_targets.as_slice(), \u0026merkle_sum_circuit);\n    println!(\"prove merkle sum tree in : {:?}\", start.elapsed());\n\n    let sub_proofs: [ProofWithPublicInputs\u003cF, C, D\u003e; RECURSION_BRANCHOUT_NUM] =\n        std::array::from_fn(|_| merkle_sum_proof.clone());\n\n    let start = std::time::Instant::now();\n    let (recursive_circuit, recursive_targets) =\n        build_recursive_n_circuit::\u003cC, RECURSION_BRANCHOUT_NUM\u003e(\n            \u0026merkle_sum_circuit.common,\n            \u0026merkle_sum_circuit.verifier_only,\n            STANDARD_CONFIG,\n        );\n    println!(\"build recursive N circuit in : {:?}\", start.elapsed());\n\n    let start = std::time::Instant::now();\n    let hash_offset = RecursiveTargets::\u003cRECURSION_BRANCHOUT_NUM\u003e::pub_input_hash_offset();\n    let subhashes = sub_proofs\n        .clone()\n        .map(|proof| HashOut::\u003cF\u003e::from_partial(\u0026proof.public_inputs[hash_offset.clone()]));\n    let recursive_prover = RecursiveProver {\n        sub_proofs: sub_proofs,\n        sub_circuit_vd: merkle_sum_circuit.verifier_only.clone(),\n    };\n    let recursive_proof_result =\n        recursive_prover.get_proof_with_circuit_data(recursive_targets, \u0026recursive_circuit);\n    println!(\"prove recursive subproofs in : {:?}\", start.elapsed());\n\n    let expected_hash = hash_n_subhashes::\u003cF, D\u003e(\u0026subhashes.to_vec());\n    let actual_hash =\n        HashOut::\u003cF\u003e::from_partial(\u0026recursive_proof_result.public_inputs[hash_offset]);\n\n    assert_eq!(expected_hash, actual_hash);\n\n    // print public inputs in recursive proof\n    assert_eq!(\n        equity_sum * F::from_canonical_u32(RECURSION_BRANCHOUT_NUM as u32),\n        recursive_proof_result.public_inputs[0]\n    );\n    assert_eq!(\n        debt_sum * F::from_canonical_u32(RECURSION_BRANCHOUT_NUM as u32),\n        recursive_proof_result.public_inputs[1]\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-core","tests","registry.rs"],"content":"use plonky2_field::types::Field;\nuse zk_por_core::{circuit_registry::registry::CircuitRegistry, types::F};\n\n#[test]\nfn test() {\n    let batch_circuit_config = zk_por_core::circuit_config::STANDARD_CONFIG;\n    let recursive_levels = 2;\n    let recursive_level_configs = vec![zk_por_core::circuit_config::STANDARD_CONFIG; 2];\n\n    let registry =\n        CircuitRegistry::\u003c2\u003e::init(1024, 2, batch_circuit_config, recursive_level_configs);\n\n    let batch_circuit = registry.get_batch_circuit().0;\n    let batch_proof =\n        registry.get_empty_proof(\u0026batch_circuit.verifier_only.circuit_digest).unwrap().clone();\n\n    assert_eq!(recursive_levels, registry.get_recursive_levels());\n    assert_eq!(F::ZERO, batch_proof.public_inputs[0]);\n    assert_eq!(F::ZERO, batch_proof.public_inputs[1]);\n    assert!(batch_circuit.verify(batch_proof).is_ok());\n    let mut inner_vd_digest = batch_circuit.verifier_only.circuit_digest;\n\n    for _ in 0..recursive_levels {\n        let recursive_circuit = registry.get_recursive_circuit(\u0026inner_vd_digest).unwrap().0;\n        let recursive_empty_proof =\n            registry.get_empty_proof(\u0026recursive_circuit.verifier_only.circuit_digest).unwrap();\n\n        assert_eq!(F::ZERO, recursive_empty_proof.public_inputs[0]);\n        assert_eq!(F::ZERO, recursive_empty_proof.public_inputs[1]);\n        assert!(recursive_circuit.verify(recursive_empty_proof.clone()).is_ok());\n\n        inner_vd_digest = recursive_circuit.verifier_only.circuit_digest;\n    }\n    let root_circuit = registry.get_root_circuit();\n    assert_eq!(inner_vd_digest, root_circuit.verifier_only.circuit_digest);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-db","src","lib.rs"],"content":"extern crate leveldb;\nextern crate tempdir;\n\nuse leveldb::{\n    database::{\n        batch::{Batch, Writebatch},\n        Database,\n    },\n    kv::KV,\n    options::{Options, ReadOptions, WriteOptions},\n};\nuse tracing::warn;\n\npub struct LevelDb\u003cK: db_key::Key\u003e {\n    db: Database\u003cK\u003e,\n}\n\nimpl\u003cK: db_key::Key\u003e LevelDb\u003cK\u003e {\n    pub fn new(db_path: \u0026std::path::PathBuf) -\u003e Self {\n        let mut options = Options::new();\n        options.create_if_missing = true;\n\n        let database = match Database::\u003cK\u003e::open(db_path, options) {\n            Ok(db) =\u003e db,\n            Err(e) =\u003e {\n                panic!(\"Failed to open database: {:?}\", e);\n            }\n        };\n        Self { db: database }\n    }\n\n    pub fn put(\u0026self, key: K, val: \u0026[u8]) {\n        let write_opts = WriteOptions::new();\n\n        match self.db.put(write_opts, key, val) {\n            Ok(_) =\u003e (),\n            Err(e) =\u003e panic!(\"Failed to write key-value pair: {:?}\", e),\n        }\n    }\n\n    /// input is a vector of (k,v) tuple\n    pub fn batch_put(\u0026self, batches: Vec\u003c(K, Vec\u003cu8\u003e)\u003e) {\n        let mut batch = Writebatch::\u003cK\u003e::new();\n        batches.into_iter().for_each(|(k, v)| {\n            batch.put(k, v.as_ref());\n        });\n\n        match self.db.write(WriteOptions::new(), \u0026batch) {\n            Ok(_) =\u003e (),\n            Err(e) =\u003e panic!(\"Batch write failed: {}\", e),\n        }\n    }\n\n    pub fn get(\u0026self, key: K) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        let read_opts = ReadOptions::new();\n        match self.db.get(read_opts, key) {\n            Ok(val) =\u003e val,\n            Err(e) =\u003e {\n                warn!(\"Failed to read value: {:?}\", e);\n                None\n            }\n        }\n    }\n\n    pub fn delete(\u0026self, key: K) {\n        let write_opts = WriteOptions::new();\n        match self.db.delete(write_opts, key) {\n            Ok(_) =\u003e (),\n            Err(e) =\u003e warn!(\"Failed to delete key: {:?}\", e),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n\n    use tempdir::TempDir;\n\n    use crate::LevelDb;\n\n    #[test]\n    fn test_db_i32() {\n        let tempdir = TempDir::new(\"example\").unwrap();\n        let db = LevelDb::\u003ci32\u003e::new(\u0026tempdir.path().to_path_buf());\n        db.put(1, b\"hello\");\n        db.put(2, b\"world\");\n        let ret = db.get(1).unwrap();\n\n        assert_eq!(ret, b\"hello\");\n        db.delete(1);\n        let ret = db.get(1);\n        assert_eq!(ret, None);\n        db.delete(2);\n    }\n}\n","traces":[{"line":19,"address":[8686726,8686128,8686086,8685488],"length":1,"stats":{"Line":3}},{"line":20,"address":[785869],"length":1,"stats":{"Line":3}},{"line":21,"address":[785904],"length":1,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":6}},{"line":24,"address":[],"length":0,"stats":{"Line":3}},{"line":25,"address":[8686447,8685807],"length":1,"stats":{"Line":0}},{"line":26,"address":[12858860,12858220],"length":1,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[786843,786710],"length":1,"stats":{"Line":0}},{"line":42,"address":[12858976,12860277,12859605,12859577,12859648,12860249],"length":1,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":8}},{"line":45,"address":[12860764,12860498,12860586,12860362],"length":1,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[12855688,12853792,12857571,12855712],"length":1,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[12854092,12855980],"length":1,"stats":{"Line":0}},{"line":59,"address":[12857061,12856625,12855434,12856930,12856812,12857128,12857318,12854342,12854924,12855042,12854737,12855243,12855176,12856230],"length":1,"stats":{"Line":0}},{"line":60,"address":[788267],"length":1,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[788879,788964],"length":1,"stats":{"Line":2}},{"line":67,"address":[788976],"length":1,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[790141,789668,789042,790077,789855,790327,789225,789967],"length":1,"stats":{"Line":0}}],"covered":20,"coverable":31},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-tracing","src","lib.rs"],"content":"pub mod opentelemetry;\n\nuse crate::opentelemetry::exporter::stdout;\nuse tracing::Level;\npub use tracing_appender::non_blocking::WorkerGuard;\nuse tracing_appender::rolling;\nuse tracing_flame::FlameLayer;\nuse tracing_opentelemetry::OpenTelemetryLayer;\nuse tracing_subscriber::{fmt, prelude::*};\n\n#[derive(Debug)]\npub struct TraceConfig {\n    pub prefix: String,\n    pub dir: String,\n    pub level: Level,\n    pub console: bool,\n    pub flame: bool,\n}\n\npub fn init_tracing(config: TraceConfig) -\u003e Vec\u003cWorkerGuard\u003e {\n    let prefix = config.prefix;\n    let dir = config.dir;\n    let level = config.level;\n    let console = config.console;\n    let flame = config.flame;\n\n    let mut guards = vec![];\n    let (fmt_writer, fmt_guard) = tracing_appender::non_blocking(rolling::daily(\u0026dir, \u0026prefix));\n    guards.push(fmt_guard);\n    let (telemetry_writer, telemetry_guard) =\n        tracing_appender::non_blocking(rolling::daily(\u0026dir, prefix.clone() + \".telemetry\"));\n    guards.push(telemetry_guard);\n    let tracer = stdout::new_pipeline().with_writer(telemetry_writer).install_simple();\n    let layered = tracing_subscriber::fmt()\n        .with_max_level(level)\n        .with_writer(fmt_writer)\n        .with_ansi(false)\n        .finish()\n        .with(OpenTelemetryLayer::new(tracer));\n    if flame {\n        let (folded_writer, folded_guard) =\n            tracing_appender::non_blocking(rolling::daily(\u0026dir, prefix.clone() + \".folded\"));\n        guards.push(folded_guard);\n        if console {\n            layered.with(fmt::Layer::default()).with(FlameLayer::new(folded_writer)).init();\n        } else {\n            layered.with(FlameLayer::new(folded_writer)).init()\n        }\n    } else if console {\n        layered.with(fmt::Layer::default()).init();\n    } else {\n        layered.init()\n    }\n\n    guards\n}\n","traces":[{"line":20,"address":[12657600,12660920,12659599],"length":1,"stats":{"Line":1}},{"line":21,"address":[4460431],"length":1,"stats":{"Line":1}},{"line":22,"address":[4460553],"length":1,"stats":{"Line":1}},{"line":23,"address":[4460571],"length":1,"stats":{"Line":1}},{"line":24,"address":[12657803],"length":1,"stats":{"Line":1}},{"line":25,"address":[4460603],"length":1,"stats":{"Line":1}},{"line":27,"address":[13565643],"length":1,"stats":{"Line":1}},{"line":28,"address":[4460747,4460690],"length":1,"stats":{"Line":2}},{"line":29,"address":[12658098],"length":1,"stats":{"Line":1}},{"line":30,"address":[13566043],"length":1,"stats":{"Line":1}},{"line":32,"address":[4461221],"length":1,"stats":{"Line":1}},{"line":33,"address":[4461362],"length":1,"stats":{"Line":1}},{"line":34,"address":[4461552,4461822,4461471,4461623],"length":1,"stats":{"Line":4}},{"line":36,"address":[4461559],"length":1,"stats":{"Line":1}},{"line":39,"address":[13566770,13566957,13568572],"length":1,"stats":{"Line":2}},{"line":40,"address":[4461881,4462935],"length":1,"stats":{"Line":1}},{"line":41,"address":[13566987,13567416],"length":1,"stats":{"Line":0}},{"line":43,"address":[4462502],"length":1,"stats":{"Line":0}},{"line":44,"address":[13567763],"length":1,"stats":{"Line":0}},{"line":45,"address":[4462754,4462958,4463298],"length":1,"stats":{"Line":0}},{"line":47,"address":[4462645,4462948,4462818],"length":1,"stats":{"Line":0}},{"line":49,"address":[4463326,4462919,4461889,4462594],"length":1,"stats":{"Line":1}},{"line":50,"address":[4461977,4462173],"length":1,"stats":{"Line":1}},{"line":52,"address":[4461922,4462082],"length":1,"stats":{"Line":0}},{"line":55,"address":[4462089],"length":1,"stats":{"Line":1}}],"covered":19,"coverable":25},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-tracing","src","opentelemetry","exporter","stdout.rs"],"content":"//! # Stdout Span Exporter\n//!\n//! The stdout [`SpanExporter`] writes debug printed [`Span`]s to its configured\n//! [`Write`] instance. By default it will write to [`Stdout`].\n//!\n//! [`SpanExporter`]: super::SpanExporter\n//! [`Span`]: crate::trace::Span\n//! [`Write`]: Write\n//! [`Stdout`]: Stdout\n//!\n//! # Examples\n//!\n//! ```no_run\n//! use opentelemetry::trace::Tracer;\n//! use opentelemetry::sdk::export::trace::stdout;\n//! use opentelemetry::global::shutdown_tracer_provider;\n//!\n//! fn main() {\n//!     let tracer = stdout::new_pipeline()\n//!         .with_pretty_print(true)\n//!         .install_simple();\n//!\n//!     tracer.in_span(\"doing_work\", |cx| {\n//!         // Traced app logic here...\n//!     });\n//!\n//!     shutdown_tracer_provider(); // sending remaining spans\n//! }\n//! ```\n#![allow(clippy::needless_doctest_main)]\nuse async_trait::async_trait;\nuse opentelemetry::{\n    global, sdk,\n    sdk::export::{\n        trace::{ExportResult, SpanData, SpanExporter},\n        ExportError,\n    },\n    trace::TracerProvider,\n};\nuse std::{\n    fmt::Debug,\n    io::{stdout, Stdout, Write},\n};\n\n/// Pipeline builder\n#[derive(Debug)]\npub struct PipelineBuilder\u003cW: Write\u003e {\n    pretty_print: bool,\n    trace_config: Option\u003csdk::trace::Config\u003e,\n    writer: W,\n}\n\n/// Create a new stdout exporter pipeline builder.\npub fn new_pipeline() -\u003e PipelineBuilder\u003cStdout\u003e {\n    PipelineBuilder::default()\n}\n\nimpl Default for PipelineBuilder\u003cStdout\u003e {\n    /// Return the default pipeline builder.\n    fn default() -\u003e Self {\n        Self { pretty_print: false, trace_config: None, writer: stdout() }\n    }\n}\n\nimpl\u003cW: Write\u003e PipelineBuilder\u003cW\u003e {\n    /// Specify the pretty print setting.\n    pub fn with_pretty_print(mut self, pretty_print: bool) -\u003e Self {\n        self.pretty_print = pretty_print;\n        self\n    }\n\n    /// Assign the SDK trace configuration.\n    pub fn with_trace_config(mut self, config: sdk::trace::Config) -\u003e Self {\n        self.trace_config = Some(config);\n        self\n    }\n\n    /// Specify the writer to use.\n    pub fn with_writer\u003cT: Write\u003e(self, writer: T) -\u003e PipelineBuilder\u003cT\u003e {\n        PipelineBuilder { pretty_print: self.pretty_print, trace_config: self.trace_config, writer }\n    }\n}\n\nimpl\u003cW\u003e PipelineBuilder\u003cW\u003e\nwhere\n    W: Write + Debug + Send + 'static,\n{\n    /// Install the stdout exporter pipeline with the recommended defaults.\n    pub fn install_simple(mut self) -\u003e sdk::trace::Tracer {\n        let exporter = Exporter::new(self.writer, self.pretty_print);\n\n        let mut provider_builder =\n            sdk::trace::TracerProvider::builder().with_simple_exporter(exporter);\n        if let Some(config) = self.trace_config.take() {\n            provider_builder = provider_builder.with_config(config);\n        }\n        let provider = provider_builder.build();\n\n        let tracer =\n            provider.versioned_tracer(\"opentelemetry\", Some(env!(\"CARGO_PKG_VERSION\")), None);\n        let _ = global::set_tracer_provider(provider);\n\n        tracer\n    }\n}\n\n/// A [`SpanExporter`] that writes to [`Stdout`] or other configured [`Write`].\n///\n/// [`SpanExporter`]: super::SpanExporter\n/// [`Write`]: Write\n/// [`Stdout`]: Stdout\n#[derive(Debug)]\npub struct Exporter\u003cW: Write\u003e {\n    writer: W,\n    pretty_print: bool,\n}\n\nimpl\u003cW: Write\u003e Exporter\u003cW\u003e {\n    /// Create a new stdout `Exporter`.\n    pub fn new(writer: W, pretty_print: bool) -\u003e Self {\n        Self { writer, pretty_print }\n    }\n}\n\n#[async_trait]\nimpl\u003cW\u003e SpanExporter for Exporter\u003cW\u003e\nwhere\n    W: Write + Debug + Send + 'static,\n{\n    /// Export spans to stdout\n    async fn export(\u0026mut self, batch: Vec\u003cSpanData\u003e) -\u003e ExportResult {\n        for span in batch {\n            let json = if self.pretty_print {\n                serde_json::to_string_pretty(\u0026span).map_err::\u003cError, _\u003e(Into::into)?\n            } else {\n                serde_json::to_string(\u0026span).map_err::\u003cError, _\u003e(Into::into)?\n            };\n            self.writer.write_all(json.as_bytes()).map_err::\u003cError, _\u003e(Into::into)?;\n            self.writer.write_all(\"\\n\".as_bytes()).map_err::\u003cError, _\u003e(Into::into)?;\n        }\n\n        Ok(())\n    }\n}\n\n/// Stdout exporter's error\n#[derive(thiserror::Error, Debug)]\n#[error(transparent)]\nenum Error {\n    Json(#[from] serde_json::Error),\n    Io(#[from] std::io::Error),\n}\n\nimpl ExportError for Error {\n    fn exporter_name(\u0026self) -\u003e \u0026'static str {\n        \"stdout\"\n    }\n}\n","traces":[{"line":54,"address":[12854800],"length":1,"stats":{"Line":1}},{"line":55,"address":[13762616],"length":1,"stats":{"Line":1}},{"line":60,"address":[4298160,4298279],"length":1,"stats":{"Line":1}},{"line":61,"address":[13762653],"length":1,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[13762803],"length":1,"stats":{"Line":1}},{"line":89,"address":[4298432,4299686,4299754],"length":1,"stats":{"Line":1}},{"line":90,"address":[4298454,4298575],"length":1,"stats":{"Line":2}},{"line":92,"address":[13763067,13763124],"length":1,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[13763219,13763283,13763616],"length":1,"stats":{"Line":2}},{"line":95,"address":[4299090,4298904],"length":1,"stats":{"Line":0}},{"line":97,"address":[12855832,12856003],"length":1,"stats":{"Line":2}},{"line":99,"address":[4299335],"length":1,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[12856268,12856180],"length":1,"stats":{"Line":2}},{"line":103,"address":[13764116],"length":1,"stats":{"Line":1}},{"line":120,"address":[12856464],"length":1,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[13766034,13765314,13765737],"length":1,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[13765451,13765552,13765739,13765825],"length":1,"stats":{"Line":0}},{"line":138,"address":[13766159,13766309,13765805,13766631],"length":1,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[4299840],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":33},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-tracing","src","opentelemetry","exporter.rs"],"content":"pub mod stdout;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","proof-of-reserves-v2","proof-of-reserves-v2","crates","zk-por-tracing","src","opentelemetry.rs"],"content":"pub mod exporter;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>